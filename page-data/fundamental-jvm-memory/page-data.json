{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/fundamental-jvm-memory/",
    "result": {"data":{"cur":{"id":"5f019a9d-4ba5-5404-8fb7-15a85aac4e66","html":"<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#step-1-%EC%9E%90%EB%B0%94-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC\">STEP 1. 자바 메모리 관리</a></p>\n</li>\n<li>\n<p><a href=\"#step-2-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD\">STEP 2. 메모리 영역</a></p>\n<ul>\n<li><a href=\"#step-21-%EC%8A%A4%ED%83%9D-%EC%98%81%EC%97%AD\">STEP 2.1 스택 영역</a></li>\n<li><a href=\"#step-22-%ED%9E%99-%EC%98%81%EC%97%AD\">STEP 2.2 힙 영역</a></li>\n<li><a href=\"#step-23-%EB%B2%88%EC%99%B8-%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4-%ED%83%80%EC%9E%85-%EC%82%AC%EC%9A%A9-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD\">STEP 2.3 번외) 레퍼런스 타입 사용 주의사항</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-3-%EC%8B%A4%ED%96%89-%EC%97%94%EC%A7%84\">STEP 3. 실행 엔진</a></p>\n<ul>\n<li>\n<p><a href=\"#step-31-gc\">STEP 3.1 GC</a></p>\n<ul>\n<li><a href=\"#step-311-gc-root-set\">STEP 3.1.1 GC Root Set</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-32-%EC%8B%9D%EB%B3%84-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">STEP 3.2 식별 알고리즘</a></p>\n<ul>\n<li><a href=\"#step-321-%EC%8A%A4%ED%83%91-%EB%8D%94-%EC%9B%94%EB%93%9C\">STEP 3.2.1 스탑-더-월드</a></li>\n<li><a href=\"#step-322-%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4-%EC%B9%B4%EC%9A%B4%ED%8C%85\">STEP 3.2.2 레퍼런스 카운팅</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-33-%EC%A0%95%EB%A6%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">STEP 3.3 정리 알고리즘</a></p>\n<ul>\n<li><a href=\"#step-331-%EA%B8%B0%EB%B3%B8-%EC%A0%95%EB%A6%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">STEP 3.3.1 기본 정리 알고리즘</a></li>\n<li><a href=\"#step-332-%EC%95%95%EC%B6%95-%EC%A0%95%EB%A6%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">STEP 3.3.2 압축-정리 알고리즘</a></li>\n<li><a href=\"#step-333-%EB%B3%B5%EC%A0%9C-%EC%A0%95%EB%A6%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">STEP 3.3.3 복제-정리 알고리즘</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-34-gc-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A4%91%EA%B0%84-%EC%A0%95%EB%A6%AC\">STEP 3.4 GC 알고리즘 중간 정리</a></p>\n</li>\n<li>\n<p><a href=\"#step-35-generational-algorithm\">STEP 3.5 Generational Algorithm</a></p>\n</li>\n<li>\n<p><a href=\"#step-36-heap%EC%9D%98-%EA%B5%AC%EC%A1%B0%EC%99%80-gc%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EB%8F%99%EC%9E%91\">STEP 3.6 Heap의 구조와 GC의 기본 동작</a></p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-4-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%98%81%EC%97%AD%EB%A9%94%ED%83%80%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4-%EC%98%81%EC%97%AD\">STEP 4. 메서드 영역(메타스페이스 영역)</a></p>\n<ul>\n<li><a href=\"#step-41-%EC%9E%90%EB%B0%94-8-%EC%9D%B4%EC%A0%84%EA%B3%BC-%EC%9D%B4%ED%9B%84%EC%9D%98-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%98%81%EC%97%AD\">STEP 4.1 자바 8 이전과 이후의 메서드 영역</a></li>\n<li><a href=\"#step-42-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%98%81%EC%97%AD%EC%97%90%EC%84%9C%EC%9D%98-gc-%EB%8F%99%EC%9E%91\">STEP 4.2 메서드 영역에서의 GC 동작</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-5-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%88%98%EC%A7%91%EA%B8%B0\">STEP 5. 가비지 수집기</a></p>\n<ul>\n<li><a href=\"#step-51-serial-gc\">STEP 5.1 Serial GC</a></li>\n<li><a href=\"#step-52-parallel-gc\">STEP 5.2 Parallel GC</a></li>\n<li><a href=\"#step-53-cms-gc\">STEP 5.3 CMS GC</a></li>\n<li><a href=\"#step-54-g1garbage-firstgc\">STEP 5.4 G1(Garbage First)GC</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h1 id=\"목차\" style=\"position:relative;\"><a href=\"#%EB%AA%A9%EC%B0%A8\" aria-label=\"목차 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>목차</h1>\n<ul>\n<li>개요</li>\n<li>STEP 1. 자바 메모리 관리</li>\n<li>STEP 2. 메모리 영역\n<ul>\n<li>STEP 2.1 스택 영역</li>\n<li>STEP 2.2 힙 영역</li>\n<li>STEP 2.3 번외) 레퍼런스 타입 사용 주의사항</li>\n</ul>\n</li>\n<li>STEP 3. 실행 엔진\n<ul>\n<li>STEP 3.1 GC\n<ul>\n<li>STEP 3.1.1 Garbage Collections roots</li>\n</ul>\n</li>\n<li>STEP 3.2 식별 알고리즘\n<ul>\n<li>STEP 3.2.1 스탑-더-월드</li>\n<li>STEP 3.2.2 레퍼런스 카운팅</li>\n</ul>\n</li>\n<li>STEP 3.3 정리 알고리즘\n<ul>\n<li>STEP 3.3.1 기본 정리 알고리즘</li>\n<li>STEP 3.3.2 압축-정리 알고리즘</li>\n<li>STEP STEP 3.3.3 복제-정리 알고리즘</li>\n</ul>\n</li>\n<li>STEP 3.4 GC 알고리즘 중간 정리</li>\n<li>STEP 3.5 Generational Algorithm</li>\n<li>STEP 3.6 Heap의 구조와 GC의 기본 동작</li>\n</ul>\n</li>\n<li>STEP 4. 메서드 영역(메타스페이스 영역)\n<ul>\n<li>STEP 4.1 자바 8 이전과 이후의 메서드 영역</li>\n<li>STEP 4.2 메서드 영역에서의 GC 동작</li>\n</ul>\n</li>\n<li>STEP 5. 가비지 수집기\n<ul>\n<li>STEP 5.1 Serial GC</li>\n<li>STEP 5.2 Parallel GC</li>\n<li>STEP 5.3 CMS(Concurrent Mark &#x26; Sweep) GC</li>\n<li>STEP 5.4 G1(Garbage First)GC</li>\n</ul>\n</li>\n<li>STEP 5. 결론</li>\n<li>STEP 6. 레퍼런스 및 참고자료</li>\n</ul>\n<h1 id=\"개요\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EC%9A%94\" aria-label=\"개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개요</h1>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/Mll9lyu.png\">\n</p>\n<p align=\"center\">\n    <em>그림 1. JVM 구조도</em>\n</p>\n<p>위 그림은 전반적인 JVM의 구조를 나타내는 그림이다. 클래스로더 시스템에 대해서는 이전에 <a href=\"https://brewagebear.github.io/fundamental-jvm-classloader/\">한번 다뤘으니</a>, 이 포스팅의 중점은 메모리 영역(Runtime Data Areas)와 실행 엔진(Execution Engine) 부분이라고 볼 수 있을 것 같다.</p>\n<p>예전에 한번 GC 알고리즘에 대해서 다루고자 한다 했는데 너무 시간이 지났다. 그래서 이왕 시간이 많이 지난거 한번에 모든 걸 담아보면 어떨까? 라는 생각으로 글을 작성하였고, 이 때문에 장문의 글이 되어버렸다. 거기다가 최신 GC인 ZGC는 내용의 압박으로 인하여 일단 패스했는데 만약 추가하게 되면 개요에 추가하도록 하겠다.</p>\n<p>추가로 이번 내용의 대부분은 아래의 책들을 참고하였다.</p>\n<ol>\n<li>\n<p><a href=\"https://www.yes24.com/Product/Goods/3577335\">Java Performance Fundamental, 김한도 저, 2009</a></p>\n</li>\n<li>\n<p><a href=\"https://a.co/d/3vI0AU4\">Java Memory Management: A comprehensive guide to garbage collection and JVM tuning, Maaike van Putten, 2022</a></p>\n</li>\n</ol>\n<p>특히, Java Performance Fundamental은 10년이 지난 지금에도 바이블이라고 생각한다. 이 책을 꼭 읽어보기를 추천한다.</p>\n<p>주의할 점은 이 책이 나온 시점에는 Java 1.5 ~ 1.6 시절이므로 그걸 감수하면서 달라진 내용을 팔로우하면서 봐야한다는 점이다. Java Memory Management라는 책 또한, 볼륨이 상대적으로 적은데 (대략 220쪽분량) 핵심적인 내용들과 내가 궁금한 부분들에 대해서는 전부 다 녹여져 있었다.</p>\n<p>이 두 권을 추천하며, 추가적으로 JVM에서 더 넓은 범위의 성능 최적화를 공부하고 싶다면 <a href=\"https://www.yes24.com/Product/Goods/115426829\">실무로 배우는 시스템 성능 최적화, 권문수 저, 2022</a> 이 책을 추천한다.</p>\n<p>자 이제 본론으로 들어가보자.</p>\n<h2 id=\"step-1-자바-메모리-관리\" style=\"position:relative;\"><a href=\"#step-1-%EC%9E%90%EB%B0%94-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC\" aria-label=\"step 1 자바 메모리 관리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1. 자바 메모리 관리</h2>\n<p>이 메모리 영역은 자바가 동작할 때 사용되는 모든 것들이 올라가지게 된다. JVM의 <strong>주된 역할 중 하나도 이 메모리 영역(Runtime Data Areas)를 관리</strong>하는 것이다.</p>\n<p>JVM이 이 영역을 관리를 하지 않게 되면, 메모리 라이프 사이클 관리와 같은 활동이 수행되지 않을 것이고 이는 OOM과 같은 문제를 발생시킬 수 있다.</p>\n<p>즉, JVM은 이 메모리 영역에 대한 라이프 사이클을 관리하여 프로그래머가 해당 부분에 노력을 기하지 않더라도 자동으로 관리하는 편의성을 가져왔다.</p>\n<p>위에서는 설명한 바와 같이 JVM은 이 메모리 영역에 대한 “라이프 사이클”을 책임져준다. 이는 자바 이전의 프로그래밍 언어들(<code class=\"language-text\">C, CPP</code>)은 프로그래머가 스스로 메모리 관리를 했어야했다는 점이다.</p>\n<p>학부생때 <code class=\"language-text\">C, CPP</code> 와 같은 프로그래밍 언어를 다뤘다면 <code class=\"language-text\">malloc</code> 이나 <code class=\"language-text\">free</code> 등을 사용해서 메모리 관리를 한 적이 있을 것이다. 이 언어들은 메모리 영역에 대한 관리를 프로그래머 스스로가 책임을 졌었다.\n이는 아래와 같은 문제점을 낳았다.</p>\n<ol>\n<li>댕글링 포인터(Dangling Pointer)<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup> : 포인터가 여전히 메모리가 해제된 영역을 가르키고 있는 상황</li>\n<li>메모리 릭(Memory leaks) : 더 이상 필요하지 않은 메모리에 대해 할당 해제가 제대로 이뤄지지 않는 상황이 누적되어서 메모리가 고갈되어 부족해지는 상황</li>\n<li>보일러플레이트 코드(Boilerplate code) : 코드에 비즈니스 로직보다 메모리 할당과 해제에 대한 코드가 더 많이 자리 잡게되고, 이 코드를 지속적으로 유지보수 해야했음</li>\n<li>오류 발생 가능성(Error-prone) : 숙련된 개발자라 하더라도 이러한 작업에 대해서 실수가 발생할 가능성이 존재</li>\n</ol>\n<p>자바는 JVM의 메모리 기능을 활용하여 위와 같은 문제를 프로그래머가 더 이상 고민하지 않고, 비즈니스 로직에 전념할 수 있도록 하였다.\n그렇다면, 이러한 기능은 어떤식으로 이뤄질 수 있을까?</p>\n<p>핵심은 위 그림의 세가지 구성요소이다.</p>\n<ol>\n<li>클래스로더 시스템(ClassLoader System) : 초기 바이트 코드 검증 및 클래스 파일을 실제로 로드되기 위해 필요한 구성요소</li>\n<li>메모리 영역(Runtime Data Areas) : 클래스의 로딩과 바이트 코드의 실행은 메모리를 필요로 하는데 이러한 작업들을 수행하는 구성요소</li>\n<li>실행 엔진(Execution Engine) : 클래스로더를 통해서 로드된 클래스들이 메모리에 적재되면 실제 바이트 코드를 실행하는 구성요소</li>\n</ol>\n<p>아마 대충 러프한 플로우는 이해가 됐을 것이다. 자세한 부분은 <a href=\"https://github.com/openjdk/jdk/blob/master/src/hotspot/share/runtime/init.hpp#L38\">OpenJDK - Github</a> 해당 코드를 참고해보자.</p>\n<p><code class=\"language-text\">init_globals()</code> 메서드를 통해서 준비 과정을 거치면서 <code class=\"language-text\">Main Java Thread</code> 를 구성하고, <code class=\"language-text\">vm_init_globas()</code> 메서드를 통해서 <code class=\"language-text\">VM Thread</code> 를 구성하는 헤더파일이다. 요즘 깃허브가 좋아져서, 클릭하면서 해당 내용을 참고할 수 있으니 내부 로직을 상세히 보고 싶으면 해당 깃허브를 참고해보자.</p>\n<p>추가로 앞으로 기술할 모든 내용은 <strong>Hospot VM</strong><sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup> 기준이다.</p>\n<p>우리는 대충 JVM이 어떠한 역할을 하는지와 실제 자바 코드가 어떤식으로 처리되고, 구성요소는 어떤 식으로 동작하는 지 배웠다.\n앞서서 말했듯이 이번에 주요하게 볼 내용은 메모리 영역과 실행엔진 부분이므로 이 두 컴포넌트의 상세한 내용을 확인해보자.</p>\n<h2 id=\"step-2-메모리-영역\" style=\"position:relative;\"><a href=\"#step-2-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD\" aria-label=\"step 2 메모리 영역 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2. 메모리 영역</h2>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/UtkS6yx.png\">\n</p>\n<p align=\"center\">\n    <em>그림 2. JVM 메모리 영역 구조도</em>\n</p>\n<p>이미 위에서 보여줬던 그림처럼 메모리 영역은 5가지의 구성요소로 이뤄진다고 하였다.\n간략하게, 각 영역들이 어떠한 일을 하는지를 설명한 후에 세부적인 내용을 다뤄보고자 한다.</p>\n<ol>\n<li><strong>스택 영역</strong></li>\n</ol>\n<p>프리미티브 타입들과 힙 영역에 저장된 참조(Reference)에 대한 정보들이 담기는 영역이다.</p>\n<p>메서드가 호출되면 스택 프레임(Stack Frame)이 생성되며, 각 프레임마다 메서드에 대한 값을 유지하고 있다. 스택 영역은 <strong>각 쓰레드 마다 독립적인 공간이 할당</strong>된다.</p>\n<ol start=\"2\">\n<li><strong>PC 레지스터</strong></li>\n</ol>\n<p>운영체제에서 말하는 PC 레지스터와 상동한 일을 수행한다. 현재 실행 중인 명령의 주소를 저장함으로써 어떤 코드가 실행되는 지를 알게끔한다.\nPC 레지스터는 <strong>각 쓰레드 마다 독립적인 공간이 할당</strong>된다.</p>\n<ol start=\"3\">\n<li><strong>힙 영역</strong></li>\n</ol>\n<p>JVM이 시작되면, RAM의 일부분을 어플리케이션의 메모리 동적할당을 위해서 예약한다고 위에서 말했었다. 이 영역이 해당 부분이라고 보면된다.</p>\n<p>런타임 데이터들은 이 곳에 할당되며, 인스턴스들을 이 영역에서 찾을 수 있다.\n힙 영역은 GC를 통해서 메모리 할당, 해제등이 관리가 된다.</p>\n<p>힙 영역은 <strong>모든 쓰레드가 공유</strong>한다.</p>\n<ol start=\"4\">\n<li><strong>메서드 영역(메타스페이스 영역)</strong></li>\n</ol>\n<p>클래스의 메타데이터인 런타임 코드, 정적 변수, 상수 풀 그리고 생성자 코드등을 포함한다.</p>\n<p>메서드 영역은 <strong>모든 쓰레드가 공유</strong>한다.</p>\n<ol start=\"5\">\n<li><strong>네이티브 메서드 스택 영역</strong></li>\n</ol>\n<p>이 영역은 Java가 아닌 C와 같은 언어로 구현된 네이티브 코드가 실행되는 곳이고, 위에서 살펴본 스택처럼 네이티브 코드 또한, 명령에 대한 스택이 필요하므로 네이티브 코드를 위한 스택 영역이라고 보면 될 것이다.</p>\n<p>이 영역 또한, <strong>스택 영역과 같이 모든 쓰레드가 독립적인 공간</strong>을 갖는다.</p>\n<p>위 내용을 정리하면 아래와 같을 것이다.</p>\n<table>\n<thead>\n<tr>\n<th>영역 명</th>\n<th>특징</th>\n<th>쓰레드 간의 공유 여부</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>스택 영역</td>\n<td>메서드가 호출될 때마다 스택프레임을 생성하며, 힙 영역에 대한 참조가 저장되는 공간</td>\n<td>X</td>\n</tr>\n<tr>\n<td>PC 레지스터</td>\n<td>현재 실행 중인 명령의 주소를 저장하는 역할</td>\n<td>X</td>\n</tr>\n<tr>\n<td>힙 영역</td>\n<td>JVM이 메모리 동적할당을 위해서 예약을 해둔 공간으로 런타임 데이터들과 인스턴트들이 저장되는 공간</td>\n<td>O</td>\n</tr>\n<tr>\n<td>메서드 영역</td>\n<td>클래스의 메타데이터인 런타임 코드, 정적 변수, 상수 풀 등을 저장하는 공간</td>\n<td>O</td>\n</tr>\n<tr>\n<td>네이티브 메서드 스택 영역</td>\n<td>자바 코드가 아닌 네이티브 코드를 위한 스택을 사용하기 위한 공간</td>\n<td>X</td>\n</tr>\n</tbody>\n</table>\n<p>이제 이 영역들에 대해서 세부적으로 보도록 하자.</p>\n<h3 id=\"step-21-스택-영역\" style=\"position:relative;\"><a href=\"#step-21-%EC%8A%A4%ED%83%9D-%EC%98%81%EC%97%AD\" aria-label=\"step 21 스택 영역 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.1 스택 영역</h3>\n<p>자바에서의 데이터 값은 크게 2가지 분류로 나뉘어진다.</p>\n<ol>\n<li>원시타입 값(Primitive value) : 이 값은 원시타입(int, char 등…) 중에서 하나의 타입을 갖고 있다.</li>\n<li>참조타입 값(Reference value) : 이 값은 객체 위치에 대한 참조 포인터를 지니고 있다.</li>\n</ol>\n<p>스택 영역을 이해하기 위해서는 이 2가지 값의 할당 방식에 대해서 이해를 할 필요가 있다.</p>\n<p>앞서 위에서 말한 것과 같이 스택은 각 쓰레드마다 별도의 영역을 갖고 있고, 쓰레드가 호출될 때마다 스택 프레임을 생성한다고 하였다.\n그림으로 보면 아래와 같다고 볼 수 있다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/eeQ4ikC.png\">\n</p>\n<p align=\"center\">\n    <em>그림 3. 쓰레드 별 스택과 스택프레임</em>\n</p>\n<p>스택은 말 그대로 자료구조의 스택과 동일하게 후입선출(Last-In First-Out, LIFO)의 구조를 갖고 있다.\n예를 들면 쓰레드 1번의 스택의 상황은 <code class=\"language-text\">a()</code> 메서드가 호출된 상황에서 다시 <code class=\"language-text\">b()</code> 메서드가 호출된 상황이라 보면 될 것이다.</p>\n<p>스택 구조로 되어있기에 <code class=\"language-text\">b()</code> 의 결과를 다시 <code class=\"language-text\">a()</code> 에서 받아서 결과를 조합한 뒤에 결과를 도출할 수 있을 것이다.\n쓰레드마다 스택 구조가 생기는 이유도 동일하다. 만약, 멀티쓰레딩 환경에서 스택 영역을 공유한다고 가정해보자.</p>\n<p>그러면 어떤 쓰레드에서 어떤 메서드가 끝났는지 파악하기도 매우 어렵고, 위 예시와 같이 <code class=\"language-text\">a()</code> 프레임은 <code class=\"language-text\">b()</code> 프레임의 결과를 받아 처리하는 것을 기대하는데, 다른 쓰레드들이 하나의 스택을 사용한다면\n이 처리하는 것이 매우 까다로울 것이다. 따라서, 자바는 각 쓰레드마다 별도의 스택 영역과 PC 레지스터를 둔 것이다.</p>\n<p>그렇다면, 스택 프레임은 어떠한 구조로 되어있을까?</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/QrKNvwY.png\">\n</p>\n<p align=\"center\">\n    <em>그림 4. 스택프레임 내부 구조도</em>\n</p>\n<p>위와 같은 구조로 되어있으며, 스택 프레임의 구성요소는 크게 3가지이다.</p>\n<ol>\n<li>지역변수 배열(Local variable array) : 해당 스택 프레임의 지역 변수들을 담는 배열</li>\n<li>피연산자 스택(Operand Stack) : 만약 프레임 내에서 지역변수 <code class=\"language-text\">x + y</code> 와 같은 연산을 수행할 시 그에 대한 피연산자인 <code class=\"language-text\">x</code>와 <code class=\"language-text\">y</code>를 저장해두는 공간</li>\n<li>프레임 데이터(Frame Data) : 메소드를 실행하는 데 필요한 데이터로 구성 되는 공간</li>\n</ol>\n<p>상세하게 하나씩 살펴보자.</p>\n<ul>\n<li>지역변수 배열(Local variable array)</li>\n</ul>\n<p>지역변수 배열의 크기는 <strong>컴파일 타임에 결정</strong>되며, 이 배열에는 2가지 공간이 존재한다.</p>\n<ol>\n<li>Single Spot : <strong>int, short, char, float, byte, boolean, reference</strong> 타입을 위한 공간</li>\n<li>Double Spot : <strong>long, double</strong> 타입을 위한 공간</li>\n</ol>\n<p>자바에서는 메서드가 2가지 타입이 존재하는 것은 다들 알고 있을 것이다.</p>\n<ol>\n<li>정적 메서드(static method)</li>\n<li>인스턴스 메서드(instance method)</li>\n</ol>\n<p>만약, 해당 프레임이 인스턴스 메서드를 통해서 생성된 것이면, 지역변수 배열의 첫번째 원소(index == 0)는 바로 <code class=\"language-text\">this</code>  즉, 메서드 호출했던 객체의 레퍼런스를 가르킨다.\n정적 메서드의 호출로 생성된 경우에는 지역변수 배열의 0번째부터 지역변수들이 저장된다.</p>\n<ul>\n<li>피연산자 스택(operand stack)</li>\n</ul>\n<p>이 부분은 어셈블러같은 걸 다뤄봤으면 이해가 쉽다. 아래와 같은 자바코드가 있다고 가정해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// main.java</span>\n<span class=\"token keyword\">package</span> <span class=\"token namespace\">test</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">{</span>\n\t <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t <span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t\t <span class=\"token keyword\">int</span> y <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\t\t <span class=\"token keyword\">return</span> x <span class=\"token operator\">+</span> y<span class=\"token punctuation\">;</span>\n\t <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>단순한 메서드임을 확인할 수 있는데 이를 자바 컴파일러로 확인하면 아래와 같은 결과를 얻을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">javac main.java # 자바 파일을 컴파일하여 바이트코드화\njavap -c Main.class # 클래스 파일을 역어셈블하여 출력하는 명령 \n\nCompiled from &quot;main.java&quot;\nclass test.Main {\n  test.Main();\n    Code:\n       0: aload_0\n       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V\n       4: return\n\n  public int test();\n    Code:\n       0: iconst_1\n       1: istore_1\n       2: iconst_2\n       3: istore_2\n       4: iload_1\n       5: iload_2\n       6: iadd\n       7: ireturn\n}</code></pre></div>\n<p>여기서 우리가 볼 내용은 <code class=\"language-text\">public int test();</code> 단의 어셈블러인데 <code class=\"language-text\">iconst_</code> 는 언더바 뒤에 상수를 피연산자 스택에 <code class=\"language-text\">push</code> 하는 명령이다.\n즉, <code class=\"language-text\">0: iconst_1</code> 은 피연산자 스택에 <code class=\"language-text\">x</code> 의 리터럴인 1을 푸시하는 명령이다. <code class=\"language-text\">istore_</code> 는 언더바 뒤에 상수를 피연산자 스택에서 <code class=\"language-text\">pop</code> 하여 지역변수 배열에 저장하는 명령이다.\n즉, <code class=\"language-text\">1: istore_1</code> 은 피연산자 스택에 넣어진 1을 지역변수 배열의 인덱스 1에 저장한다. (인스턴스 메서드기 때문이다.) 이후 <code class=\"language-text\">iload_</code> 는 지역변수 배열의 인덱스를 읽어서 값을 읽는 연산이다.\n이후 실제로 <code class=\"language-text\">iadd</code> 명령을 통해서 <code class=\"language-text\">x + y</code> 의 결과를 얻게 되는 것이다.</p>\n<ul>\n<li>프레임 데이터(Frame Data)</li>\n</ul>\n<p>위에서 프레임 데이턴느 메서드를 실행하는 데 필요한 다양한 데이터로 구성된다고 얘기를 하였다.</p>\n<p>런타임 상수 풀(run-time constant pool)에 대한 레퍼런스, 일반 메서드 호출 완료(Normal Method Invocation Completion), 갑작스러운 메서드 호출 완료(Abrupt Method Invocation Completion) 등이 이 데이터에 대한 예시이다.</p>\n<p>스택 프레임은 동적 링킹(Dynamic-Linking)<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup>을 지원하기 위해 현재 메서드 유형에 대한 런타임 상수 풀의 참조를 갖고 있다. 예시를 위해서 위의 코드를 좀 손을 봐보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// main.java</span>\n<span class=\"token keyword\">package</span> <span class=\"token namespace\">test</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">{</span>\n\t <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t <span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t\t <span class=\"token keyword\">int</span> y <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\t\t <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello World!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t <span class=\"token keyword\">return</span> x <span class=\"token operator\">+</span> y<span class=\"token punctuation\">;</span>\n\t <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 코드의 역어셈블러 결과는 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">Compiled from &quot;main.java&quot;\nclass test.Main {\n  test.Main();\n    Code:\n       0: aload_0\n       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V\n       4: return\n\n  public int test();\n    Code:\n       0: iconst_1\n       1: istore_1\n       2: iconst_2\n       3: istore_2\n       4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;\n       7: ldc           #3                  // String Hello World!\n       9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n      12: iload_1\n      13: iload_2\n      14: iadd\n      15: ireturn\n}</code></pre></div>\n<p>위에서 봤을 때랑 달라진 부분은 <code class=\"language-text\">#2, #3, #4</code> 로 주석쳐진 부분이다. 이 부분이 바로 런타임 상수 풀에 대한 참조를 처리하는 부분이다. 한 줄씩 봐보자.</p>\n<ol>\n<li><code class=\"language-text\">getstatic</code> 은  클래스의 정적 필드 값(<code class=\"language-text\">System.out == PrintStream</code>)을 가져와서 오퍼랜드 스택에 푸시한다.</li>\n<li><code class=\"language-text\">ldc</code>를 통해서 상수 풀의 참조 값(<code class=\"language-text\">Hello World!</code> 상수의 참조 값)을 스택의 맨 위로 푸시한다.</li>\n<li><code class=\"language-text\">invokevirtual</code> 명령어를 수행한다.\n<ul>\n<li>현재, 오퍼랜드 스택의 탑에는 <code class=\"language-text\">Hello World!</code> 의 참조 값이 들어가 있다 이를 꺼내와서 <code class=\"language-text\">PrintStream.println()</code> 의 인자로 전달하여 새로운 프레임을 생성한다.</li>\n<li>참조 값이 팝되었기 때문에 현재 탑은 <code class=\"language-text\">PrintStream</code> 일 것이다. 이를 다시 팝하여 위에서 처리된 인자들을 활용하여 화면에 출력한다.</li>\n</ul>\n</li>\n</ol>\n<p>이 뿐만 아니라 아까 위에서 적은 것 처럼 스택 프레임에는 <code class=\"language-text\">throws</code> 와 같은 예외 상황이나 정상 리턴에 대한 처리등이 포함된다고 하였다. 이는 실제로 바이트코드를 보면서 확인해보길 바란다.</p>\n<p>위에서 상세하게 스택 영역의 구성요소들이 하는 일에 대해서 다뤄보았다.\n하지만, 원시 타입과 정적 메서드에 대한 테스트로만 예시를 보여줬는데 그렇다면 스택과 힙 영역은 어떻게 연관되어지고, 실제 객체를 힙 영역에 저장할 때는 JVM에서 어떠한 일이 벌어지는 걸까?</p>\n<h3 id=\"step-22-힙-영역\" style=\"position:relative;\"><a href=\"#step-22-%ED%9E%99-%EC%98%81%EC%97%AD\" aria-label=\"step 22 힙 영역 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.2 힙 영역</h3>\n<p>위에서는 스택 영역에 대해서 다뤘었다. 그렇다면, 실제 힙 영역의 객체는 어떤식으로 저장되는 것일까?</p>\n<p>아래와 같은 코드가 있다고 가정해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> <span class=\"token namespace\">test</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> address<span class=\"token punctuation\">;</span>\n\n\t\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> address<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>address <span class=\"token operator\">=</span> address<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token class-name\">Person</span> person <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"bear\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Goyang-si\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 코드를 그림으로 나타내면 아래와 같을 것이다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/b4NZmnc.png\">\n</p>\n<p align=\"center\">\n    <em>그림 5. 예시코드의 스택과 메모리 상황</em>\n</p>\n<p><code class=\"language-text\">test()</code> 메서드가 호출되면 프레임이 생길테고, 이때 우리는 해당 메서드 내부에서 <code class=\"language-text\">new Person(\"bear\", \"Goyang-si\")</code> 와 같이 생성자를 전달하여 객체를 생성하였다.</p>\n<p>인스턴스가 생성되게 되면, 실제 값은 힙 영역에 저장되고 스택 내 지역변수는 해당 힙 영역에 생성된 값에 대한 레퍼런스를 갖고 있게 된다.</p>\n<p>즉, <code class=\"language-text\">person</code> 이라는 <strong>변수 자체는 실제 값을 들고 있는 것이 아니라 힙 영역에 할당된 데이터에 대한 참조 값을 들고 있는 것</strong>이다.</p>\n<p>위의 예시를 좀 더 우리가 자주 쓰는 자바 언어처럼 바꾸면서 스택 프레임과 힙 영역 할당 과정에 대해서 알아보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> <span class=\"token namespace\">test</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> address<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> age\n\n\t\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> address<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>address <span class=\"token operator\">=</span> address<span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\n\t\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">introduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token class-name\">String</span> template <span class=\"token operator\">=</span> <span class=\"token string\">\"안녕하세요. 제 이름은 \"</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">+</span> <span class=\"token string\">\"이고, 사는 곳은 \"</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>address <span class=\"token operator\">+</span> <span class=\"token string\">\" 에 살고 있으며, 나이는 \"</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">+</span> <span class=\"token string\">\"입니다.\"</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token keyword\">return</span> template<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token class-name\">Person</span> bear <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"bear\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Goyang-si\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">29</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>bear<span class=\"token punctuation\">.</span><span class=\"token function\">introduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이제 예시가 좀 더 그럴싸해졌다. 그렇다면 스택 프레임의 구조는 어떻게 될까?</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/1x6ZWE8.png\">\n</p>\n<p align=\"center\">\n    <em>그림 6. 예시코드의 스택과 메모리 상황</em>\n</p>\n<p>위 스택 프레임을 분석하면 아래와 같이 분석할 수 있다.</p>\n<ol>\n<li><code class=\"language-text\">main()</code> 메서드가 호출됨에 따라 스택프레임이 생성된 후에 스택 영역에 푸시된다.</li>\n<li>스택 프레임 내에 <code class=\"language-text\">args, x</code> 값이 지역 변수 배열에 저장된다. (<code class=\"language-text\">x</code> 는 원시타입으로 별도 레퍼런스를 갖고 있지 않고, <code class=\"language-text\">main()</code> 메서드 내에 선언된 지역 변수라 따로 레퍼런스가 없다.)</li>\n<li>객체(<code class=\"language-text\">bear</code>)가 아래와 같은 과정으로 이뤄진다.\n<ul>\n<li>문자열 리터럴 2개 (“bear”, “Goyang-si”, 29)를 전달하여 <code class=\"language-text\">Person</code> 객체를 생성한다.\n<ul>\n<li>문자열 리터럴은 <code class=\"language-text\">String</code> 객체이므로 힙에 저장되며, <code class=\"language-text\">String</code> 이기 때문에 특별한 공간인 <strong>String Pool</strong>에도 저장된다.</li>\n<li><code class=\"language-text\">age</code> 의 경우에는 원시타입이므로 힙에 직접 저장이 된다.</li>\n<li>그러나, 객체의 레퍼런스 값이 담기는 <code class=\"language-text\">bear</code> 변수는 <code class=\"language-text\">main()</code> 메서드 내에 저장된다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>이후 <code class=\"language-text\">System.out.println(x)</code> 에 따라 <code class=\"language-text\">println()</code> 메서드의 새로운 프레임이 스택 영역에 푸시된다.</li>\n<li>추가로 <code class=\"language-text\">bear.introduce()</code> 메서드도 호출됨에 따라 이 프레임도 해당 스택 영역에 푸시된다.</li>\n</ol>\n<p>이 과정을 끝낸 후에 위에서 우리가 바이트 코드를 분석했던 방식과 같이 프로그램이 동작할 것이다.</p>\n<h3 id=\"step-23-번외-레퍼런스-타입-사용-주의사항\" style=\"position:relative;\"><a href=\"#step-23-%EB%B2%88%EC%99%B8-%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4-%ED%83%80%EC%9E%85-%EC%82%AC%EC%9A%A9-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD\" aria-label=\"step 23 번외 레퍼런스 타입 사용 주의사항 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.3 번외) 레퍼런스 타입 사용 주의사항</h3>\n<p>우리는 스택 영역을 깊게 보면서, 스택과 힙 영역이 어떤 역할을 하는 지와 자바에서 객체들이 생성될 때 어떠한 과정으로 생성되는 지 등을 살펴보았다.\n또한, 힙 영역에 우리가 사용할 객체가 생성되면 이 값은 레퍼런스를 토대로 참조를 하여 접근하는 식으로 동작하는 것을 알게되었다.</p>\n<p>이때, 자바의 특성이 레퍼런스 타입을 사용할 때는 위와 같이 동작을 하기 때문에 주의할 점이 존재한다.</p>\n<p>이에 대해서 잠깐 설명을 해보고자 한다. 이를 위해 아래의 간단한 코드를 참고해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">NameBuilder</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">StringBuilder</span> name<span class=\"token punctuation\">;</span>\n\t\n\t<span class=\"token class-name\">NameBuilder</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringBuilder</span> name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">StringBuilder</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> args<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token class-name\">StringBuilder</span> first <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StringBuilder</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"test\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t\t<span class=\"token class-name\">NameBuilder</span> nameBuilder <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NameBuilder</span><span class=\"token punctuation\">(</span>first<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>nameBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// test</span>\n\n\t\t<span class=\"token class-name\">StringBuilder</span> second <span class=\"token operator\">=</span> nameBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\tsecond<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"test\"</span><span class=\"token punctuation\">)</span>\n\t\t\n\t\t<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>nameBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// testtest</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 코드의 작성자는 <code class=\"language-text\">NameBuilder</code> 라는 클래스에 <code class=\"language-text\">String</code> 을 인자로 받는 것보다 <code class=\"language-text\">StringBuilder</code> 를 인자로 전달받아서 보다 <code class=\"language-text\">append()</code> 작업등을 원할하게 하는 식의 작업을 생각했던 것 같다.\n그리고 <code class=\"language-text\">NameBuilder</code> 의 멤버변수 <code class=\"language-text\">name</code>은 접근제어자를 <code class=\"language-text\">private</code>으로 두는 등 얼핏보면 나름 잘짠 코드라고 보일 수도 있다.</p>\n<p>그러나, 이 코드는 <strong>캡슐화가 제대로 이뤄지지 않는다.</strong> 우리는 <code class=\"language-text\">NameBuilder</code> 내부에 <code class=\"language-text\">StringBuilder</code> 가 <code class=\"language-text\">private</code> 이므로 바깥에서 접근도 안될 것이라 생각했지만 실제 코드를 동작해보면 옆에 주석을 달아둔 부분과 같이 <code class=\"language-text\">testtest</code>가 찍힘을 볼 수가 있다.</p>\n<p>왜 이런 문제가 발생하는 것일까? 정답은 ”<strong>레퍼런스</strong>“에 있다.\n그림으로 확인해보자.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/aDoI9xQ.png\">\n</p>\n<p align=\"center\">\n    <em>그림 7. 예시코드의 스택과 메모리의 레퍼런스 상황</em>\n</p>\n<p><code class=\"language-text\">first</code> 와 <code class=\"language-text\">nameBuilder</code> 를 생성한 시기에 스택과 힙 영역을 보면 위 구조와 동일할 것이다.</p>\n<p>이제 <code class=\"language-text\">StringBuilder second = nameBuilder.get();</code> 이후에는 어떻게 변하는지 그림을 확인해보자.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/9pa6JCy.png\">\n</p>\n<p align=\"center\">\n    <em>그림 8. 변경된 코드에 의한 스택과 메모리의 레퍼런스 상황</em>\n</p>\n<p><code class=\"language-text\">nameBuilder.get()</code> 를 호출하게 됐을 때, 사실 상 <code class=\"language-text\">first</code>가 가르키는 곳과 동일한 레퍼런스를 참고하고 있으며, <code class=\"language-text\">second.append(\"test\")</code> 를 하게 되면, 이는 같은 레퍼런스를 바라보고 있는 <code class=\"language-text\">nameBuilder</code> 의 <code class=\"language-text\">name</code> 에도 영향을 주고 말아 값이 변경되게 되는 것이다.</p>\n<p>이러한 문제때문에 접근제어자를 <code class=\"language-text\">private</code>으로 두었다 해도, 캡슐화가 깨질수가 있는 것이다.\n이 문제를 해결할 수 있는 방법은 무엇일까?</p>\n<p>아래와 같이 코드를 바꾸면 방법이 존재한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">NameBuilder</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">StringBuilder</span> name<span class=\"token punctuation\">;</span>\n\t\n\t<span class=\"token class-name\">NameBuilder</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringBuilder</span> name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StringBuilder</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 새로운 객체를 생성하여 전달</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">StringBuilder</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StringBuilder</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 새로운 객체를 생성하여 전달</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> args<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token class-name\">StringBuilder</span> first <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StringBuilder</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"test\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t\t<span class=\"token class-name\">NameBuilder</span> nameBuilder <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NameBuilder</span><span class=\"token punctuation\">(</span>first<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>nameBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// test</span>\n\n\t\t<span class=\"token class-name\">StringBuilder</span> second <span class=\"token operator\">=</span> nameBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\tsecond<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"test\"</span><span class=\"token punctuation\">)</span>\n\t\t\n\t\t<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>nameBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// test</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 방식을 유식한 말로 방어적 복사 기법(Defensive copy)<sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup> 이라 한다. 위에서 <code class=\"language-text\">get()</code> 을 호출하거나 생성자를 호출 할 때 <code class=\"language-text\">new StringBuilder</code> 를 통해서 아예 새로운 객체를 할당하여 리턴하는 것을 볼 수 있다. 이를 통해서 레퍼런스를 끊고, 올바르게 캡슐화를 시킬 수 있다.</p>\n<p>이러한 문제는 레퍼런스 타입에 발생한다고 얘기를 했는데 우리가 자주 사용하는 콜렉션 프레임워크인 <code class=\"language-text\">List, Map, Set</code> 등에도 발생할 수 있다.</p>\n<p>따라서, 일급콜렉션<sup id=\"fnref-5\"><a href=\"#fn-5\" class=\"footnote-ref\">5</a></sup> 을 사용할 때도 위와 같은 방어적 복사 기법과 같이 불변 객체(<code class=\"language-text\">unmodifiableList</code> 와 같은)를 활용하기도 한다.\n이 내용에 대해서 좀 더 알고 싶으면, 깊은 복사(Deep Copy)<sup id=\"fnref-6\"><a href=\"#fn-6\" class=\"footnote-ref\">6</a></sup> 혹은 얕은 복사(Shallow Copy)<sup id=\"fnref-6\"><a href=\"#fn-6\" class=\"footnote-ref\">6</a></sup> 에 대해서 공부해보도록 하자.</p>\n<h2 id=\"step-3-실행-엔진\" style=\"position:relative;\"><a href=\"#step-3-%EC%8B%A4%ED%96%89-%EC%97%94%EC%A7%84\" aria-label=\"step 3 실행 엔진 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3. 실행 엔진</h2>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/NOlggKt.png\">\n</p>\n<p align=\"center\">\n    <em>그림 9. 실행 엔진 내부 구조도</em>\n</p>\n<p>위에서는 스택 &#x26; 힙 영역에 대해서 다뤘었다. 이제는 실행 엔진에 대해서 다뤄보고자 한다.\n특히, 중점적으로 GC에 대해서 다룰 예정이다.</p>\n<h3 id=\"step-31-gc\" style=\"position:relative;\"><a href=\"#step-31-gc\" aria-label=\"step 31 gc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.1 GC</h3>\n<p>서두에서 자바는 <code class=\"language-text\">C, CPP</code>와 다르게 JVM 내에서 메모리를 할당하고 해제하는 등의 라이프 사이클을 관리해준다고 얘기하였다.\n이 기능을 제공해주는 것이 바로 “GC” 이다.</p>\n<p>이제 GC가 어떤 매커니즘으로 동작하는지 알아볼 차례이다.</p>\n<h4 id=\"step-311-gc-root-set\" style=\"position:relative;\"><a href=\"#step-311-gc-root-set\" aria-label=\"step 311 gc root set permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.1.1 GC Root Set</h4>\n<p>GC의 로직은 매우 간단하다.</p>\n<blockquote>\n<p>“현재 힙과 메서드 영역에서 사용되지 않는 객체(Object)를 정리하는 것이다.”</p>\n</blockquote>\n<p>그렇다면, 이 사용유무는 어떻게 판별할까? 그것을 판단해주는 것이 바로 <em>“GC Root Set”</em> 이다.</p>\n<p>Root Set에서 어떤 식으로든 레퍼런스를 참고하고 있으면 <em><strong>접근가능한 객체(Reachable Object)</strong></em> 라 부르고 이를 현재 사용 객체라 판단한다.</p>\n<p>GC Root Set의 종류는 아래와 같다.</p>\n<ol>\n<li>스택 내 레퍼런스 정보</li>\n<li>JNI 레퍼런스 정보</li>\n<li>메서드 영역 내 로드된 클래스 중 클래스 정적 변수 및 상수 풀 레퍼런스 정보</li>\n</ol>\n<p>위 세가지가 왜 GC 대상이 되면 안되는 지는 하나씩 설명해보도록 하겠다.</p>\n<ul>\n<li><strong>스택 내 레퍼런스 정보</strong></li>\n</ul>\n<p>스택 내 레퍼런스 정보는 엄밀하게 따지면, 현재 동작 중인 상황에서의 레퍼런스에 대해서라고 볼 수 있다.</p>\n<p>즉, 지역변수 배열이나 피연산자 스택 등에 레퍼런스 정보가 현재 존재한다면 이는 접근가능한 객체이므로, GC의 대상이 아니다.</p>\n<p>상식적으로 생각해보면 매우 쉬운데 정상적으로 어플리케이션이 동작 중인데 해당 레퍼런스가 GC의 대상이 된다면 아마도 수 많은 오류들을 마주하게 될 것이다.</p>\n<ul>\n<li><strong>JNI 레퍼런스 정보</strong></li>\n</ul>\n<p>위에서 JNI에 대해서는 간략히 다뤘는데, 네이티브 호출을 한 후에 실제로 사용 중인지 확인을 해야될 것이다.</p>\n<p>스택 내 레퍼런스 정보와 마찬가지로 해당 객체를 네이티브 코드에서 사용 중인데 함부로 GC를 하게 된다면 많은 오류가 발생할 것이기 때문이다.</p>\n<p>따라서, JNI에 대한 레퍼런스 정보를 GC Root Set으로 사용하는 것이다.</p>\n<ul>\n<li><strong>메서드 영역 내 로드된 클래스 중 클래스 정적 변수 및 상수 풀 레퍼런스 정보</strong></li>\n</ul>\n<p>메서드 영역에 대해서도 서두에서 간략하게 말했었다. 두 데이터 모두 클래스 수준의 데이터이며, 둘 다 클래스가 로드될 때 생성된 후에 클래스가 JVM 내에 로드된 상태로 유지되는 한 존재한다.</p>\n<p>따라서, 두 데이터를 갖고 있는 클래스가 로드 되는 동안에는 GC의 대상이 되서는 안된다.</p>\n<p>이는 후에 메서드 영역에 대한 GC를 다루면서 좀 더 다뤄보고자 한다.</p>\n<blockquote>\n<p>위와 같은 세가지 레퍼런스 정보에 <strong>직, 간접적</strong>으로 참조되고 있다면 모두 접근가능한 객체이고, GC 대상이 아니라는 점을 명심하자.</p>\n</blockquote>\n<p>이제, 실제 GC가 어떤 식으로 동작하는 지 알아보자.</p>\n<h3 id=\"step-32-식별-알고리즘\" style=\"position:relative;\"><a href=\"#step-32-%EC%8B%9D%EB%B3%84-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"step 32 식별 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.2 식별 알고리즘</h3>\n<p>아래의 코드가 주어진다 가정하고 스택 프레임을 그려보겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> id<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span> \n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> args<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token class-name\">Member</span> member1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">(</span><span class=\"token number\">1L</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"bear\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">29</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token class-name\">Member</span> member2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">(</span><span class=\"token number\">2L</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"rabbit\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">28</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token class-name\">Member</span> member3 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">(</span><span class=\"token number\">2L</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"tiger\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">27</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t\t<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">></span></span> members <span class=\"token operator\">=</span> <span class=\"token class-name\">List</span><span class=\"token punctuation\">.</span><span class=\"token function\">of</span><span class=\"token punctuation\">(</span>member1<span class=\"token punctuation\">,</span> member2<span class=\"token punctuation\">,</span> member3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>스택 프레임은 아래와 같이 그려질 것이다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/hhsbkF8.png\">\n</p>\n<p align=\"center\">\n    <em>그림 10. 예시 코드의 스택과 힙의 레퍼런스</em>\n</p>\n<p>만약 여기서 <code class=\"language-text\">member1 = null</code> 로 변경하면 레퍼런스가 아래와 같은 그림으로 변경될 것이다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/wWLztN9.png\">\n</p>\n<p align=\"center\">\n    <em>그림 11. null로 처리된 후의 스택과 힙의 레퍼런스</em>\n</p>\n<p>하지만, 여전히 <code class=\"language-text\">members</code> 의 레퍼런스는 <code class=\"language-text\">null</code> 로 변경된 <code class=\"language-text\">member1</code> 을 참조하고 있다.</p>\n<p>이 부분이 바로 우리가 GC Root Set을 얘기할 때 나왔던 스택 내 레퍼런스 정보에 해당하는 예시라 볼 수 있다.\n현재, <code class=\"language-text\">member1</code> 의 직접적인 참조는 제거되었지만, <code class=\"language-text\">members</code> 가 해당 객체의 레퍼런스를 갖고 있으므로 간접적으로 접근이 가능하다.</p>\n<p>즉, <em><strong>접근가능한 객체(Reacheable Object)</strong></em> 로써 <code class=\"language-text\">member1</code> 은 아직 GC의 대상이 아니다.</p>\n<p>그렇다면 <code class=\"language-text\">members = null</code> 로 변경하게 되면 어떻게 될까?</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/r9OqVsE.png\">\n</p>\n<p align=\"center\">\n    <em>그림 12. 접근불가능한 객체(Unreacheable Object)가 나타난 상황</em>\n</p>\n<p>이런식으로 스택 프레임 내의 레퍼런스 정보가 변경될 것이다 더이상 접근할 수 없는 두 객체(Member Object, List Object)는 비로소 GC의 대상이 된다.</p>\n<p>그렇다면, 궁금한 점이 생길 것이다.</p>\n<blockquote>\n<p>그렇다면, 지속적으로 접근가능한 객체인지 아닌지 판별을 해야될 것 같은데 이는 어떻게 처리가 되나요?</p>\n</blockquote>\n<p>저러한 판별을 해주는 것이 바로 <em><strong>식별 알고리즘(Marking Algorithm)</strong></em> 이다.</p>\n<p>GC를 통한 마킹은 모든 활성 객체와 가비지 수집 준비가 되지 않은 모든 객체에 마킹이 된다.\n객체는 이 마킹 여부를 표시하는 <strong>특수 비트</strong>를 갖고 있다.</p>\n<p>생성 시에는 해당 비트가 0이고, 마킹 단계에서 객체가 여전히 사용 중이며 제거되지 않아야하는 경우 1로 설정된다.</p>\n<p>위 예시 중에서 <code class=\"language-text\">member1 = null</code> 이였던 상황을 재활용해서 스택 프레임과 특수비트를 표기하면 아래와 같을 것이다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/0g4GOsB.png\">\n</p>\n<p align=\"center\">\n    <em>그림 13. 초기 마킹을 하는 상황</em>\n</p>\n<p>초기에는 모두 0으로 표기되다가 마킹을 수행하면, <code class=\"language-text\">member1</code> 제외하고 레퍼런스를 갖고 있기 때문에 아래와 같이 변경된다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/d0XRhAS.png\">\n</p>\n<p align=\"center\">\n    <em>그림 14. 스택에서 직접적으로 레퍼런스로 식별하는 객체 마킹</em>\n</p>\n<p>일단, 먼저 스택 내에서 직접적으로 접근 가능한 레퍼런스들을 갖고 있는 객체들에 대한 특수비트를 1로 바꾼다.\n이 후에 힙 내에서도 접근 가능한 레퍼런스를 마킹한다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/Cd67rdr.png\">\n</p>\n<p align=\"center\">\n    <em>그림 15. 힙 내부의 레퍼런스를 통한 객체 마킹</em>\n</p>\n<p>우리는 JVM에서 GC가 이뤄질 때 접근가능한 객체인지 아닌지를 판별하는 알고리즘을 살펴보았다.\n이 마킹 방법에는 크게 2가지 방법이 존재한다.</p>\n<h4 id=\"step-321-스탑-더-월드\" style=\"position:relative;\"><a href=\"#step-321-%EC%8A%A4%ED%83%91-%EB%8D%94-%EC%9B%94%EB%93%9C\" aria-label=\"step 321 스탑 더 월드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.2.1 스탑-더-월드</h4>\n<p>위에 식별 매커니즘을 보았을 때 궁금한 점이 있지 않은가? 바로 <strong>시점의 충돌</strong>이다.</p>\n<blockquote>\n<p>마킹하는 순간에 새로운 객체가 생겨나면?</p>\n<p>이 객체는 아직 특수비트가 0일 테고 나중에 GC대상이 될 수 있지 않을까요?</p>\n</blockquote>\n<p>라는 질문이 나올 수 있다. 이러한 시점의 차이로 인해서 살아있어야할 객체가 GC에 의해 수집된다면 아마도 재앙이라고도 볼 수 있을 것이다.</p>\n<p>스탑-더-월드 알고리즘은 이름처럼 마킹 단계에서 <strong>새 객체가 생성되지 않도록 실행을 일시 중지하는 기법</strong> 이라고 볼 수 있다.</p>\n<p>이 방법은 당연히 어플리케이션 <strong>성능에 매우 치명적인 영향</strong> 을 끼친다. 그래서, 많은 자바 개발자들은 스탑-더-월드가 없이 마킹 단계를 수행하고 싶어하였다.\n이러한 요구사항으로 나온 기법이 바로 <strong>레퍼런스 카운팅(Reference Counting)</strong> 이다.</p>\n<h4 id=\"step-322-레퍼런스-카운팅\" style=\"position:relative;\"><a href=\"#step-322-%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4-%EC%B9%B4%EC%9A%B4%ED%8C%85\" aria-label=\"step 322 레퍼런스 카운팅 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.2.2 레퍼런스 카운팅</h4>\n<p>이 알고리즘은 객체 헤더의 필드를 주어서 레퍼런스 카운트를 저장한 후 이 객체가 다른 객체에 의해 참조되는 경우 해당 객체의 레퍼런스 카운트는 1씩 증가하고, 해제될 경우에는 1씩 감소하는 단순한 매커니즘을 갖고 있다.</p>\n<p>즉, 카운트가 0이 되면 가비지 수집의 대상이 된다.</p>\n<p>스탑-더-월드가 일시 중지하는 이유는 위에서 설명했듯이 잠깐 중단하고, 힙의 모든 레퍼런스를 마킹해야되기 때문이라고 하였다. 하지만, 레퍼런스 카운팅은 실제 힙에 카운트를 저장하는 개념이다보니 이 스탑-더-월드를 최소화시킬 수 있다.</p>\n<p>위의 장점만 보면 매우 아름다운 알고리즘이라고 볼 수 있으나, 요즘 GC는 스탑-더-월드 방식을 채택한 후 이 스탑-더-월드 시간을 최소화하는 식으로 발전해왔다.\n왜 그럴까? 이 알고리즘은 2가지 단점을 갖고 있다.</p>\n<ol>\n<li>카운트 유지 오버헤드 : 각 객체는 레퍼런스 카운트를 유지해야되며, 레퍼런스가 삭제/생성될 때마다 업데이트해야된다. 이는 객체가 많아질 경우 상당한 오버헤드가 발생한다.</li>\n<li>고립된 섬 문제(Island of Isolation)<sup id=\"fnref-7\"><a href=\"#fn-7\" class=\"footnote-ref\">7</a></sup> : 순환참조 관계에서 발생하는 문제인데, 순환참조 관계에서는 카운트가 0으로 떨어지지않고 GC가 안되는 문제가 발생하여 메모리 릭이 발생할 수 있다.</li>\n</ol>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/ofah5OD.png\">\n</p>\n<p align=\"center\">\n  <em><a href=\"https://alibabatech.medium.com/how-does-garbage-collection-work-in-java-cf4e31343e43\">그림 16. Island of Isolation - Alibaba Tech</a></em>\n</p>\n<p>즉, 위와 같은 단점들을 갖고 있기 때문에 오늘날에도 우리는 식별 알고리즘에 스탑-더-월드를 사용하고 있는 것이다.\n이제 식별을 했으니 실제 메모리를 지우는 작업을 보고자한다. 이를 정리 알고리즘(Sweep Algorithm)이라 부를 것이다.</p>\n<h3 id=\"step-33-정리-알고리즘\" style=\"position:relative;\"><a href=\"#step-33-%EC%A0%95%EB%A6%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"step 33 정리 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.3 정리 알고리즘</h3>\n<p>정리 알고리즘은 그냥 비워버리는 알고리즘부터 정리하면서 압축하는 알고리즘, 다른 곳으로 복제하는 알고리즘이 존재한다.\n기본적인 알고리즘부터 확인해보자.</p>\n<h4 id=\"step-331-기본-정리-알고리즘\" style=\"position:relative;\"><a href=\"#step-331-%EA%B8%B0%EB%B3%B8-%EC%A0%95%EB%A6%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"step 331 기본 정리 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.3.1 기본 정리 알고리즘</h4>\n<p>기본 정리 알고리즘(Normal Sweeping, Mark-and-Sweep Algorithm)은 아주 단순하다.  아래의 그림을 보면 바로 이해될 것이다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/LRqNaYu.png\">\n</p>\n<p align=\"center\">\n  <em>그림 17. 기본 정리 알고리즘</em>\n</p>\n<p>마킹 단계에서 접근가능하지 않은 객체로 판별된 녀석들을 위 그림과 같이 할당 해제하는 것이다.\n여기서, 점선은 메모리의 가용 영역이라고 생각하자.</p>\n<p>그런데, 위와 같이 처리하면 어떠한 문제가 생길까? 애초에 그림 상으로 봐도 메모리 단편화(Memory Fragmentation)<sup id=\"fnref-8\"><a href=\"#fn-8\" class=\"footnote-ref\">8</a></sup> 이 발생했음을 확인할 수 있다.\n만약, 가용용량보다 큰 객체를 할당하고자 하면 어떠한 문제가 발생할까?</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/PIgTDYP.png\">\n</p>\n<p align=\"center\">\n  <em>그림 18. 크기가 큰 객체는 할당하지 못하는 문제(메모리 단편화)</em>\n</p>\n<p>위와 같은 객체가 들어오고자하면 두 가용공간 모두 할당을 실패하므로, <code class=\"language-text\">OutOfMemory</code> 가 발생할 것이다.\n이러한, 단편화를 막기 위해서 먼저, 접근가능하지 않은 객체를 지운 후 압축을 하는 압축-정리 알고리즘이 탄생하였다.</p>\n<h4 id=\"step-332-압축-정리-알고리즘\" style=\"position:relative;\"><a href=\"#step-332-%EC%95%95%EC%B6%95-%EC%A0%95%EB%A6%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"step 332 압축 정리 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.3.2 압축-정리 알고리즘</h4>\n<p>압축-정리 알고리즘(Sweeping with compacting, Mark-and-Compaction Algorithm)은 위에서 말한 것과 같이 기본 알고리즘 이후에 압축 단계가 추가된 알고리즘이다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/iuBg8oq.png\">\n</p>\n<p align=\"center\">\n  <em>그림 19. 압축-정리 알고리즘</em>\n</p>\n<p>이렇게 되면, 더 큰 객체도 할당할 수 있게 되고 메모리 단편화 문제도 해결할 수 있다.\n하지만 이 알고리즘의 경우 <strong>비용이 매우 비싼데</strong>, 그 이유는 위에서 보면 알 수 있듯이 압축을 하면서 모든 메모리 블록을 이동시키기 때문이다.</p>\n<p>이러한 문제때문에 복제-정리 알고리즘이 대두되었다.</p>\n<h4 id=\"step-333-복제-정리-알고리즘\" style=\"position:relative;\"><a href=\"#step-333-%EB%B3%B5%EC%A0%9C-%EC%A0%95%EB%A6%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"step 333 복제 정리 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.3.3 복제-정리 알고리즘</h4>\n<p>복제-정리 알고리즘(Sweeping with copying, Copying Algorithm)은 <strong>아예 메모리 영역을 2개의 공간</strong>으로 나누어서 정리한다는 개념에서 출범하였다.</p>\n<p>그 이유는 <em><strong>압축 비용보다 영역 자체를 2개를 나눈 뒤 연속적으로 복제하는 것</strong></em>이 비용이 저렴하기 때문이다.</p>\n<p>복제-정리 알고리즘은 2단계로 나눠지는데 그림을 보면 이해하기 쉬울 것이다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/WFawkyx.png\">\n</p>\n<p align=\"center\">\n  <em>그림 20. 복제-정리 알고리즘 (복제 단계)</em>\n</p>\n<p>GC 대상이 아닌 활성 객체들을 다른 영역에 복제를 한다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/V7oCY4Z.png\">\n</p>\n<p align=\"center\">\n  <em>그림 21. 복제-정리 알고리즘 (정리 단계)</em>\n</p>\n<p>기존 영역을 모두 정리한다.\n이 알고리즘은 압축보다 빠른 성능을 가지는 장점이 있지만, 추가적인 메모리 공간이 필요하다는 단점이 존재한다.\n위의 정리 알고리즘은 어떤 가비지 수집기(Garbage Collector)를 선택하는 지에 따라 달려있다.</p>\n<h3 id=\"step-34-gc-알고리즘-중간-정리\" style=\"position:relative;\"><a href=\"#step-34-gc-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A4%91%EA%B0%84-%EC%A0%95%EB%A6%AC\" aria-label=\"step 34 gc 알고리즘 중간 정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.4 GC 알고리즘 중간 정리</h3>\n<p>우리는 위에서 GC에서 이뤄지는 단계들에 대한 알고리즘을 세부적으로 살펴보았다.</p>\n<ol>\n<li>마킹 단계\n<ol>\n<li>스탑-더-월드</li>\n<li>레퍼런스 카운팅</li>\n</ol>\n</li>\n<li>스위핑 단계\n<ol>\n<li>기본 정리 알고리즘</li>\n<li>압축-정리 알고리즘</li>\n<li>복제-정리 알고리즘</li>\n</ol>\n</li>\n</ol>\n<p>마킹 단계에서는 레퍼런스 카운팅의 단점(독립된 섬 문제)<sup id=\"fnref-7\"><a href=\"#fn-7\" class=\"footnote-ref\">7</a></sup>가 존재하여 요즘날의 GC들은 스탑-더-월드 방식을 사용한다고 말했었다. 마킹 후에 새 객체를 위해 공간을 비우는 알고리즘들을 정리 알고리즘이라 말하며, 이에 대한 여러가지 알고리즘을 살펴보았다.</p>\n<p>이제 힙 &#x26; 스택 영역에서 어떤식으로 GC가 일어나는지를 확인하기에 앞 서 한가지 중요한 알고리즘을 보고 가자.</p>\n<h3 id=\"step-35-generational-algorithm\" style=\"position:relative;\"><a href=\"#step-35-generational-algorithm\" aria-label=\"step 35 generational algorithm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.5 Generational Algorithm</h3>\n<p>복제-정리 알고리즘을 사용하면서 몇 가지 경험적 지식이 체득되었는데 바로 <strong>대부분의 프로그램에서 생성되는 객체는 생성된 지 얼마 되지 않아 GC 대상이 되는 짧은 수명을 갖게 된다는 점</strong>과 또한 <strong>어떤 프로그램도 수명이 긴 몇 개의 객체들은 반드시 가지고 있다는 점</strong>이다.</p>\n<p>이를 <strong>약한 세대 가설(weak generational hypothesis)</strong><sup id=\"fnref-9\"><a href=\"#fn-9\" class=\"footnote-ref\">9</a></sup>라 한다.</p>\n<p>이 가설이 왜 복제-정리 알고리즘에서 경험적 지식으로 파생되었냐면, 수명이 긴 객체의 경우 위에 복제-정리 알고리즘 매커니즘에 의해서 두 영역을 서로 오고갈텐데 정리 대상은 아니게 되는 것이다.</p>\n<p>그러다보니 <em><strong>오버헤드가 만만치 않게 된다</strong></em>는 사실을 알게 된 것이다. 이 사실은 Generational Algorithm이 만들어지는 데 기여를 하였다.\n이 알고리즘을 토대로 메모리 단편화, 활용 그리고 복제-정리 알고리즘이 가진 오버헤드를 상당 부분 극복할 수 있었고 각 영역에 대해서 적절한 알고리즘을 선택할 수 있게 되었다.</p>\n<p>아래의 그림을 잠깐 봐보자.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/Cx9dI52.png\">\n</p>\n<p align=\"center\">\n  <em><a href=\"https://www.yes24.com/Product/Goods/3577335\">그림 22. Generational Algorithm, Java Performance Fundamental, 김한도 저</a></em>\n</p>\n<p>①은 GC 이전이고, ②는 GC 이후를 보여준다.</p>\n<p>각 영역에 대해서 적절한 알고리즘을 선택할 수 있게 된다고 얘기했는데 여기서 “Youngest Generation Sub Heap”은 기본 정리 알고리즘처럼 단편화가 발생한 모습을 볼 수 있고, “Oldest Generation Sub Heap” 영역은 복제-정리 알고리즘에 본듯이 처리된 모습을 볼 수 있다.</p>\n<blockquote>\n<p>💡 그림22는 JDK 1.5 시절 그림이므로 “영역별로 각기 다른 알고리즘을 적재적소에 쓸 수 있었다” 정도로 기억하자.</p>\n</blockquote>\n<p>현대의 대부분 가비지 수집기들은 이 알고리즘을 근간에 두고 있고, 밑에서 다룰 기본적인 GC 매커니즘을 설명할 때 나올 힙의 영역들에 대해서도 이 알고리즘의 영향을 받았다.</p>\n<h3 id=\"step-36-heap의-구조와-gc의-기본-동작\" style=\"position:relative;\"><a href=\"#step-36-heap%EC%9D%98-%EA%B5%AC%EC%A1%B0%EC%99%80-gc%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EB%8F%99%EC%9E%91\" aria-label=\"step 36 heap의 구조와 gc의 기본 동작 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.6 Heap의 구조와 GC의 기본 동작</h3>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/WgCCx2Q.png\">\n</p>\n<p align=\"center\">\n  <em>그림 23. 힙 메모리의 구조</em>\n</p>\n<p>위 그림은 힙의 구조를 나타낸다. 위에서 설명한 “Generational Algorithm” 에 따라서 2개의 세대의 영역으로 분리가 된다.</p>\n<ol>\n<li>Young Generation Space\n<ul>\n<li>에덴 영역(Eden Space) : 새로 할당되는 객체들이 위치하는 영역으로, 에덴영역에 더 이상 할당할 수 있는 객체의 공간이 없으면 <strong>마이너 GC가 발생</strong>한다.</li>\n<li>서바이버 영역(Survivor Space) :  2개의 동일한 크기를 가진 영역(S0, S1)으로 구성된다. <strong>마이너 GC</strong>는 이 영역을 서로 변경하면서 복제하는 방식으로 활용한다.  (복제-정리 알고리즘 참고)</li>\n</ul>\n</li>\n<li>Old Generation Space\n<ul>\n<li>GC에서 살아남은(Survivor Space에 존재하는) 일정 수의 객체가 임계값을 초과하여 생존할 때 넘어가는 공간으로 이 영역에 할당할 수 있는 공간이 없다면 <strong>풀(Full) GC가 발생</strong>한다.</li>\n</ul>\n</li>\n</ol>\n<p>참고로, 서바이버 영역의 <code class=\"language-text\">SO, S1</code> 은 <strong>논리적인 구분이고, 물리적인 구분은 아니다.</strong></p>\n<p>위에서 정리한 내용을 수도코드로 표기하면 아래와 같이 볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">- 에덴 영역이 가득차면 => 마이너 GC가 실행된다 :\n\t- Run #1:\n\t\t- 처음에 S0가 타겟 서바이버 영역(Target Survivor Space)이라고 가정한다.\n\t\t- 활성 객체를 에덴에서 S0로 복제한다; age=1 \n\t\t- S1의 활성객체를 검사한다 :\n\t\t\t- age + 1 >= threshold 일 경우 \n\t\t\t\tY : 오브젝트를 Old Generation Space로 복제한다.\n\t\t\t\tN : 오브젝트를 S0로 복제한다; age += 1\n\t\t- 에덴영역과 S1를 비운다\n\t\t- 에덴영역에 객체를 할당한다\n\t- Run #2:\n\t\t- S1이 타겟 서바이버 영역이면\n\t\t- 활성 객체를 에덴에서 S1로 복제한다; age=1 \n\t\t- S0의 활성객체를 검사한다 :\n\t\t\t- age + 1 >= threshold 일 경우\n\t\t\t\tY : 오브젝트를 Old Generation Space로 복제한다.\n\t\t\t\tN : 오브젝트를 S1로 복제한다; age += 1\n\t\t- 에덴영역과 S1를 비운다\n\t\t- 에덴영역에 객체를 할당한다\n\n- Old Generation Space가 가득차면 => 풀 GC가 실행된다 :\n\t- Old Generation Space를 정리한다.(GC에 따라 다름)</code></pre></div>\n<p>이 부분을 그림을 통해서 확인해보자.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/1iwbASD.png\">\n</p>\n<p align=\"center\">\n  <em>그림 24. 힙에 새로운 메모리가 할당</em>\n</p>\n<p>새로운 객체(H)가 들어오고자 하는데, 에덴 영역에 공간이 없는 상황이다.  이때, 마이너 GC가 발생한다.\n여기서, 빨간색으로 칠해진 A, D, G가 GC의 대상이라고 생각해보고 아래의 그림을 본 후 수도코드를 다시 한번 보면 어떤 일이 발생 했는지 이해가 될 것이다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/ee8sm6q.png\">\n</p>\n<p align=\"center\">\n  <em>그림 25. 새 객체가 에덴에 할당, 기존 생존 객체들은 서바이버 영역으로 이동</em>\n</p>\n<p>여기서 살아남은 객체들 밑에 생긴 숫자는 나중에 Old Generation Space로 승격(promotion)하기 위한 기준 값이 된다.\n또, 아래의 그림을 봐보자.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/S1JsY1L.png\">\n</p>\n<p align=\"center\">\n  <em>그림 26. 추가로 또 마이너 GC가 일어나는 상황</em>\n</p>\n<p>위와 같은 상황에서 GC가 일어나면 어떤 그림이 그려질 지 생각해보고 아래의 그림을 봐보자.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/DTcVPnj.png\">\n</p>\n<p align=\"center\">\n  <em>그림 27. 생존 객체들을 Target 서바이버 영역으로 복제</em>\n</p>\n<p>위 그림과 비슷하게 생각했다면 정답이다.\n마이너 GC는 위 매커니즘으로 동작하며, 오래 생존한 객체는 수도 코드에 보이듯  <code class=\"language-text\">age + 1 >= threshold</code> 조건이 될 경우 Old Generation Space으로 승격된다.\n이 임계값은  <code class=\"language-text\">-XX:MaxTenuringThreshold</code> 로 조절할 수 있다.</p>\n<p>위의 마이너 GC 또한 어떠한 가비지 수집기(Garbage Collector)를 쓰느냐에 따라서 달라지는데 이를 알아보기 앞서 메서드 영역을 살펴보고, 마지막으로 각 가비지 수집기에 대한 특징과 동작 방식을 설명한 후에 글을 마무리 짓도록 하겠다.</p>\n<h2 id=\"step-4-메서드-영역메타스페이스-영역\" style=\"position:relative;\"><a href=\"#step-4-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%98%81%EC%97%AD%EB%A9%94%ED%83%80%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4-%EC%98%81%EC%97%AD\" aria-label=\"step 4 메서드 영역메타스페이스 영역 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 4. 메서드 영역(메타스페이스 영역)</h2>\n<p>메서드 영역은 서두에서 설명했던 내용처럼 <em><strong>클래스의 메타데이터인 런타임 코드, 정적 변수, 상수 풀 그리고 생성자 코드등을 포함</strong></em>한다고 하였다.</p>\n<p>메서드 영역도 변경의 역사가 존재하는데 이에 대해서 간단하게 짚고 넘어가보자.</p>\n<h3 id=\"step-41-자바-8-이전과-이후의-메서드-영역\" style=\"position:relative;\"><a href=\"#step-41-%EC%9E%90%EB%B0%94-8-%EC%9D%B4%EC%A0%84%EA%B3%BC-%EC%9D%B4%ED%9B%84%EC%9D%98-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%98%81%EC%97%AD\" aria-label=\"step 41 자바 8 이전과 이후의 메서드 영역 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 4.1 자바 8 이전과 이후의 메서드 영역</h3>\n<p>원래, 이 영역은 본래 자바 8 이전에는 <code class=\"language-text\">PermGen</code> 이라는 영역으로 불렀고, <strong>힙 영역의 일부로 자리</strong>를 하고 있었다.\n물론, 위에서 GC Root Set을 설명할 때 말했지만, 이 영역은 GC의 대상이 아닐 확률이 크고(밑에서 메서드 영역의 GC에 대해서 설명할 것임), 고정된 크기로 할당되었다.\n<code class=\"language-text\">-XX:PermSize=256m -XX:MaxPermSize=256m</code> 과 같은 인자를 통해서 늘리거나 줄일 수 있었다.</p>\n<p>하지만, 하드웨어 성능이 좋아지고 램은 더 싸지기 시작하면서 자바 언어를 활용하여 더 많은 클래스와 객체들이 올라가기 시작했고 이는 OOM의 원인이 되기도 하였다.\n따라서, 이 영역을 대체하고자 하였고 그 내용은 <a href=\"https://openjdk.org/jeps/122\">JEP 122 - Remove the Permnent Generation</a> 이 이슈를 확인하여 볼 수 있다.</p>\n<p>저 이슈에서 “Success Metric” 부분만 발췌해오면 아래와 같다.</p>\n<blockquote>\n<p>Class metadata, interned Strings and class static variables will be moved from the permanent generation to either the Java heap or native memory.\nThe code for the permanent generation in the Hotspot JVM will be removed.\nApplication startup and footprint will not regress more than 1% as measured by a yet-to-be-chosen set of benchmarks.</p>\n</blockquote>\n<p>맨 윗줄을 보면 클래스 메타데이터나 정적 변수 등이 <code class=\"language-text\">PermGen</code> 에서 자바 힙 혹은 네이티브 메모리로 옮겨진다고 되어있다.\n이 중 네이티브 메모리 영역으로 옮겨진 부분이 바로, 메타스페이스 영역이다.</p>\n<p>즉,  <code class=\"language-text\">Metaspace</code> 영역은 네이티브 메모리에 동작을 함으로써 부족할 경우에 자동으로 늘어나는 식으로 하여 기존의 <code class=\"language-text\">PermGen</code> 에 비해 클래스 로드되는 건 수가 많더라하더라도 비교적 안전해졌다.</p>\n<p>물론, <code class=\"language-text\">-XX:MaxMetaspaceSize</code> 인자를 통해서 상한을 지정할 수도 있긴하다.</p>\n<p>이뿐만 아니라, 압축 클래스 영역(Compress Class Space) 라는 영역도 추가되었다.</p>\n<p>우리가 이 글에서 자주 보았던 레퍼런스는 JVM이 OOPS(Ordinary Object Pointers)<sup id=\"fnref-10\"><a href=\"#fn-10\" class=\"footnote-ref\">10</a></sup>라는 자료구조를 활용하여 관리한다.</p>\n<p>32bit 시스템에서는 oops는 최대 힙을 4GB<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msup><mn>2</mn><mn>32</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(2^{32})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">32</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>까지 사용할 수 있고, 64bit 시스템에서는 oops는 최대 힙을 18.5EB<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msup><mn>2</mn><mn>64</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(2^{64})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">64</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>까지 사용할 수 있다.</p>\n<p>이것은 이론적인 숫자에 불과하고, 실제로 64bit 포인터로 공간을 관리하는 것은 매우 비효율적이다.</p>\n<p>이에, Compressed OOPS라는 녀석이 나왔는데 이는 64bit 환경에서도 OOPS는 32bit 포인터를 활용하게끔 하는 것이다. 이 때문에 많은 자바 어플리케이션들이 32GB 이상 힙 사이즈를 넘지 않는 것을 권고하는 이유기도 하다.</p>\n<p>이유는 32GB가 넘어갈 경우에는 Compressed OOPS 기능이 꺼지고, 원래대로 포인터 자체가 64bit를 활용하게 된다.</p>\n<p>이러한 이유때문에 ES와 같은 곳에서 32GB 이하의 힙사이즈를 추천 설정으로 이야기하는 것이다. 이 부분에 대해서 궁금하다면 아래의 링크를 참고해보자.</p>\n<p>참고 : <a href=\"https://discuss.elastic.co/t/es-lucene-32gb-heap-myth-or-fact/22920\">ES&#x26;Lucene 32GB heap myth or fact? - Elsatic Discuss</a></p>\n<p>이에 대한 자세한 동작 방식이나 매커니즘은 <a href=\"https://github.com/openjdk/jdk/blob/jdk-18-ga/src/hotspot/share/oops/compressedOops.hpp\">compressedOops.hpp - OpenJDK github</a> 를 참고해보도록 하자.</p>\n<p>어쨋든간 중요한 점은 <code class=\"language-text\">PermGen</code> 이라는 기존 힙에서 관리하던 메타데이터들을 네이티브 영역에 분리하였는데 그것을 <code class=\"language-text\">Metaspace</code> 라 부르며,  Compressed OOPS나 네이티브 메모리를 활용한 기능들을 통해서 보다 현대적인 어플리케이션의 요구사항을 감당하게끔 되었다는 점이다.</p>\n<h3 id=\"step-42-메서드-영역에서의-gc-동작\" style=\"position:relative;\"><a href=\"#step-42-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%98%81%EC%97%AD%EC%97%90%EC%84%9C%EC%9D%98-gc-%EB%8F%99%EC%9E%91\" aria-label=\"step 42 메서드 영역에서의 gc 동작 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 4.2 메서드 영역에서의 GC 동작</h3>\n<p>간략하게 메서드 영역에 대해서 소개를 진행하였다.\n메서드 영역 또한 우리가 위에서 보았던 힙 영역의 Minor GC 매커니즘과 흡사한데 차이점이 있는 부분은 접근가능 객체를 식별하는데 <em><strong>클래스 로딩</strong></em>과 관련이 있다 정도이다.</p>\n<p>이 구조를 그림으로 봐보자.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/FSf6dCG.png\">\n</p>\n<p align=\"center\">\n  <em>그림 28. 스택, 힙 그리고 메타스페이스의 상황</em>\n</p>\n<p>에덴 영역에 들어있는 빨간색 동그라미는 <em><strong>클래스 로더 객체</strong></em>를 뜻하며, 파란색은 A 객체, 노란색은 C 객체라고 보면서 설명을 읽어주길 바란다.</p>\n<ul>\n<li>JVM은 클래스 로더 객체와 A 객체 2개, 그리고 C 객체 1개를 힙에 생성한다.</li>\n<li>첫번째 A와 C를 생성할 때, 클래스 로더는 메타스페이스에 A와 C에 대한 메타데이터를 로드한다.</li>\n<li>하지만 두번째 A 객체는 메타스페이스에서는 어떤 일도 발생하지않는다. 이미 “Metadata A”가 로드되어 있기 때문이다.</li>\n</ul>\n<p>자 이제 아래와 같이 레퍼런스가 변경되었다고 가정해보겠다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/hCUm3PT.png\">\n</p>\n<p align=\"center\">\n  <em>그림 29. A 객체에 대해서 끊어진 레퍼런스</em>\n</p>\n<p>스택에 대한 레퍼런스 정보가 <code class=\"language-text\">pop</code> 되었지만, GC가 실행되지 않아서 인스턴스가 살아있는 상황이다. 이때 만약, GC가 벌어지면 어떠한 그림으로 변경될까?</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/6J1zXZQ.png\">\n</p>\n<p align=\"center\">\n  <em>그림 30. 에덴 영역에서 서바이버 영역으로 이동</em>\n</p>\n<p>위에서 본 내용과 같이 객체 C는 에덴 영역에서 서바이버 영역으로 이동될 것이다. 이때, 클래스 로더 객체도 같이 움직인다.\nA 객체가 가비지 수집에 의해서 제거됐지만, 메타스페이스는 A의 메타데이터를 들고 있다. 이는 <em><strong>힙에 C 객체가 남아있어서 클래스 로더를 회수 할 수 없기 때문</strong></em>이다.\n즉, 클래스 로더가 가비지 수집에 의해서 회수가 되고 메타스페이스 영역이 정리가 되려면, <em><strong>클래스 로더 객체에 의해 로드된 모든 클래스가 정리</strong></em>가 되어야만 한다.</p>\n<p>이것이 힙 영역에서의 GC와 메서드 영역에서의 GC의 동작 방식 중에 가장 차이가 나는 부분이다.\n이제 마지막으로 가비지 수집기에 대해서 다루고 포스팅을 마무리 짓도록 하겠다.</p>\n<h2 id=\"step-5-가비지-수집기\" style=\"position:relative;\"><a href=\"#step-5-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%88%98%EC%A7%91%EA%B8%B0\" aria-label=\"step 5 가비지 수집기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 5. 가비지 수집기</h2>\n<h3 id=\"step-51-serial-gc\" style=\"position:relative;\"><a href=\"#step-51-serial-gc\" aria-label=\"step 51 serial gc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 5.1 Serial GC</h3>\n<p><img src=\"https://i.imgur.com/u6kHGF0.png\" alt=\"\"></p>\n<p>오늘날 개발자들은 자주 사용하지 않을 GC면서 절대로 사용해서는 안되는 방식이다. (CPU 코어가 1개일 경우를 위해서 만든 녀석이다.)</p>\n<ul>\n<li>Young Generation Space(Minor GC) : 우리가 앞서서 봤던 알고리즘대로 동작한다. (수도코드 참고 (복제-정리 알고리즘과 흡사))</li>\n<li>Old Generation Space(Full GC) : 압축-정리 알고리즘을 사용한다.</li>\n</ul>\n<p>GC 쓰레드가 수행되면 다음과 같은 순서에 의해서 동작된다.</p>\n<ol>\n<li>마킹을 수행 (스탑-더-월드 발생)</li>\n<li>정리를 수행</li>\n<li>압축을 수행</li>\n</ol>\n<p>해당 GC를 활성하기 위해서는 <code class=\"language-text\">-XX: +UseSerialGC</code> 를 JVM 인자로 넘겨주면 된다.</p>\n<h3 id=\"step-52-parallel-gc\" style=\"position:relative;\"><a href=\"#step-52-parallel-gc\" aria-label=\"step 52 parallel gc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 5.2 Parallel GC</h3>\n<p><img src=\"https://i.imgur.com/EdWHvqU.png\" alt=\"\"></p>\n<p>동작 원리는 Serial GC와 흡사하지만, 멀티쓰레드로 수행한다는 차이가 존재한다.</p>\n<ul>\n<li>Young Generation Space(Minor GC) : 우리가 앞서서 봤던 알고리즘대로 동작한다. (단, 병렬 복제를 지원)</li>\n<li>Old Generation Space(Full GC) : 압축-정리 알고리즘을 사용한다.</li>\n</ul>\n<p>해당 GC가 생겨나게 된 이유는 멀티 코어 혹은 멀티 CPU 환경이 대두되면서, 힙 영역의 크기 또한 덩달아 커져갔고 Serial GC의 스탑-더-월드는 길어져만 갔다.\n이 길어진 스탑-더-월드를 해결하고, 어플리케이션의 처리량(Throughput)을 증대시키는 것을 목표로 하였다.</p>\n<p>병렬로 여러 쓰레드를 사용하여 동시에 힙 영역을 정리하며,  스탑-더-월드가 발생하지만 Serial GC와 비교해서 시간이 보다 짧으므로 더 나은 성능을 갖는다.</p>\n<p>주의할 점은 병렬 쓰레드로 처리되다보니 두 개의 쓰레드나 프로세스가 동일 메모리 공간을 점유하는 레이스 컨디션 문제가 발생할 수 있다. 이 때문에 동기화 작업이 수반되어야하는데 이 경우 서바이버 영역에서 살아남은 객체들을 승격하는 성능이 떨어지게 된다. 이 때문에, HotSpot VM에서는 PLAB(Parallel Local Allocation Buffer)<sup id=\"fnref-11\"><a href=\"#fn-11\" class=\"footnote-ref\">11</a></sup>라는 승격용 버퍼를 만들었다. 해당 부분은 각주를 보고 참고하자.</p>\n<p>이 GC를 활성화하기 위해서는 <code class=\"language-text\">-XX: +UseParallelGC</code> 인자를 전달하자.</p>\n<h3 id=\"step-53-cms-gc\" style=\"position:relative;\"><a href=\"#step-53-cms-gc\" aria-label=\"step 53 cms gc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 5.3 CMS GC</h3>\n<p><img src=\"https://i.imgur.com/EYVaigT.png\" alt=\"\"></p>\n<p>CMS(Concurrent Mark &#x26; Sweep) GC는 아래의 특징을 갖고 있다.</p>\n<ul>\n<li>Young Generation Space(Minor GC) : 우리가 앞서서 봤던 알고리즘대로 동작한다. (수도코드 참고 (복제-정리 알고리즘과 흡사))</li>\n<li>Old Generation Space(Full GC) : 동시성 기본 정리 알고리즘(Concurrent Mark &#x26; Sweep)</li>\n</ul>\n<p>이 알고리즘의 초점은 GC 이벤트(Fast Elapsed Time)의 기간을 줄이는 것이다.\n즉, 스탑-더-월드의 시간을 적절하게 분산하여 응답시간을 개선하는데 초점을 둔 수집기라고 볼 수 있다.</p>\n<p>이를 단계별로 설명하면 아래와 같다.</p>\n<ol>\n<li>Initial Mark\n<ul>\n<li>힙 내부의 모든 살아있는 객체를 살피는 것이 아니라 Root Set에서 직접적으로 연결된 객체만 마킹한다. 따라서, 스탑-더-월드는 매우 짧다.</li>\n<li>그림에서 보는 바와 같이 이 단계는 싱글 쓰레드로 동작한다.</li>\n</ul>\n</li>\n<li>Concurrent Mark\n<ul>\n<li>Initial Mark 단계에서 식별된 객체들을 대상으로 레퍼런스를 추적하여 마킹을 수행한다.</li>\n<li>이때, 다른 쓰레드가 실행 중인 상태에서 동시에 진행된다. (즉 파란색 쓰레드들은 어플리케이션 실행에 쓰인다.)</li>\n</ul>\n</li>\n<li>Remark\n<ul>\n<li>Concurrent Mark 단계에서 새로 추가되거나 레퍼런스가 끊긴 객체를 확인한다. (실제 스탑-더-월드 발생이 제일 긺)</li>\n</ul>\n</li>\n<li>Concurrent Sweep\n<ul>\n<li>Remark 단계에서 최종적으로 수집 대상이 된 객체들을 정리한다. (이 작업도 다른 쓰레드가 실행 중인 상황에서 동작한다.)</li>\n</ul>\n</li>\n</ol>\n<p>중요한 점은 다른 GC들과 다르게 압축을 수행하지 않는데, 그 이유는 동시성(Concurrent)를 보장하기 위해서는 힙 영역 전체가 멈추는 상황을 최소화해야하는데, 압축을 수행하게될 경우에 위에서 살펴본 바와 같이 모든 메모리 블록을 움직여야하고 그렇다면 힙 영역을 멈춰야하는 작업이 필요하다. 따라서, CMS GC는 압축을 수행하지 않는다.</p>\n<p>위에서 본 압축을 안하면 생기는 단점처럼 CMS 역시, 단편화 현상을 유발할 수 있다.\n이를 위해서 Freelist를 활용하는데 이를 활용하면 Freelist를 탐색하는 과정이 추가되기 때문에 승격(Promotion) 시간이 길어지고, 에덴 영역 혹은 서바이버 영역에 객체가 체류하는 시간이 늘어난다.</p>\n<p>하지만 압축은 위에서 말했듯이 비용이 매우 비싼 작업이므로 승격이 자주 일어나지 않는 경우에 성능 상의 이점을 가져갈 수 있다.</p>\n<h3 id=\"step-54-g1garbage-firstgc\" style=\"position:relative;\"><a href=\"#step-54-g1garbage-firstgc\" aria-label=\"step 54 g1garbage firstgc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 5.4 G1(Garbage First)GC</h3>\n<p><img src=\"https://i.imgur.com/k5VpgxW.png\" alt=\"\"></p>\n<p>자바11부터 기본적으로 설정되는 GC로, 지금까지 살펴보았던 GC들과 다르다.\n위에서 Generational Algorithm에 의해서 힙의 구조가 설계되었고, 대부분의 GC는 이를 따른다고 하였다.</p>\n<p>하지만, G1GC는 Young Generation Space와 Old Generation Space의 물리적인 공간을 허물고, 논리적으로만 분리되게끔 하였다.</p>\n<p>이러한 이유는 위에서 본 GC들의 단점에서부터 비롯되었는데 CMS GC를 설명하면서 결국 압축을 하지않음으로서 파편화가 발생할 수 있다고 하였다. 여기서는 생략했지만 CMS GC 이후에 Parallel Compaction GC라는 수집기도 생겼는데 이름에서만 봐도 알 수 있듯이 결국 다시 “압축” 방식으로 회귀하였다.</p>\n<p>G1GC는 이러한 근본적인 문제를 해결하기 위해서 물리적인 Generation의 구분을 없애고 전체 힙 영역을 리전(Region)이라는 단위로 개편하였다.\n따라서, 더 이상 세대를 관리하는 두 공간 모두 연속된 메모리 공간이라는 보장도 사라졌고, Young / Old라는 개념도 논리적인 개념으로만 자리잡게 되었다.</p>\n<p>이름에서 보듯이 이 수집기의 동작원리를 알 수 있는데 Garbage로 차있는 Region부터 먼저(First) 정리를 수행하기 때문에 G1GC라는 이름이 붙이게 되었다.\n추가적으로 “Humongous Region” 처럼 큰 크기의 객체를 할당하기 위한 리전도 추가가 되었다.</p>\n<ul>\n<li>Minor GC</li>\n</ul>\n<p>Young Generation 리전들을 대상으로 접근가능한 객체를 찾아낸 후 일정 임계치를 넘지 않은 객체들은 서바이버 리전으로 복제(Copy)한다.\n임계치를 넘은 리전들은 Old Generation 리전으로 복제한다. 그리고 기존의 Young Generation은 가비지로 간주하여 Region 단위로 할당을 해지한다.</p>\n<ul>\n<li>Full GC</li>\n</ul>\n<p>Minor GC가 끝나면 바로 Full GC가 발생한다. 그렇다고 해서 이전의 GC들처럼 힙 영역 전반에 걸친 가비지 수집이 일어나지는 않고, Region 단위로 발생한다.\n이러한 까닭에 스탑-더-월드 현상도 해당 리전을 사용하는 쓰레드에 국한된다. 이러한 기법을 통해서 가비지 수집의 충격을 최소화하였다.</p>\n<p>간략한 플로우는 아래와 같다.</p>\n<ol>\n<li>Minor GC 발생 (Evaucation Pause) : 위의 Minor GC와 동일</li>\n<li>Concurrent Mark : 마킹 / 리마킹으로 구분이된다.\n<ul>\n<li>마킹(Marking) : 이전 단계에서 변경된 정보를 토대로 Initial Mark를 빠르게 수행한다. (CMS 참고, CMS와 같이 동시적으로 수행 가능)</li>\n<li>리마킹(Remarking) : 전체 쓰레드가 함께 작업에 참가하여, 스탑-더-월드가 발생하며 각 리전마다 접근가능한 객체를 판별하며 가비지 리전은 다음 단계로 넘어가지 않고 이 단계에서 해지된다.</li>\n</ul>\n</li>\n<li>Old Region Reclaim : Old 리전에 대한 회수 단계로 여기도 리마킹 / Evacauation Pause 단계가 포함된다.\n<ul>\n<li>리마킹(Remarking) : 가비지 수집을 위해 살아있는 객체의 비율이 낮은 리전 중 몇 개를 추려내는 작업을 수행한다.</li>\n<li>Evacuation Pause : Young 리전에 대한 가비지 수집도 포함하며, 리마킹 단계에서 식별한 Old Region과 같이 수집이 된다.\n<ul>\n<li>이렇게 함으로써, 생존률이 높은 리전들만 골라낼 수 있게되고 이 단계에서 Young / Old에 대한 작업이 동시적으로 수행되서 Mixed-GC라고도 부른다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Compaction : 다른 GC의 압축과 달리 동시성을 보장해준다. 이러한 방식이 가능한 이유는 리전단위로 작업을 수행하기 때문이다. 이를 토대로 단편화를 방지할 수 있다.</li>\n</ol>\n<p><img src=\"https://i.imgur.com/7LqTMaD.png\" alt=\"\"></p>\n<p>이에 대한 GC Cycle도 존재하는데 Young-only 단계는 위에서 본 Minor GC의 시작으로 시작되며, 이후  Old Region Reclaim 단계가 Space Reclamation 단계라고 보면 된다.\n여기서 Mixed-GC가 수행되서 공간을 확보하며, 더 이상 효율적으로 Old 리전을 줄일 수 없다 판단되면 다시 Young-only 단계로 돌아간다.</p>\n<h1 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h1>\n<p>어쩌다보니까 초 장문의 글이 되었다.\n정리해서 담으려다보니 대부분의 내용을 담고 싶어졌고, 오히려 욕심때문인지 글이 매우 길어졌다.</p>\n<p>일단, 새벽에 작성하는 글이라 추후 다음을 예정인데 혹시라도 다듬기 전에 글을 보고 계시는 분이라면 댓글로 오타나 수정사항이 있으면 알려주시면 감사할 것 같다.</p>\n<p>아무쪼록 매우 긴 글인데 읽어주셔서 감사합니다.</p>\n<h1 id=\"레퍼런스-및-참고자료\" style=\"position:relative;\"><a href=\"#%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4-%EB%B0%8F-%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\" aria-label=\"레퍼런스 및 참고자료 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>레퍼런스 및 참고자료</h1>\n<ol>\n<li><a href=\"https://docs.oracle.com/javase/specs/jvms/se17/html/jvms-2.html#jvms-2.6.2\">Chapter 2. The Structure of the Java Virtual Machine - Oracle Java SE17 JVM Spec</a></li>\n<li><a href=\"https://homoefficio.github.io/2019/01/31/Back-to-the-Essence-Java-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EC%97%90%EC%84%9C-%EC%8B%A4%ED%96%89%EA%B9%8C%EC%A7%80-1/\">Back to the Essence - Java 컴파일에서 실행까지 - (1) - HomoEfficio</a></li>\n<li><a href=\"https://homoefficio.github.io/2019/01/31/Back-to-the-Essence-Java-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EC%97%90%EC%84%9C-%EC%8B%A4%ED%96%89%EA%B9%8C%EC%A7%80-2/\">Back to the Essence - Java 컴파일에서 실행까지 - (2) - HomoEfficio</a></li>\n<li><a href=\"https://alibabatech.medium.com/how-does-garbage-collection-work-in-java-cf4e31343e43\">How Does Garbage Collection Work in Java? - Alibaba Tech</a></li>\n<li><a href=\"https://johngrib.github.io/wiki/jvm-stack/\">JVM stack과 frame - 기계인간 John Grib</a></li>\n<li><a href=\"https://johngrib.github.io/wiki/defensive-copy/\">방어적 복사(defensive copy) - 기계인간 John Grib</a></li>\n<li><a href=\"https://blog.voidmainvoid.net/315\">Java PermGen의 역사 - 데브원영</a></li>\n<li><a href=\"https://goodgid.github.io/Java-8-JVM-Metaspace/\">Java 8에서 JVM의 변화 : PermGen이 사라지고 Metaspace가 등장하다. - goodGid</a></li>\n<li><a href=\"https://openjdk.org/jeps/122\">JEP 122: Remove the Permanent Generation - OpenJDK Project</a></li>\n<li><a href=\"https://www.oracle.com/webfolder/technetwork/tutorials/mooc/JVM_Troubleshooting/week1/lesson1.pdf\">JVM Trobleshooting MOOC - Oracle</a></li>\n<li><a href=\"https://xephysis.tistory.com/6\">JVM Compressed OOPS - xephysis</a></li>\n<li><a href=\"https://www.baeldung.com/jvm-compressed-oops\">Compressed OOPs in the JVM - Baeldung</a></li>\n<li><a href=\"https://johngrib.github.io/wiki/jvm-memory/\">JVM 메모리 구조와 GC - 기계인간 John Grib</a></li>\n<li><a href=\"https://thinkground.studio/2020/11/07/%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-gc-%EB%82%B4%EC%9A%A9%EA%B3%BC-g1gc-garbage-first-garbage-collector-%EB%82%B4%EC%9A%A9/\">일반적인 GC 내용과 G1GC (Garbage-First Garbage Collector) 내용 - ThinkGround</a></li>\n<li><a href=\"https://velog.io/@hanblueblue/GC-1.-G1GC\">1. G1GC - keep going</a></li>\n<li><a href=\"https://www.codecentric.de/wissens-hub/blog/35gb-heap-less-32gb-java-jvm-memory-oddities\">Why 35GB Heap is Less Than 32GB – Java JVM Memory Oddities - codecentric</a></li>\n</ol>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\"><a href=\"https://thinkpro.tistory.com/67\">댕글링 포인터(Dangling Pointer) -THINK-PRO BLOG</a><a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\"><a href=\"https://en.wikipedia.org/wiki/HotSpot_(virtual_machine)\">HotSpot(virtual machine) - wikipedia</a><a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-3\"><a href=\"https://docs.oracle.com/javase/specs/jvms/se17/html/jvms-2.html#jvms-2.6.3\">Java Virtual Machine Specification - Oracle Docs</a><a href=\"#fnref-3\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-4\"><a href=\"https://johngrib.github.io/wiki/defensive-copy/\">방어적 복사(defensive copy) - 기계인간 John Grib</a><a href=\"#fnref-4\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-5\"><a href=\"https://jojoldu.tistory.com/412\">일급 콜렉션(First Class Collection)의 소개와 써야할 이유 - 기억보단 기록을</a><a href=\"#fnref-5\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-6\"><a href=\"https://en.wikipedia.org/wiki/Object_copying\">Object Copying - wikipedia</a><a href=\"#fnref-6\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-7\"><a href=\"https://medium.com/javarevisited/curious-case-of-island-of-isolation-6243f3a6698d\">The curious case of Island of Isolation - Arun Jijo</a><a href=\"#fnref-7\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-8\"><a href=\"https://jeong-pro.tistory.com/91\">메모리 단편화(Memory Fragmentation)가 무엇이고 왜 발생하는가? - 기본기를 쌓는 정아마추어 코딩블로그</a><a href=\"#fnref-8\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-9\"><a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/generations.html\">Generations - Oracle JDK8 Docs</a><a href=\"#fnref-9\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-10\"><a href=\"https://wiki.openjdk.org/display/HotSpot/CompressedOops\">CompressedOops - OpenJDK Wiki</a><a href=\"#fnref-10\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-11\"><a href=\"https://alidg.me/blog/2019/6/21/tlab-jvm\">Thread-Local Allocation Buffers in JVM - Kemikit</a><a href=\"#fnref-11\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>","excerpt":"STEP 1. 자바 메모리 관리 STEP 2. 메모리 영역 STEP 2.1 스택 영역 STEP 2.2 힙 영역 STEP 2.3 번외) 레퍼런스 타입 사용 주의사항 STEP 3. 실행 엔진 STEP 3.1 GC STEP 3.1.1 GC Root Set STEP 3.2 식별 알고리즘 STEP 3.2.1 스탑-더-월드 STEP 3.2.2 레퍼런스 카운팅 STEP 3.3 정리 알고리즘 STEP 3.3.1 기본 정리 알고리즘 STEP 3.3.2 압축-정리 알고리즘 STEP 3.3.3 복제-정리 알고리즘 STEP 3.4 GC 알고리즘 중간 정리 STEP 3.5 Generational Algorithm STEP 3.6 Heap의 구조와 GC의 기본 동작 STEP 4. 메서드 영역(메타스페이스 영역) STEP 4.1 자바 8 이전과 이후의 메서드 영역 STEP 4.2 메서드 영역에서의 GC 동작 STEP 5. 가비지 수집기 STEP 5.1 Serial GC STEP 5.2 Parallel GC …","frontmatter":{"date":"July 15, 2023","title":"Fundamental of JVM and Memory and GC - Java JVM과 메모리 그리고 GC의 동작 과정 이해","categories":"개발","author":"개발한입","emoji":"💻"},"fields":{"slug":"/fundamental-jvm-memory/"}},"next":{"id":"174ae09d-f54c-5e52-9b16-a17b05c7b0c0","html":"<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#step-11-%EA%B3%BC%EA%B1%B0%EC%9D%98-%EC%9D%B4%EC%95%BC%EA%B8%B0\">STEP 1.1 과거의 이야기</a></p>\n</li>\n<li>\n<p><a href=\"#step-12-%EB%B2%88%EC%99%B8-nvme%EB%A5%BC-%EC%8A%A4%EC%99%91-%EC%98%81%EC%97%AD%EC%9C%BC%EB%A1%9C-%EC%9E%A1%EC%9C%BC%EB%A9%B4-ram%EA%B3%BC-%EC%86%8D%EB%8F%84%EA%B0%80-%EB%B9%84%EC%8A%B7%ED%95%A0%EA%B9%8C\">STEP 1.2 번외) NVMe를 스왑 영역으로 잡으면 RAM과 속도가 비슷할까?</a></p>\n</li>\n<li>\n<p><a href=\"#step-21-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EC%BA%90%EC%8B%9C-%EC%98%81%EC%97%AD%EA%B3%BC-%EC%8A%A4%EC%99%80%ED%95%91\">STEP 2.1 운영체제의 캐시 영역과 스와핑</a></p>\n<ul>\n<li><a href=\"#step-211-%EC%BA%90%EC%8B%9C%EC%98%81%EC%97%AD\">STEP 2.1.1 캐시영역</a></li>\n<li><a href=\"#step-212-%EC%8A%A4%EC%99%80%ED%95%91\">STEP 2.1.2 스와핑</a></li>\n<li><a href=\"#step-213-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%9E%AC%ED%95%A0%EB%8B%B9-%EB%B0%A9%EC%8B%9D\">STEP 2.1.3 운영체제의 메모리 재할당 방식</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-22-%EC%9E%90%EB%B0%94-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98\">STEP 2.2 자바, 페이지 캐시 그리고 가비지 컬렉션</a></p>\n<ul>\n<li><a href=\"#step-221-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%99%80-%EB%8D%94%ED%8B%B0-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%8F%99%EA%B8%B0%ED%99%94\">STEP 2.2.1 페이지 캐시와 더티 페이지 동기화</a></li>\n<li><a href=\"#step-222-%EC%9E%90%EB%B0%94-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%99%80-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98\">STEP 2.2.2 자바 메모리와 가비지 컬렉션</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-31-%EC%B6%94%EC%8B%A0\">STEP 3.1 추신</a></p>\n</li>\n</ul>\n</div>\n<ul>\n<li>STEP 1. 서론\n<ul>\n<li>STEP 1.1 과거의 이야기</li>\n<li>STEP 1.2 번외) NVMe를 스왑 영역으로 잡으면 RAM과 속도가 비슷할까?</li>\n</ul>\n</li>\n<li>STEP 2. 본론\n<ul>\n<li>STEP 2.1 운영체제의 캐시 영역과 스와핑\n<ul>\n<li>STEP 2.1.1 캐시영역</li>\n<li>STEP 2.1.2 스와핑</li>\n<li>STEP 2.1.3 운영체제의 메모리 재할당 방식</li>\n</ul>\n</li>\n<li>STEP 2.2 자바, 페이지 캐시 그리고 가비지 컬렉션\n<ul>\n<li>STEP 2.2.1 페이지 캐시와 더티 페이지 동기화</li>\n<li>STEP 2.2.2 자바 메모리와 가비지 컬렉션</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>STEP 3. 결론</li>\n<li>STEP 4. 참고자료</li>\n</ul>\n<h1 id=\"step-1-서론\" style=\"position:relative;\"><a href=\"#step-1-%EC%84%9C%EB%A1%A0\" aria-label=\"step 1 서론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1. 서론</h1>\n<p>카프카 핵심가이드를 읽으면서, 챕터 1의 운영체제 튜닝하기(p.40) 부분을 보면서 궁금한 점이 생겨났다.</p>\n<blockquote>\n<p>대부분의 어플리케이션, 특히 처리량이 중요한 어플리케이션에서는 (거의) 어떻게 해서든 스와핑을 막는 것이 최선이다.</p>\n<p>-카프카 핵심가이드, p.40-</p>\n</blockquote>\n<p>당연히, 운영체제 레벨에서 지원하는 가상 메모리는 실제 메모리가 아니고 디스크를 임시로 메모리처럼 사용하는 방식이기에 이 부분은 <strong>처리량이 중요한</strong> 어플리케이션이면 사용하지 않는 것이 맞다는 생각은 들었으나 정확히 왜? 라는 부분에 대해서는 궁금증이 생겼다.</p>\n<p>이 내용은 카프카 뿐만아니라 ES에도 정리가 되어있다.</p>\n<ul>\n<li><a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/setup-configuration-memory.html\">Disable swapping - Elasticsearch Guide 8.8</a></li>\n</ul>\n<p>이 부분에 대해서 정리를 해보고자 한다.</p>\n<p>물론, 독자분들이 스왑(가상 메모리) 영역에 대한 기본적인 개념이 있다고 가정하고 서술할 내용이니 이 부분을 잘 모른다면 다른 블로그나 기타 자료를 참고해보기 바란다.</p>\n<h2 id=\"step-11-과거의-이야기\" style=\"position:relative;\"><a href=\"#step-11-%EA%B3%BC%EA%B1%B0%EC%9D%98-%EC%9D%B4%EC%95%BC%EA%B8%B0\" aria-label=\"step 11 과거의 이야기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.1 과거의 이야기</h2>\n<p>리눅스를 직접 설치한지가 벌써 10년 전으로 기억하는데 그때 당시만 해도, 스왑 영역에 대한 가이드로 대부분의 블로그에 아래와 같은 글들이 많이 보였다.</p>\n<blockquote>\n<p>스왑 영역은 RAM의 2배정도 크기로 할당한다.</p>\n</blockquote>\n<p>사실, 이 내용은 레드햇 공식 가이드에 있던 내용으로 인해서 구전되던 내용이 여러번 희석되서 해당 시스템의 메모리 2배를 할당한다고 내려온거지 않을까? 생각해본다.</p>\n<p>아래는 현재 RHEL 9의 스왑 영역에 대한 가이드이다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/5q8qYzf.png\">\n</p>\n<p align=\"center\">\n    <em>그림 1. <a href=\"https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/managing_storage_devices/getting-started-with-swap_managing-storage-devices\">RHEL Recommended System Swap Space</a></em>\n</p>\n<p>학생때는 스왑 메모리에 대한 이해가 없이 사용하다보니 위와 같은 가이드를 따르기 보다는 통상 2배로 설정하라해서 그대로 따랐던 기억이 있다.</p>\n<p>하지만, 요즘날과 같이 물리 메모리(RAM)이 저렴해진 환경에서 스왑이 굳이 필요할까? 이러한 생각도 들게되었다.</p>\n<p>이 부분은 서버 엔지니어분들이 많이 계신 커뮤니티인 2cpu에 많은 질답이 오고간 것을 확인할 수 있다.</p>\n<ol>\n<li><a href=\"https://www.2cpu.co.kr/QnA/477563#c_477565\">Ubuntu Swap 파티션 크기 - 2cpu</a></li>\n<li><a href=\"https://www.2cpu.co.kr/bbs/board.php?bo_table=QnA&#x26;wr_id=556001\">요즘같이 메모리 큰 환경에서 리눅스 스왑영역은 어떻게 잡으세요? - 2cpu</a></li>\n</ol>\n<p>1번은 15년도에 올라온 질문글이고, 2번은 16년도에 올라온 질문글임을 확인할 수 있다.</p>\n<p>1번 질문 글의 경우에는 김한구님께서 답변해주신 내용이 인상 깊었다.</p>\n<blockquote>\n<p>스왑 파티션이라는 것이 옛날에 물리적인 메모리가 부족하던 시절, 하드 디스크를 메모리처럼 사용하려고 만들어진 것인데 메모리가 128기가인 경우에는 부족할 것 같지 않으니 필요가 없어보인다. 그러나, 스왑을 안잡으면 경고 메시지가 뜰테니 대략 2-4기가 정도만 잡아도 충분해보인다.</p>\n</blockquote>\n<p>레드햇의 가이드와 매우 흡사해보인다.</p>\n<p>2번 질문 글의 경우에는 2가지 답변이 인상 깊었다.</p>\n<ul>\n<li>깡통이님</li>\n</ul>\n<blockquote>\n<p>스왑의 사용할 때의 장점은 2가지입니다.</p>\n<ol>\n<li>스왑이 있으면 실제 메모리 이상으로 사용했을 때 다운되지 않고, 느려지면서 동작</li>\n<li>스왑이 있으면 OS는 거의 사용하지 않는 메모리 영역을 스왑으로 내리고,  확보된 공간을 디스크 캐쉬로 돌릴 수 있다.</li>\n</ol>\n<p>스왑을 사용해서 느려지는건 싫지만, 1번의 경우때문에 스왑을 사용하게 하고 싶으면 적당히 잡고 vm.swappiness를 0 ~ 10 사이로 설정해서 최대한 물리메모리를 사용하도록 설정하면 됩니다.</p>\n</blockquote>\n<ul>\n<li>박님</li>\n</ul>\n<blockquote>\n<p>어플리케이션에 따라서도 달라집니다.\n오라클의 경우 메모리의 3배를 권장하기도하고, 특수한 경우 메모리의 내용을 덤프 받기 위해 최소 메모리 용량만큼의 스왑 공간을 요구하는 경우도 있습니다.</p>\n</blockquote>\n<p>또한, 다른 분께서는 스왑을 사용하는 이유에 최대절전모드(hibernation)을 얘기도 했는데 이 부분은 <a href=\"https://kwonnam.pe.kr/wiki/linux/ubuntu/hibernation\">Ubuntu Linux Hibernation - 권남</a> 를 참고해보자. 아마 최대절전모드가 동작할 때 스왑 영역을 활용하는 것으로 보인다.</p>\n<p>종합을 해보면 아래와 같은 결론을 내릴 수 있을 것이다.</p>\n<ul>\n<li>가용한 물리적 메모리와 어플리케이션의 사용량에 따라 스왑을 적절하게 설정할 수 있다.\n<ul>\n<li>만약, 필요가 없다 가정하면 아예 설정을 하지않을 수 있다.</li>\n</ul>\n</li>\n<li>스왑 영역을 세팅한다면 실제 RAM을 초과해도 속도는 느려지겠지만 시스템 다운은 막을 수 있다.</li>\n</ul>\n<h2 id=\"step-12-번외-nvme를-스왑-영역으로-잡으면-ram과-속도가-비슷할까\" style=\"position:relative;\"><a href=\"#step-12-%EB%B2%88%EC%99%B8-nvme%EB%A5%BC-%EC%8A%A4%EC%99%91-%EC%98%81%EC%97%AD%EC%9C%BC%EB%A1%9C-%EC%9E%A1%EC%9C%BC%EB%A9%B4-ram%EA%B3%BC-%EC%86%8D%EB%8F%84%EA%B0%80-%EB%B9%84%EC%8A%B7%ED%95%A0%EA%B9%8C\" aria-label=\"step 12 번외 nvme를 스왑 영역으로 잡으면 ram과 속도가 비슷할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.2 번외) NVMe를 스왑 영역으로 잡으면 RAM과 속도가 비슷할까?</h2>\n<p>혹자는 이런 생각을 할 수 있을 것이다.</p>\n<blockquote>\n<p>아니 NVMe를 사용하면, 거의 RAM과 속도가 비슷할테니 NVMe를 꽂은 후 이를 스왑 영역으로 잡으면 사실 상 램이 증설된 효과를 주는거 아닌가요?</p>\n</blockquote>\n<p>물론, 현재 NVMe가 DDR2의 속도를 따라잡긴했다. 하지만, DDR4는 일반적으로 20GB/s 속도이고, NVMe는 4개의 PCIe 레인을 사용하고, PCIe 3.0 기준으로 8GB/s의 속도를 가지게 된다.</p>\n<p>물론 레인(4개가 아닌 16개)을 증설하거나 PCIe 인터페이스 버전이 4.0일 경우에는 또 달라질 것이다.  하지만 이 글을 쓰는 시점에서 RAM은 DDR5 시대가 도래했고, PCIe 3.0 vs PCIe 4.0 차이에 대한 기사를 보니 성능차이가 미미하다는 점도 있다.</p>\n<p>참고 : <a href=\"http://www.weeklypost.kr/news/articleView.html?idxno=4258\">NVMe ‘PCIe 3.0 vs PCIe 4.0’ 성능? 어라, 차이없네</a></p>\n<p>그리고 위와 같은 가정도 <strong>순차적인 읽기 쓰기만 고려한 점</strong>이라는 것이다. RAM의 가장 중요한 기능 중 하나는 <strong>랜덤 액세스</strong>인데 위와 같은 가정도 <strong>랜덤 액세스로 비교를 하게되면 NVMe의 성능은 고대의 SDRAM과 비교할 수 없을 정도로 느리다.</strong></p>\n<p>그래도, HDD보다는 NVMe나 SSD를 사용하는 것이 훨씬 빠르니 적용할만하다고 생각한다.\n본디, 과거에는 SSD 수명이 매우 짧다보니 스왑으로 활용할 경우 SSD 수명이 가파르게 깎이는 문제점이 존재했으나, <a href=\"https://www.jedec.org/standards-documents/focus/flash/solid-state-drives\">JEDEC Standards</a> 를 참고하면 요즘날 SSD에는 크게 걱정할 요소는 아님으로 보인다.</p>\n<h1 id=\"step-2-본론\" style=\"position:relative;\"><a href=\"#step-2-%EB%B3%B8%EB%A1%A0\" aria-label=\"step 2 본론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2. 본론</h1>\n<p>과거의 사례를 들어서 이야기를 해보았다. 스왑 영역을 사용하는 케이스는 아래와 같다고 정리를 할 수 있다.</p>\n<ul>\n<li>가용한 물리적 메모리와 어플리케이션의 사용량에 따라 스왑을 적절하게 설정할 수 있다.\n<ul>\n<li>만약, 필요가 없다 가정하면 아예 설정을 하지않을 수 있다.</li>\n</ul>\n</li>\n<li>스왑 영역을 세팅한다면 실제 RAM을 초과해도 속도는 느려지겠지만 시스템 다운은 막을 수 있다.</li>\n</ul>\n<p>이 두가지 결론으로 인하여 스왑은 메모리보다 속도는 느리긴 하나 가용 메모리가 없을 경우 최악의 사태는 방지할 수 있다는 점을 알 수 있다.</p>\n<p>그렇다면 이제 본격적으로 <code class=\"language-text\">vm.swappiness = 1</code>로 설정하는 이유에 대해서 설명을 해보고자한다.\n두 부분을 살펴봐야하는데 먼저 <strong>운영체제 레벨</strong>을 살펴본 후에 <strong>JVM 레벨</strong>을 살펴보는 식으로 글을 서술하고자한다.</p>\n<p>먼저, 운영체제의 캐시 관련하여 이야기가 필요하므로 이 이야기부터 진행해보고자 한다.</p>\n<h2 id=\"step-21-운영체제의-캐시-영역과-스와핑\" style=\"position:relative;\"><a href=\"#step-21-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EC%BA%90%EC%8B%9C-%EC%98%81%EC%97%AD%EA%B3%BC-%EC%8A%A4%EC%99%80%ED%95%91\" aria-label=\"step 21 운영체제의 캐시 영역과 스와핑 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.1 운영체제의 캐시 영역과 스와핑</h2>\n<h3 id=\"step-211-캐시영역\" style=\"position:relative;\"><a href=\"#step-211-%EC%BA%90%EC%8B%9C%EC%98%81%EC%97%AD\" aria-label=\"step 211 캐시영역 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.1.1 캐시영역</h3>\n<p>OS 커널은 블록 디바이스(Block Devices)<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup> 라는 값을 통해서 디스크로 부터 데이터를 읽거나 쓴다. 하지만 당연히 이 비용은 디스크를 통하다보니 비쌀 수 밖에 없다.</p>\n<p>그래서, 커널은 메모리의 일부에 캐시영역<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup>을 두어 한 번 읽은 디스크의 내용을 메모리에 저장해두어 동일한 내용을 읽고자하면, 디스크에 읽기 요청을 하는 것이 아니라 캐시 영역에 값이 존재하는지 확인한 후에 가져온다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/cx5KQtU.png\">\n</p>\n<p align=\"center\">\n    <em>그림 2. 캐시영역 적재 흐름도</em>\n</p>\n<p>그림으로 보면 위와 같다고 볼 수 있다.\n실제 어플리케이션 로드 상황에서 메모리 영역 사용 현황을 보면 아래와 같이 이뤄질 것 이다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/ddqF2a0.png\">\n</p>\n<p align=\"center\">\n    <em>그림 3. 어플리케이션 로드 이후의 가용 메모리 변화</em>\n</p>\n<ol>\n<li>초기에 사용중인 메모리 영역과 가용 메모리 영역이 존재</li>\n<li>시간이 흐름에 따라 캐시영역에 데이터가 적재</li>\n<li>어플리케이션에서 사용하게 되는 영역이 점점 많아짐</li>\n<li>사용 중인 메모리 영역이 점점 커지면 캐시 영역에서 사용되던 일부를 어플리케이션이 사용하도록 변경</li>\n</ol>\n<p>이 과정 속에서 더 이상 가용 메모리가 충분하지않을 수 있는데 이때 스왑 영역이 존재하면 스왑을 사용하게 된다.</p>\n<p>그렇다면 이 스왑을 사용하는 과정은 어떻게 진행될까?</p>\n<h3 id=\"step-212-스와핑\" style=\"position:relative;\"><a href=\"#step-212-%EC%8A%A4%EC%99%80%ED%95%91\" aria-label=\"step 212 스와핑 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.1.2 스와핑</h3>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/8BNaTLn.png\">\n</p>\n<p align=\"center\">\n    <em>그림 4. 스와핑 동작 방식</em>\n</p>\n<p>OS 레벨에서의 스와핑은 위와 같이 동작을 한다.</p>\n<p>그러나, 위 그림을 보고 의아할 수도 있다.</p>\n<blockquote>\n<p>왜 프로세스가 디스크 영역에 적재되나요?</p>\n</blockquote>\n<p>그림 4는 기본적인 OS의 스와핑(Swapping)방식이다. 하지만, 가상 메모리(스왑 영역)는 <strong>프로세스 단위로 스와핑을 하는 것이 아니라 페이지 단위로 스와핑</strong>한다.</p>\n<p>그림 2에 나와있는 캐시 영역은 사실 페이지 캐시(Page Cache)<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup> 를 통해서 관리되는데, 이는 후술할 내용이므로 그냥 단순하게 <strong>캐시 영역에서 스왑 영역으로 이동되는 스와핑은 데이터가 디스크에 적재</strong>된다고 보면 될 것 같다.</p>\n<p>이 부분에 대해서 좀 더 깊게 알고 싶다면 아래의 링크를 참고하자.</p>\n<ul>\n<li><a href=\"https://resilient-923.tistory.com/397\">운영체제(OS) 스와핑(swapping), 가상메모리(virtual memory) 란? - 빠르고 꾸준하게</a></li>\n</ul>\n<p>그림 4에서 보는 것과 같이 스와핑에는 2가지 동작이 존재한다.</p>\n<ul>\n<li><strong>스왑-아웃(swap-out)</strong> : 메모리의 데이터 중 자주 사용되지 않은 데이터를 스왑영역으로 이동</li>\n<li><strong>스왑-인(swap-in)</strong> : 스왑으로 옮겨진 데이터를 다시 읽기 위해 데이터를 디스크에서 가져옴</li>\n</ul>\n<p>서론에서 얘기했듯이 <strong>Disk I/O 비용은 비싸다.</strong></p>\n<p>그리고 가장 큰 문제는 우리는 그림3과 같이 <strong>점점 어플리케이션이 사용량이 증가함에 따라 가용영역이 부족할 경우만 스와핑이 이뤄질 것으로 기대하지만 실제 동작은 그렇지 않다</strong>는 점이다.</p>\n<blockquote>\n<p>즉, 캐시영역이나 가용영역이 널널해도 스와핑이 발생할 수 있다.</p>\n</blockquote>\n<p>이 부분을 이해하기 위해서는 운영체제의 메모리 재할당 방식에 대해서 이해해야한다.</p>\n<h3 id=\"step-213-운영체제의-메모리-재할당-방식\" style=\"position:relative;\"><a href=\"#step-213-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%9E%AC%ED%95%A0%EB%8B%B9-%EB%B0%A9%EC%8B%9D\" aria-label=\"step 213 운영체제의 메모리 재할당 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.1.3 운영체제의 메모리 재할당 방식</h3>\n<p><strong>리눅스 커널은 메모리가 유휴 상태(idle state)로 남아있는 것을 선호하지 않는다.</strong> 이 과정을 나타낸 것이 바로 그림 3이라 보면될 것이다. 커널은 캐시 영역을 활용하는 식으로 하여 유휴 상태로 만들지 않는데, 이런식으로 운영되다보니 가용 메모리가 계속 줄게 된다. 이 때 <strong>사용하지 않는 메모리를 확인하여 필요하는 곳에 재할당 하는 것을 메모리 재할당</strong>이라 한다.</p>\n<p>그림 3의 4번째 단계를 보면 캐시 영역이 줄어들고 사용하는 메모리 영역이 증가된 것을 볼 수가 있는데 메<strong>모리 재할당 과정에서 주로 캐시 영역을 반환하고, 스와핑도 발생</strong>하게 된다.</p>\n<p><strong>즉, 가용 메모리 영역이 없다면 사용 중인 메모리 중에 반환 할 수 있는 메모리가 있는지 찾아서 반환하게 된다.</strong></p>\n<p>이때 바로 <code class=\"language-text\">vm.swappiness</code> 커널 파라미터가 사용되게 된다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/AMImeT5.png\">\n</p>\n<p align=\"center\">\n    <em>그림 5. 메모리 재할당 방식</em>\n</p>\n<p>설명했던 메모리 재할당 과정을 간략하게 표현한 것이 그림 5라고 보면 될 것이다.</p>\n<p>스와핑을 다루면서 캐시 영역이나 가용 메모리 영역이 널널한데 스와핑이 발생할 수 있다고 말했었는데 그 이유가 바로 <code class=\"language-text\">vm.swappiness</code> 값에 따라 동작 방식이 다르기 때문이다.</p>\n<p>저 커널 파라미터는 커널이 <strong>얼마나 공격적으로 메모리 영역을 스왑 영역으로 옮기느냐를 결정하는 파라미터</strong>이다. 따라서 이 값이 높아지면 캐시 영역이 여유가 있음에도 불구하고 스왑 영역을 사용하게된다. 따라서, 불필요한 스와핑이 발생하고 Disk I/O가 발생하므로 성능에 영향을 끼치는 것이다.</p>\n<p>따라서, 처리량이 높은 어플리케이션에서 <code class=\"language-text\">vm.swappiness = 1</code>로 설정하는 이유는 <strong>메모리 재할당 과정 속에서 불필요한 스와핑을 줄이고, 가능한 캐시영역을 비우고 스왑을 사용</strong>하고자 함이다.</p>\n<p>이 비율을 계산하는 공식인 Swap Tendency도 존재한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">swap_tendency = mapped_ratio/2 + distress + vm_swappiness;</code></pre></div>\n<p>이 부분은 범위를 벗어나는 부분으로 재할당 부분과 해당 파라미터 등을 자세히 알고 싶다면 아래의 링크를 참고하자.</p>\n<ul>\n<li><a href=\"https://brunch.co.kr/@alden/14\">메모리 재할당과 커널 파라미터 - 강진우님</a></li>\n</ul>\n<p>참고로 0이 아닌 1로 설정하는 이유도 위 저자분께서 친절하게 작성해두셨다.</p>\n<blockquote>\n<p>다만 1로 설정했을 때보다 훨씬 더 많은 page cache를 해제하게 됩니다.\n거의 한자리 수까지 털어 버리기 때문에 좀 더 안정적인 성능의 시스템을 원한다면 1로 세팅해서 사용하는 것도 좋을 것이라 생각됩니다.</p>\n<p>page cache를 지나치게 버리면 I/O가 높아지고 시스템의 load를 상승시킬 수 있기  때문입니다.</p>\n</blockquote>\n<p>여기서 추가적으로 페이지 캐시를 다 버리는데 왜 I/O가 높아지는지에 대해서는 JVM 레벨에서의 내용을 다루면서 서술하고자한다.</p>\n<h2 id=\"step-22-자바-페이지-캐시-그리고-가비지-컬렉션\" style=\"position:relative;\"><a href=\"#step-22-%EC%9E%90%EB%B0%94-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98\" aria-label=\"step 22 자바 페이지 캐시 그리고 가비지 컬렉션 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.2 자바, 페이지 캐시 그리고 가비지 컬렉션</h2>\n<p>위에서는 운영체제 레벨에서 해당 내용을 다뤘다 물론, 저기서 끝내도 무방하지만 필자는 <code class=\"language-text\">vm.swappniess</code> 값과 JVM과는 상관관계가 있는지 궁금했다.</p>\n<p>왜냐면, Kafka와 ES 모두 JVM 위에서 동작하는 녀석들이기 때문이다.</p>\n<p>사실 이 부분도 JVM 내부를 분석한다던가 그런 내용은 아니다. 위의 기저지식을 기반으로 좀 더 세부적인 내용을 다루고, 실질적으로 어떤 영향을 끼치는지 서술할 예정이다.</p>\n<p>그 전에 우리는 먼저 페이지 캐시에 알 필요가 있다.</p>\n<h3 id=\"step-221-페이지-캐시와-더티-페이지-동기화\" style=\"position:relative;\"><a href=\"#step-221-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%99%80-%EB%8D%94%ED%8B%B0-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%8F%99%EA%B8%B0%ED%99%94\" aria-label=\"step 221 페이지 캐시와 더티 페이지 동기화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.2.1 페이지 캐시와 더티 페이지 동기화</h3>\n<p>사실, 그림 2에서 봤던 캐시 영역과 그림 5에서 봤던 캐시 영역 모두 페이지 캐시와 동치된다고 봐도 무방하다.</p>\n<p>우리는 위에서 <strong>페이지 캐시를 통해서 한번 읽은 데이터를 적재해두고 Disk I/O를 줄이는 방식</strong>으로 운영체제가 동작함을 알게되었다.</p>\n<p>그러면 아래와 같은 궁금증이 생기는 분도 계실 것이다.</p>\n<blockquote>\n<p>만약, 페이지 캐시에 적재된 페이지 중에서 변경이 발생하면 어떻게 되나요?</p>\n</blockquote>\n<p>현재 이 글을 읽는 분들 중에서 JPA를 사용하시는 분이라면 더티 체킹(Dirty Checking)<sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup>라는 용어를 들어보셨을 것이다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/JsiNr2f.png\">\n</p>\n<p align=\"center\">\n    <em>그림 6. 더티체킹, 자바 ORM 표준 JPA 프로그래밍, 김영한 저</em>\n</p>\n<p>간략하게 위 그림을 설명하면, 1차 캐시를 페이지 캐시라 생각하고, 기존에 적재된 내역의 상태를 스냅샷으로 볼 수 있을 것이다. 이 후 엔티티 매니저를 통해서 스냅샷을 비교하여 업데이트를 수행한다.</p>\n<p>사실 이러한 동작방식은 운영체제 레벨에서도 비슷하다. 운영체제에서는 기존 페이지 캐시에 적재된 데이터인데 변경이 이뤄진 페이지를 더티 페이지(Dirty Page)<sup id=\"fnref-5\"><a href=\"#fn-5\" class=\"footnote-ref\">5</a></sup>라 부른다.</p>\n<p>식별 방식과 처리 방식은 아래의 그림과 같다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/2IXA7Yc.png\">\n</p>\n<p align=\"center\">\n    <em>그림 7. 더티 페이지 감지 및 동기화 방식</em>\n</p>\n<ol>\n<li>A, B, C라는 데이터가 페이지 캐시에 있고, 이 값들은 디스크에 이미 적재되었다고 가정한다.</li>\n<li>페이지 캐시의 데이터 중 B -> D로 변경되었는데 이때 바로 디스크에 반영하지는 않고, 페이지 캐시에는 더티페이지를 들고있는다.</li>\n<li>특정 조건이 채워졌을 경우에 더티페이지를 디스크에 반영한다.</li>\n</ol>\n<p>위의 방식으로 처리된다고 볼 수 있다.\n여기서 페이지 캐시에서 발생된 <strong>더티페이지를 디스크에 쓰는 행위를 더티 페이지 동기화</strong>라 한다.</p>\n<p>그러면 우리는 아래와 같은 가정을 가질 수 있다.</p>\n<ul>\n<li>만약, 동기화 특정 조건을 매우 짧게 가져간다면? -> 더티페이지 생성마다 빈번하게 Disk I/O 발생</li>\n<li>만약, 동기화 특정 조건을 매우 길게 가져간다면? -> 더티페이지가 페이지캐시에 적재되는데 서버다운 시 이 데이터들은 모두 휘발</li>\n</ul>\n<p>역시 <strong>은총알은 없다.(No Silver Bullet)</strong> 하지만 우리는 처리량이 높은 JVM 어플리케이션을 기준으로 설명하고 있다보니 Disk I/O를 줄이는게 좀 더 초점이 될 수 있을 것이다.</p>\n<p>동기화의 발생 횟수 등 조건을 제어하는 커널 파라미터는 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">vm.dirty_backgroud_ratio \nvm.dirty_ratio \n... etc ...</code></pre></div>\n<p>이 부분에 대해서 좀 더 깊게 보고 싶으면 아래의 링크를 참고해보자.</p>\n<ul>\n<li><a href=\"https://brunch.co.kr/@alden/32\">dirty page 동기화 #1 - 강진우님</a></li>\n</ul>\n<h3 id=\"step-222-자바-메모리와-가비지-컬렉션\" style=\"position:relative;\"><a href=\"#step-222-%EC%9E%90%EB%B0%94-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%99%80-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98\" aria-label=\"step 222 자바 메모리와 가비지 컬렉션 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.2.2 자바 메모리와 가비지 컬렉션</h3>\n<p>사실 이전의 내용들을 이 내용을 위한 빌드업이라고 볼 수 있다. 이제는 Kafka와 ES의 사례를 들어서 위의 내용들을 종합하고자 한다.</p>\n<p>우선, 자바 개발자면 이런 생각을 갖을 수 있다.</p>\n<blockquote>\n<p>그러면 스왑이든 페이지 캐시든 사용하기 번거로우니 자바에서 인-메모리로 관리하면 안되나요? 어차피 GC가 알아서 해주지 않나요? ㄹㅇㅋㅋ</p>\n</blockquote>\n<p>그러나, Kafka와 ES 모두 운영체제의 페이지 캐시를 활용하는데 도대체 그 이유가 무엇일까?\n이 해답은 <a href=\"https://docs.confluent.io/kafka/design/file-system-constant-time.html#ak-and-the-jvm\">Kafka 공식 문서</a>에 나와있다.</p>\n<blockquote>\n<p>Kafka is built on top of the JVM, and Java memory usage has the following characteristics:</p>\n<ol>\n<li>The memory overhead of objects is very high, often doubling the size of the data stored (or worse).</li>\n<li>Java garbage collection becomes increasingly slow as the in-heap data increases.</li>\n</ol>\n</blockquote>\n<p>즉, 위 2가지 특성때문에 자바 메모리로 관리하는 캐시보다 운영체제의 페이지 캐시를 사용하게 디자인되었다고 보면된다. 그리고 이러한 디자인의 가장 큰 장점은 바로 <strong>GC의 패널티</strong>를 줄일 수 있다는 점이다.</p>\n<p>어찌됐든 STW(Stop-the-world)는 GC하는 순간에 발생한다. 만약, 대량의 데이터가 메모리에 올라가진 상태에서 GC가 발생한다면? 그게 Full-GC라면? STW로 어플리케이션이 멈추는 시간은 매우 길어질 것이다.</p>\n<p>다른 장점으로는 어플리케이션 재시작 상황을 가정해보자 우리가 만약 캐시를 자바 메모리로 관리하고 있었다면 재시작하는 순간 캐시들이 전부 휘발될테고 이 캐시를 웜업하기 위해서 다시 상당한 시간이 소요될 것이다.</p>\n<p>하지만, 운영체제의 페이지 캐시로 관리하면 어플리케이션의 동작유무와 별개로 캐시는 존재할 것이므로 다시 웜업하는 비용이 단축될 것이다.</p>\n<p>이것과 관련된 재미난 이슈를 아래의 링크에서 확인할 수 있다.</p>\n<ul>\n<li><a href=\"https://access.redhat.com/solutions/2685771\">Java process takes a long time with -XX:+AlwaysPreTouch - Red Hat Customer Portal</a></li>\n</ul>\n<p>간단하게 설명하면 <code class=\"language-text\">-XX:+AlwaysPreTouch</code> 옵션은 Heap 사이즈가 큰 경우에 공간을 0으로 채워 초기화하는데 부팅 속도는 느려지지만 실행시 속도는 빨라진다는 이점이 있다. 즉, <strong>웜업 비용이 단축</strong>되는 명령어라고 보면될 것같다.</p>\n<p>해당 옵션을 사용하면 Xmx 설정한 힙사이즈(최대 힙사이즈)를 모두 0으로 터치한다. 이 케이스에서 원래 우리가 그림 3에서 봤던 거처럼 점진적으로 페이지 캐시가 할당되는게 어플리케이션 시작점부터 운영체제에 페이지를 요청한다.</p>\n<p>그러면 가용 메모리 영역에서 페이지를 요청하기 위해서 메모리 재할당 과정이 이뤄질 것이다.</p>\n<p>그 뒤를 생각해보자. 운영체제에 메모리를 요청해서 페이지가 생겼는데 동작과정 속에서 이미 페이지가 생겼으니 데이터가 변경될때마다 더티페이지가 생길 것이다.</p>\n<p>자 이때 가용 메모리가 부족하여 재할당 과정이 발생한다고 가정해보자. 그러면 이미 많은 양의 페이지 캐시가 생성되어있으므로 그만큼 재할당을 하는 과정이 느려질 것이고, 더티페이지 커널 파라미터도 별도 튜닝을 안했다면 Disk I/O도 많이 발생할 것이다.</p>\n<p>해당 이슈는 위와 같은 이유때문에 느려진 것이 않을까? 추론할 수 있을 것이다.</p>\n<p>자 이제, JVM 상에서 동작하는 어플리케이션들 중에서 처리량이 높아야하는 요구사항을 지닌 것들은 운영체제의 페이지 캐시를 사용하는 것을 이해할 수 있었다. 이유는 자바 메모리의 특성과 연관이 되어있었다.</p>\n<p>그러면, 왜 스왑은 쓰면 안될까? 이 내용은 사실 GC와 관련이 있다.\n아래와 같은 상황이라 가정해보자.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/MZw7rIs.png\">\n</p>\n<p align=\"center\">\n    <em>그림 8. 자바 힙 내에서 레퍼런스가 끊겼지만 회수는 안된 상황</em>\n</p>\n<ol>\n<li>B, A, C라는 데이터가 할당 된 후에 페이지 캐시에 적재가 되었다.</li>\n<li>B, A, C라는 데이터가 더이상 자바 어플리케이션에서 사용되지 않으나 아직 GC에 의해 수거되기 전이다.</li>\n</ol>\n<p>자 우리는 위에서 스왑-아웃과 스왑-인에 대해서 배웠다. 페이지 캐시에 적재된 페이지가 자주 사용되지 않으면 스왑 영역으로 이동된다는 점 말이다.</p>\n<p>그러면 아래와 같이 예상할 수 있다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/LeJbSEA.png\">\n</p>\n<p align=\"center\">\n    <em>그림 9. 운영체제가 먼저 스왑 아웃을 하여 실제 GC 발생 시 Disk I/O가 발생하는 상황</em>\n</p>\n<p>스왑-아웃을 통해서 스왑 영역으로 이동한 페이지가 실제 JVM이 GC를 트리거하게되면 이 내용을 찾기 위해서 다시 스왑-인을 해야될 것이다.</p>\n<p>즉, <strong>STW가 매우 길게 발생</strong>할 수 있다.이 점이 스왑영역을 JVM 어플리케이션이 최소화시키는 이유라 볼 수 있다.</p>\n<h1 id=\"step-3-결론\" style=\"position:relative;\"><a href=\"#step-3-%EA%B2%B0%EB%A1%A0\" aria-label=\"step 3 결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3. 결론</h1>\n<p>어쩌다보니 긴 글이 되었는데 정리를 하자면 아래와 같다.</p>\n<ol>\n<li>가상 메모리를 통한 Disk I/O는 SSD, NVMe를 사용해도 RAM과 비교해서 여전히 느리다.</li>\n<li>1에 의거해서 운영체제의 페이지 캐시를 스와핑하는 작업은 비용이 상당히 높은 작업이다.</li>\n</ol>\n<p>하지만 그럼에도 처리량이 높아야하는 요구사항을 갖는 자바 어플리케이션은 페이지 캐시를 사용한다. 그 이유는 아래와 같다.</p>\n<ol>\n<li>자바 메모리의 GC 패널티가 매우 크다.</li>\n<li>자바 어플리케이션 재시작 시 데이터 유실 문제 및 웜업 작업등의 추가 작업이 필요하다.</li>\n</ol>\n<p>그럼에도 스와핑은 Disk I/O와 GC를 사용할 적에 문제점이 생길 수 있으니 사용하더라도 최소화해서 쓰는 방식이 선호되고 있다.</p>\n<p>긴 글 읽느라 다들 고생 많으셨습니다.</p>\n<h2 id=\"step-31-추신\" style=\"position:relative;\"><a href=\"#step-31-%EC%B6%94%EC%8B%A0\" aria-label=\"step 31 추신 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.1 추신</h2>\n<p>이 내용을 정리한 계기가 되었던 부분은 아래의 글 때문입니다.</p>\n<ul>\n<li><a href=\"https://blog.mikemccandless.com/2011/04/just-say-no-to-swapping.html\">Just say no to swapping! - Michael McCandless</a></li>\n</ul>\n<p>근데, 해당 글이 작성년도는 2011년으로 확인됩니다. (Java 7 사용 시점쯤에 작성된 글)\n그러나, 결론 부에 제가 그린 그림은 G1GC의 Region과 같이 구성되어있습니다.</p>\n<p>이 부분에 대해서 제가 실제 검증은 하지 않았지만, 현재까지도 위와 같이 발생할 수 있는 문제가 있지않을까? 추론해서 그린 그림입니다. 그러면 해당 추론이 합리적일까요?</p>\n<ol>\n<li><a href=\"https://www.gridgain.com/docs/latest/perf-troubleshooting-guide/memory-tuning#tune-swappiness-setting\">Memory and JVM Tuning - GridGain Doc</a></li>\n</ol>\n<p>위 가이드에서는 아래와 같이 작성되어있습니다.</p>\n<blockquote>\n<p>The value of this setting can prolong GC pauses as well.\nFor instance, if your GC logs show low user time, high system time, long GC pause records, it might be caused by Java heap pages being swapped in and out. To address this, use the swappiness settings above.</p>\n</blockquote>\n<p>따라서, 실제 GC 시간이 스왑-인/아웃으로 느려질 수 있다는 점을 시사한다고 봅니다.</p>\n<ol start=\"2\">\n<li><a href=\"https://www.slideshare.net/HyojeongLee6/paperdesign-of-swapaware-java-virtual-machine-garbage-collector-policy\">Design of Swap-aware Java Virtual Mache Garbage Collector Policy</a></li>\n</ol>\n<p>위 링크는 JVM GC 중에 발생하는 시스템 스왑의 영향도와 그것에 대한 해결법에 대한 논문의 요약 슬라이드입니다.</p>\n<p>논문 자체를 보진 않아서 슬라이드만 참고하면 G1GC는 아니고 Parallel GC(Mark-and-Summary Compaction이 슬라이드 뒷편에 기술되어있어서) 기준인거 같긴합니다. 어찌됐든 GC와 스왑영역에 대해서 확실한 영향도가 있음을 시사하고 있습니다.</p>\n<ol start=\"3\">\n<li><a href=\"https://www.mastertheboss.com/java/tuning-java-applications-on-linux/\">Tuning Java application on Linux</a></li>\n</ol>\n<p>해당 링크에서는 자바 어플리케이션이 현재 스왑을 사용하는지 확인할 수 있는 스크립트를 제공해주고, 병목지점으로 스왑이 식별될 시 대처법을 설명하고 있습니다.</p>\n<p>위 같은 다양한 사례를 보면 G1GC에도 충분히 적용될 사례로 보이는데 시간이 난다면 해당 내용에 대한 검증을 추가해보겠습니다.</p>\n<h1 id=\"step-4-참고자료\" style=\"position:relative;\"><a href=\"#step-4-%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\" aria-label=\"step 4 참고자료 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 4. 참고자료</h1>\n<ol>\n<li><a href=\"https://www.quora.com/If-you-have-a-super-fast-NVMe-M-2-SSD-for-virtual-memory-caching-or-swap-files-do-you-still-need-a-lot-of-physical-RAM\">If you have a super fast NVMe M.2 SSD for virtual memory (caching, or swap files), do you still need a lot of physical RAM?</a></li>\n<li><a href=\"https://askubuntu.com/questions/652337/why-are-swap-partitions-discouraged-on-ssd-drives-are-they-harmful\">Why are swap partitions discouraged on SSD drives, are they harmful?</a></li>\n<li><a href=\"https://kwonnam.pe.kr/wiki/linux/ubuntu/hibernation\">Ubuntu Linux Hibernation</a></li>\n<li><a href=\"https://resilient-923.tistory.com/397\">운영체제(OS) 스와핑(swapping), 가상메모리(virtual memory) 란? - 빠르고 꾸준하게</a></li>\n<li><a href=\"https://brunch.co.kr/@alden/14\">메모리 재할당과 커널 파라미터 - 강진우님</a></li>\n<li><a href=\"https://blog.mikemccandless.com/2011/04/just-say-no-to-swapping.html\">Just say no to swapping! - Michael McCandless</a></li>\n<li><a href=\"https://www.elastic.co/kr/blog/elasticsearch-caching-deep-dive-boosting-query-speed-one-cache-at-a-time\">Elasticsearch 캐싱 심층 분석 : 한 번에 하나의 캐시로 쿼리 속도 향상 - elastic.co</a></li>\n<li><a href=\"https://brunch.co.kr/@alden/32\">dirty page 동기화 #1 - 강진우님</a></li>\n<li><a href=\"https://www.gridgain.com/docs/latest/perf-troubleshooting-guide/memory-tuning#tune-swappiness-setting\">Memory and JVM Tuning - GridGain Doc</a></li>\n<li><a href=\"https://www.slideshare.net/HyojeongLee6/paperdesign-of-swapaware-java-virtual-machine-garbage-collector-policy\">Design of Swap-aware Java Virtual Mache Garbage Collector Policy</a></li>\n<li><a href=\"https://www.mastertheboss.com/java/tuning-java-applications-on-linux/\">Tuning Java application on Linux</a></li>\n</ol>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\"><a href=\"https://en.wikipedia.org/wiki/Device_file#Block_devices\">Block Devices - Wikipedia</a><a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\"><a href=\"https://en.wikipedia.org/wiki/Disk_cache\">Disk cache - Wikipedia</a><a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-3\"><a href=\"https://en.wikipedia.org/wiki/Page_cache\">Page cache - Wikipedia</a><a href=\"#fnref-3\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-4\"><a href=\"https://jojoldu.tistory.com/415\">더티 체킹(Dirty Checking)이란? - 기억보단 기록을</a><a href=\"#fnref-4\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-5\"><a href=\"https://lemp.io/what-is-a-dirty-page-in-operating-system/\">What are dirty pages? - lemp.io</a><a href=\"#fnref-5\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>","frontmatter":{"date":"June 19, 2023","title":"왜 처리량이 중요한 JVM 어플리케이션은 vm.swappiness = 1로 설정하라고 할까?","categories":"개발 인프라","author":"개발한입","emoji":"💻"},"fields":{"slug":"/fundamental-os-page-cache/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://brewagebear.github.io","comments":{"utterances":{"repo":"brewagebear/blog-comments"}}}}},"pageContext":{"slug":"/fundamental-jvm-memory/","nextSlug":"/fundamental-os-page-cache/","prevSlug":""}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}