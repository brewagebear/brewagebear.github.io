{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/linux-kernel-internal-2/",
    "result": {"data":{"cur":{"id":"4df41ab3-4636-55ae-99e1-06ce85d287e2","html":"<h1 id=\"개요\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EC%9A%94\" aria-label=\"개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개요</h1>\n<p>이전 포스팅</p>\n<ol>\n<li><a href=\"https://brewagebear.github.io/linux-kernel-internal-1/\">[Kernel] 리눅스 스케줄링 매커니즘과 Load Average</a></li>\n</ol>\n<p>이전 내용에서는 커널을 이해하기 위한 배경지식과 더불어, <code class=\"language-text\">top</code>에서 나타내는 지표들을 읽는 법 그리고 Load Average가 어떤 부분을 나타내는 지 중점적으로 알아보았다.</p>\n<p>이번 내용에서는 리눅스 내부 메모리 관리에 대해서 중점적으로 다루고자 한다.\n그 전에 앞서 역시 이 부분 또한, 배경지식이 필요하다보니 배경지식에 대해서 다루고, 메모리와 관련된 지표들에 대한 내용을 다뤄보고자 한다.</p>\n<h2 id=\"step-1-서론\" style=\"position:relative;\"><a href=\"#step-1-%EC%84%9C%EB%A1%A0\" aria-label=\"step 1 서론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1. 서론</h2>\n<h2 id=\"step-11-가상-주소-공간\" style=\"position:relative;\"><a href=\"#step-11-%EA%B0%80%EC%83%81-%EC%A3%BC%EC%86%8C-%EA%B3%B5%EA%B0%84\" aria-label=\"step 11 가상 주소 공간 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.1 가상 주소 공간</h2>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/7uArXuJ.png\">\n</p>\n<p align=\"center\">\n    <em>그림 1. 리눅스의 가상 주소 공간 매핑 예시</em>\n</p>\n<p>이전 장에서 이러한 그림을 토대로 가상 주소 공간(Virtual Address Spaces, VAS)<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup> 에 대해서 간략하게 다뤘었다.  메모리 관리에 들어가기 앞서 가상 주소 공간에 대해서 좀 더 알 필요가 존재하여 이에 대해서 다뤄보고자 한다.</p>\n<p>이를 이해하기 위해서는 먼저 중요한 구조체 몇개를 파악할 필요가 있다.</p>\n<h2 id=\"step-12-task_struct와-mm_struct에-대한-이해\" style=\"position:relative;\"><a href=\"#step-12-task_struct%EC%99%80-mm_struct%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%B4%ED%95%B4\" aria-label=\"step 12 task_struct와 mm_struct에 대한 이해 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.2 task_struct와 mm_struct에 대한 이해</h2>\n<p><code class=\"language-text\">task_struct</code>는 이전 포스팅에서 Run Queue를 다루면서 잠깐 설명을 했었던 적이 있다.\n이 <code class=\"language-text\">task_struct</code> 구조체는 리눅스 커널에서 매우 중요한 구조체이므로, 이야기를 하고 넘어가고자 한다.</p>\n<p>먼저, 리눅스에서는 작업의 기본 단위를 태스크(Task)라 부른다. 태스크는 프로세스와 동치되는 개념이라고 생각하면 된다.\n운영체제도 소프트웨어다보니 이 태스크를 나타내거나 처리할 자료구조가 필요할 것이다. 그것이 <code class=\"language-text\">task_struct</code> 이다.</p>\n<p>근데, 여기서만 이야기를 끝내면 안된다. 학부생때 운영체제 과목을 수강했다면 프로세스 제어 블록(Process Control Block, PCB)<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup> 라는 단어를 들었던 기억이 어렴풋이 날 것이다.</p>\n<p>그  PCB도 <code class=\"language-text\">task_struct</code> 라는 구조체로 구현이 된다. 따라서, 기본 작업인 태스크와 PCB도 모두 <code class=\"language-text\">task_struct</code> 라는 구조체로 이뤄진다는 점이다.</p>\n<p>그렇다면 쓰레드의 경우에는 어떨까? 이는 운영체제에 따라 다르다.</p>\n<ul>\n<li>Windows (NT Kernel)</li>\n</ul>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/qrf20s5.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://linux-kernel-labs.github.io/refs/heads/master/lectures/processes.html\">그림 2. Windows 커널의 쓰레드 구조, The Linux Kernel(5.10.14), Processes </a></em>\n</p>\n<p>윈도우즈의 경우를 본다면, 위 그림과 같이 <code class=\"language-text\">Thread list</code>에 각 쓰레드 구조에 대한 포인터가 등록되는 식으로 관리된다고 보면 된다.  그러나, 리눅스의 경우에는 아래 그림과 같다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/qrf20s5.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://i.imgur.com/c9oEUO6.png\">그림 3. Linux 커널의 쓰레드 구조, The Linux Kernel(5.10.14), Processes </a></em>\n</p>\n<p>위 그림은 같은 프로세스 내에 쓰레드가 2개가 있다고 가정한 모습이다. 각 쓰레드 또한 <code class=\"language-text\">task_struct</code>를 활용하여 구현되며 단순히 같은 프로세스 내의 쓰레드라면 동일한 리소스 구조 인스턴스를 가르킬 뿐이다.</p>\n<p>실제 <code class=\"language-text\">task_struct</code> 코드 중에서 중요한 부분만 발췌하면 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// https://github.com/torvalds/linux/blob/master/include/linux/sched.h#L743</span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">task_struct</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">thread_info</span>\t\tthread_info<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span>\t\t\t__state<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">sched_info</span>\t\tsched_info<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">list_head</span>\t\ttasks<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">mm_struct</span>\t\t<span class=\"token operator\">*</span>mm<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">mm_struct</span>\t\t<span class=\"token operator\">*</span>active_mm<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 코드에서 중점적으로 볼 내용은 <code class=\"language-text\">mm_struct</code> 이다.  태스크도 <code class=\"language-text\">task_struct</code> 를 통해서 만들어진다고 하였는데 그렇다면 우리가 기존에 알고 있던 <code class=\"language-text\">stack</code> , <code class=\"language-text\">heap</code> 영역은 어디에 할당되는지 궁금하지 않은가? 그 공간이 바로 <code class=\"language-text\">mm_struct</code> 구조체로 관리된다.</p>\n<p>이 구조체는 가상 주소 공간을 관리하기 위한 여러 정보를 포함하고 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// https://github.com/torvalds/linux/blob/master/include/linux/mm_types.h#L598</span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">mm_struct</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">maple_tree</span> mm_mt<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> start_code<span class=\"token punctuation\">,</span> end_code<span class=\"token punctuation\">,</span> start_data<span class=\"token punctuation\">,</span> end_data<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> start_brk<span class=\"token punctuation\">,</span> brk<span class=\"token punctuation\">,</span> start_stack<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 구조체도 매우 복잡한데 현재 설명할 내용과 관련된 필드는 위에 나온 정도라 보면된다. (<code class=\"language-text\">maple_tree</code>는 후에 설명한다.)</p>\n<ul>\n<li><code class=\"language-text\">start_code / end_code</code> : 프로세스의 코드 영역의 시작과 끝을 나타냄</li>\n<li><code class=\"language-text\">start_data / end_data</code> : 프로세스의 데이터 영역의 시작과 끝을 나타냄</li>\n<li><code class=\"language-text\">start_brk / brk</code> : 프로세스의 힙 영역의 시작과 끝을 나타냄</li>\n<li><code class=\"language-text\">start_stack</code> :  스택 영역의 시작을 나타냄</li>\n</ul>\n<p>이제 아래의 그림을 이해할 수 있을 것이다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/uef6DfS.png\">\n</p>\n<p align=\"center\">\n    <em>그림 4. 리눅스 가상 메모리 영역 시각화</em>\n</p>\n<p>프로세스 내부의 <code class=\"language-text\">mm_struct</code> 를 시각화한 그림이다. 우리가 힙 영역을 늘리고 싶다면, <code class=\"language-text\">brk()</code> 라는 시스템 콜을 통해서 늘리거나 줄일 수 있다.\n<code class=\"language-text\">brk()</code> 시스템콜은 프로그램 브레이크(Program Break)<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup> 를 제어하는 시스템 콜이라고 보면 된다. 위에서 보면 알겠지만 <code class=\"language-text\">brk</code> 라는 값을 통해서 <code class=\"language-text\">heap</code> 크기를 늘리고 줄일 수 있는 것을 볼 수 있다.</p>\n<p>이 <code class=\"language-text\">brk()</code> 시스템 콜을 통해 프로그램 브레이크를 증가시키면, <strong>프로세스에 메모리가 할당</strong>되고 감소하면 <strong>프로세스의 메모리를 해제</strong>할 수 있는 것이다.</p>\n<h2 id=\"step-13-가상-메모리-영역virtual-memory-area-vma\" style=\"position:relative;\"><a href=\"#step-13-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%ADvirtual-memory-area-vma\" aria-label=\"step 13 가상 메모리 영역virtual memory area vma permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.3 가상 메모리 영역(Virtual Memory Area, VMA)</h2>\n<p>위 <code class=\"language-text\">mm_struct</code>필드 중에서 <code class=\"language-text\">maple_tree</code> 의 타입을 갖는 <code class=\"language-text\">mm_mt</code> 라는 값이 존재하였는데 이 부분도 중요하다보니 다루고자 한다.\n이를 이해하기 위해서는 이전 커널 버전을 볼 필요가 존재한다.</p>\n<ul>\n<li>6.1 이전 커널의 <code class=\"language-text\">mm_struct</code></li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">mm_struct</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">vm_area_struct</span> <span class=\"token operator\">*</span>mmap<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* list of VMAs */</span>\n\t\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">rb_root</span> mm_rb<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 레드블랙트리의 루트</span>\n\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre></div>\n<p>이러한 코드로 <code class=\"language-text\">vm_area_struct</code> 를 사용하였다.  그러나 6.5 이후는 위에서 본 코드와 같이 <code class=\"language-text\">*mmap</code> 부분이 <code class=\"language-text\">maple_tree</code>로 변경되었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">mm_struct</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">maple_tree</span> mm_mt<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre></div>\n<p>이에 대한 구체적인 내용은 아래 링크를 참고 바란다.</p>\n<ul>\n<li>참고 커밋 : <a href=\"https://github.com/torvalds/linux/commit/d4af56c5c7c6781ca6ca8075e2cf5bc119ed33d1#diff-dc57f7b72015cf5f95444ec4f8a60f85d773f40b96ac59bf55b281cd63c06142\">mm: start tracking VMAs with maple tree, Github</a></li>\n<li>참고 자료 : <a href=\"https://blogs.oracle.com/linux/post/the-maple-tree-a-modern-data-structure-for-a-complex-problem\">The Maple Tree, A Modern Data Structure for a Complex Problem, Oracle</a></li>\n</ul>\n<p><code class=\"language-text\">vm_area_struct</code>가 기존에는 레드블랙트리(<code class=\"language-text\">rbtree</code>)<sup id=\"fnref-6\"><a href=\"#fn-6\" class=\"footnote-ref\">6</a></sup> 로 추적되었는데  숫자 순서로 노드를 탐색하는 것이 효율적이지 않았고, 기존 락에 대한 문제점이 존재하였다고 한다.\n이에 대해서 새로운 데이터 구조가 필요하였고, 메이플트리(Maple Tree)<sup id=\"fnref-7\"><a href=\"#fn-7\" class=\"footnote-ref\">7</a></sup> 를 제안하였다고 한다.</p>\n<p><code class=\"language-text\">mm_mt</code> 값은 VMA를 순회를 할 때 사용된다고 보면 된다.  중요한 점은 <code class=\"language-text\">vm_area_struct</code> 로 관리되던게  <code class=\"language-text\">maple_tree</code> 로 변경되었다는 점이고, 실제 내부 값은 <code class=\"language-text\">vm_area_struct</code> 를 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// @mas : the maple state</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">vma_mas_store</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">vm_area_struct</span> <span class=\"token operator\">*</span>vma<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">ma_state</span> <span class=\"token operator\">*</span>mas<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이제, <code class=\"language-text\">vm_area_struct</code>에 대해 이해해보자.</p>\n<p>위에서 <code class=\"language-text\">mm_struct</code> 에 대해서 네 가지 구조로 나눌 수 있다고 말했었다.</p>\n<ol>\n<li>스택 영역</li>\n<li>힙 영역</li>\n<li>데이터 영역</li>\n<li>코드 영역</li>\n</ol>\n<p>이 영역들을 통틀어 <strong>가상 메모리 영역(Virtual Memory Area, VMA)</strong> 이라 한다. 즉, <code class=\"language-text\">vm_area_struct</code> 는 가상 메모리 영역에 대한 데이터 구조를 나타낸다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">//https://github.com/torvalds/linux/blob/master/include/linux/mm_types.h#L565</span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">vm_area_struct</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">union</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token comment\">/* VMA covers [vm_start; vm_end) addresses within mm */</span>\n\t\t\t<span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> vm_start<span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> vm_end<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">mm_struct</span> <span class=\"token operator\">*</span>vm_mm<span class=\"token punctuation\">;</span>\n\t<span class=\"token class-name\">pgprot_t</span> vm_page_prot<span class=\"token punctuation\">;</span>          <span class=\"token comment\">/* Access permissions of this VMA. */</span>\n\t\n\t<span class=\"token keyword\">union</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">const</span> <span class=\"token class-name\">vm_flags_t</span> vm_flags<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token class-name\">vm_flags_t</span> __private __vm_flags<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">list_head</span> anon_vma_chain<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* Serialized by mmap_lock &amp;  page_table_lock */</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">anon_vma</span> <span class=\"token operator\">*</span>anon_vma<span class=\"token punctuation\">;</span>\t<span class=\"token comment\">/* Serialized by page_table_lock */</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> vm_pgoff<span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">/* Offset (within vm_file) in PAGE_SIZE units */</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">file</span> <span class=\"token operator\">*</span> vm_file<span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">/* File we map to (can be NULL). */</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\t\n</code></pre></div>\n<p>중요한 필드 몇 가지만 봐보자.</p>\n<ul>\n<li><code class=\"language-text\">vm_start, vm_end</code> : VMA 영역의 시작 주소와 끝 주소를 나타냄 (<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>M</mi><msub><mi>A</mi><mrow><mi>S</mi><mi>I</mi><mi>Z</mi><mi>E</mi></mrow></msub><mo>=</mo><mi>V</mi><msub><mi>M</mi><mrow><mi>E</mi><mi>N</mi><mi>D</mi></mrow></msub><mo>−</mo><mi>V</mi><msub><mi>M</mi><mrow><mi>S</mi><mi>T</mi><mi>A</mi><mi>R</mi><mi>T</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">VMA_{SIZE} = VM_{END} - VM_{START }</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">ZE</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">EN</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">ST</span><span class=\"mord mathnormal mtight\">A</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">RT</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>)</li>\n<li><code class=\"language-text\">*vm_mm</code> : 해당 VMA가 속해있는 <code class=\"language-text\">mm_struct</code>를 나타낸다.</li>\n<li><code class=\"language-text\">vm_page_prot</code> : 해당 VMA에 접근하고자할 경우에 대한 권한 값 (read only, rw 등)</li>\n<li><code class=\"language-text\">vm_flags</code> : <code class=\"language-text\">vm_page_prot</code>의 권한 하위 집합을 지정할 수 있다. (<code class=\"language-text\">VM_READ | VM_WRITE | VM_GROWS_DOWN</code> 등..)\n<ul>\n<li>참고 : <a href=\"https://itecnote.com/tecnote/linux-vm_flags-vs-vm_page_prot/\">Linux – vm_flags vs vm_page_prot, iTecNote</a></li>\n</ul>\n</li>\n</ul>\n<p>이 후 값은 MMIO에 대한 이해가 필요하니 이전 포스팅에서 익명 매핑(Anonymous Mapping)과 파일 매핑(File-backed Mapping)에 대해서 알고 오길 추천드린다.\n위에서 <code class=\"language-text\">anon_vma, anon_vma_chain</code> 은 익명 매핑 시에 사용되고, <code class=\"language-text\">vm_pgoff, vm_file</code>은 파일 매핑 시에 사용이 된다.</p>\n<p>두 가지 구조로 따로 나눈 이유는 역방향 매핑과 관련되어 있는데 이 부분은 페이징때 자세히 다루도록 하고 간단하게 링크만 달아두도록 하겠다.</p>\n<ul>\n<li>\n<p>참고 : <a href=\"https://www.sobyte.net/post/2022-08/linux-anonymous-pages-reverse-mapping/\">Reverse mapping of anonymous pages in Linux, SoByte</a></p>\n</li>\n<li>\n<p><code class=\"language-text\">vm_file</code> : 파일 매핑을 사용할 경우 사용되는 실제 파일에 대한 링크를 갖는 구조체</p>\n</li>\n<li>\n<p><code class=\"language-text\">vm_pageoff</code> : 해당 파일 내의 offset을 나타낸다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">anon_vma</code> : 익명 매핑을 사용할 경우 사용되는 구조체</p>\n</li>\n<li>\n<p><code class=\"language-text\">anon_vma_chain</code> : <code class=\"language-text\">anon_vma</code> 만 사용하였을 경우 문제점을 해결하기 위해 도입된 필드</p>\n<ul>\n<li>익명 역 매핑(Anonymous Page Reverse Mapping) 매커니즘은 페이지 매핑을 해제한 후 매핑될 PTE(Page Table Entry)<sup id=\"fnref-9\"><a href=\"#fn-9\" class=\"footnote-ref\">9</a></sup> 찾기 위해 전체 연결 목록인 <code class=\"language-text\">vma</code>에 액세스한 후 순회하여 연결 목록에 액세스하는데 <code class=\"language-text\">fork()</code>를 통해 복사된 하위 프로세스에서 쓰기 액세스가 발생하면 <code class=\"language-text\">vma</code>에 새 익명 페이지가 할당되고, <code class=\"language-text\">vma</code>는 이 익명 페이지를 가르키게 되는데 이 페이지가 <code class=\"language-text\">vma</code>에 반영되지 않는 문제점이 존재하였음.</li>\n</ul>\n</li>\n</ul>\n<p>이제 <code class=\"language-text\">tast_struct</code> 와 <code class=\"language-text\">mm_struct</code>, <code class=\"language-text\">vm_area_struct</code> 구조체에 대해 중요한 부분을 위주로 다뤄봤는데 리눅스 커널에서 프로세스가 할당되어 사용되는 구조를 각 구조체를 통해서 나타내면 아래와 같다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/sRBzgjS.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://cs4118.github.io/www/2023-1/lect/21-linux-mm.html#struct-vm_area_struct-source-code\">그림 5. Virtual address space with kernel data structures, COMS W4118 Operating Systems 1 - Columbia univ, 2023</a></em>\n</p>\n<p><code class=\"language-text\">vm_next, vm_prev</code> 는 메이플 트리 도입<sup id=\"fnref-9\"><a href=\"#fn-9\" class=\"footnote-ref\">9</a></sup> 이후로 삭제가 되었고, <code class=\"language-text\">mm_struct</code>가 가르키는 것이 <code class=\"language-text\">mmap</code> 이 아니라 <code class=\"language-text\">mm_mt</code>로 변경되긴 해야겠지만 전반적인 큰 틀은 흡사하므로 이해할 수 있을 것이다.\n해당 그림을 이해를 못하겠다면 다시 한번 읽어보는 것을 추천드린다.  위에서 강조한 내용처럼 <strong>지금까지 다룬 구조체들은 커널에서 가장 중요한 구조체들</strong>이다.</p>\n<h2 id=\"step-14-프로세스가-가상-주소-공간에-매핑되는-방식\" style=\"position:relative;\"><a href=\"#step-14-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EA%B0%80-%EA%B0%80%EC%83%81-%EC%A3%BC%EC%86%8C-%EA%B3%B5%EA%B0%84%EC%97%90-%EB%A7%A4%ED%95%91%EB%90%98%EB%8A%94-%EB%B0%A9%EC%8B%9D\" aria-label=\"step 14 프로세스가 가상 주소 공간에 매핑되는 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.4 프로세스가 가상 주소 공간에 매핑되는 방식</h2>\n<p>우리는 위에서 커널에서 중요한 구조 중 하나인 <code class=\"language-text\">task_struct</code> 와 <code class=\"language-text\">mm_struct</code>, <code class=\"language-text\">vm_area_struct</code> 에 대해 알아보았다.\n이제 이 개념이 왜 중요한지 알아보도록 한다. 일단, 이를 위해서는 매핑되는 방식에 대해서 이해 해야한다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/C9mJAyt.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://cs4118.github.io/www/2023-1/lect/21-linux-mm.html#process-virtual-address-space-re-revisited\">그림 6. virtual address space diagram, COMS W4118 Operating Systems 1 - Columbia univ, 2023</a></em>\n</p>\n<p>실제 가상 주소 공간에 매핑되는 구조를 나타낸 그림이다. 매핑 방식은 2가지 방식이 있다.</p>\n<ol>\n<li>간접 매핑(Indirect Mapping) : 가상 주소와 물리 주소 사이의 매핑이 페이지 테이블(Page Table)<sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup> 을 통해서 이뤄지는 구조이다. (OS와 하드웨어가 주소 변환을 수행해야함.)</li>\n<li>직접 매핑(Direct Mapping, Linear Mapping) : 직접 매핑은 가상 주소와 물리 주소 사이에서 선형적(Linear)으로 이뤄진다. 리눅스 커널의 일부는 커널 코드와 데이터, 시스템 테이블 등을 저장하는데 이용되며 모든 프로세스에 대해 공유된다. (선형적으로 매핑되어서 보다 단순함.)</li>\n</ol>\n<blockquote>\n<p>💡 직접 매핑에서 나온 선형적으로 매핑이 이뤄진다는 뜻은 가상 주소가 0x1000이고, 물리 주소 0x2000에 매핑되었다면 선형 매핑을 사용하면 가상 주소 0x1004는 물리 주소 0x2004에 매핑이 된다.</p>\n</blockquote>\n<p>또한, 모든 프로세스는 커널 코드 &#x26; 데이터 영역에 대한 공유를 하기 위해 직접 매핑된 값들이 존재한다.\n그렇다면 왜 이런식으로 나누었을까?</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/3JkVM2I.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://linux-kernel-labs.github.io/refs/heads/master/lectures/address-space.html#linux-address-space\">그림 7. Dedicated, The Linux Kernel(5.10.14), Linux Address Space</a></em>\n</p>\n<p>우리는 알다시피 유저 공간과 커널 공간이 나눠져있다는 점을 알고 있다.  위 그림은 그 공간을 나누는 방식에 대한 방식을 나타낸다.\n(a)는 전용 주소 공간(Dedicated Address Spaces)를 뜻하며, (b)는 공유 주소 공간을 분할(Split a Shared Address Space)하는 것을 보여준다.</p>\n<p>이는 각각 장, 단점이 존재한다.</p>\n<ul>\n<li>전용 커널 공간의 단점(a) : 모든 시스템 호출에 대한 TLB 완전 무효화</li>\n<li>공유 주소 공간의 단점(b) : 커널 및 사용자 프로세스 모두를 위한 주소 공간 자체가 감소</li>\n</ul>\n<p>과거에는 (a)의 형태가 많았지만 주로 (b)와 같이 공유 주소 공간을 분할하는 식으로 사용한다. (특히, 64bit 환경은 항상 공유 주소 공간으로 처리된다 한다.)</p>\n<p>공유 주소 공간을 사용하는 아키텍처라고 가정했을 때, 각 공간은 아래의 특징을 갖는다.</p>\n<ul>\n<li><strong>유저 공간(User Space) : 권한 있는 작업을 수행하거나 하드웨어에 직접 액세스를 할 수 없다.</strong></li>\n<li><strong>커널 공간(Kernel Space) : 권한 있는 작업을 수행할 수 있으며 하드웨어에 대한 전체 액세스 권한이 있다.</strong></li>\n</ul>\n<p>따라서, CPU에서 <strong>어떤 작업을 유저 공간에서 수행 중에 권한이 필요한 작업이 존재하면 커널 공간에 요청을 해야한다</strong>.</p>\n<p>예를 들어, 유저 공간에 <code class=\"language-text\">read()</code> 혹은 <code class=\"language-text\">write()</code> 와 같이 시스템 콜이 발생한다고 가정하면 아래와 같은 플로우로 흘러간다.</p>\n<ol>\n<li>유저 공간에서 데이터로 복사하려면 커널 버퍼의 가상 주소를 사용한다.</li>\n<li>페이지 테이블을 이동하여 커널 버퍼의 가상 주소를 물리적 주소로 변환한다.</li>\n<li>커널 버퍼의 물리적 주소를 사용하여 DMA 전송을 시작한다.</li>\n</ol>\n<p>근데, 만약 커널 공간이 <strong>직접 매핑이 되어있다면 2번에 대한 작업이 축소가 되어서 아래와 같이 처리가 가능</strong>할 것이다.</p>\n<ol>\n<li>가상 주소 공간에서 물리적 주소 공간으로의 변환이 페이지 테이블을 통해서 처리되는 대신 한번에 처리가 가능하다.</li>\n<li>페이지 테이블을 만드는 데 사용되는 메모리가 적어진다.</li>\n<li>커널 메모리에 사용되는 TLB(Translation Look-aside Buffer)<sup id=\"fnref-5\"><a href=\"#fn-5\" class=\"footnote-ref\">5</a></sup> 항목 수 감소</li>\n</ol>\n<p>그래서 실제로 가상 주소 공간은 아래와 같이 분할되어 사용된다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/fxDD1wV.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://cs4118.github.io/www/2023-1/lect/21-linux-mm.html#struct-page-source-code\">그림 9. Users, Kernel Space Diagram, COMS W4118 Operating Systems 1 - Columbia univ, 2023</a></em>\n</p>\n<p>커널 공간은 대부분 직접매핑이 되어 쓰이고(<code class=\"language-text\">Lowmem</code> 부분), 아주 일부분은 간접매핑되어 쓰인다. (<code class=\"language-text\">Highmem</code>)\n이 부분은 <code class=\"language-text\">Slab</code> 을 다룰 때 다뤄볼 예정이다.</p>\n<p>어찌됐든 간에 중요한 점은 유저 공간과 커널 공간이 공유 주소 공간을 사용하여 일정 부분 별로 나눠져있고, 이에 대해 직, 간접 매핑을 활용하여 각자의 장단점을 누릴 수 있게끔 설계되었다는 점이 중요하다.</p>\n<h2 id=\"step-14-페이지와-페이지-캐시\" style=\"position:relative;\"><a href=\"#step-14-%ED%8E%98%EC%9D%B4%EC%A7%80%EC%99%80-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C\" aria-label=\"step 14 페이지와 페이지 캐시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.4 페이지와 페이지 캐시</h2>\n<h3 id=\"step-141-페이지\" style=\"position:relative;\"><a href=\"#step-141-%ED%8E%98%EC%9D%B4%EC%A7%80\" aria-label=\"step 141 페이지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.4.1 페이지</h3>\n<p>나중에 페이징을 별도로 포스팅할 예정인데 그 전에 리눅스 메모리 관리에 이해하려면 어찌됐든 페이지에 대해서 알긴 해야되서 간단하게 코드만 보고자 한다.\n각 물리적 프레임(Physical Frame)<sup id=\"fnref-11\"><a href=\"#fn-11\" class=\"footnote-ref\">11</a></sup>은 <code class=\"language-text\">struct page</code>라 부르는 페이지 값을 가지게 되는데 이 값은 물리적 프레임에 대한 메타데이터를 담고 있다.</p>\n<p>실제로 글로벌 메모리를 설정하는 부분에 전역 배열로 <code class=\"language-text\">struct page</code> 값을 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// https://github.com/torvalds/linux/blob/master/mm/memory.c#L102</span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">page</span> <span class=\"token operator\">*</span>mem_map<span class=\"token punctuation\">;</span></code></pre></div>\n<p>커널은 모든 물리적 프레임을 <code class=\"language-text\">mem_map</code>에 저장한다. 그러나, 이에 직접 접근하는 것은 좋은 방법은 아니기에 다양한 메서드들을 제공(<code class=\"language-text\">virt_to_page(), kmap(), kunmap()</code> 등…)하는데 이는 <code class=\"language-text\">struct page</code>를 살펴보고 알아볼 예정이다.</p>\n<p>이제 <code class=\"language-text\">struct page</code> 에서 중요한 필드들을 확인해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">https<span class=\"token operator\">:</span><span class=\"token comment\">//github.com/torvalds/linux/blob/master/include/linux/mm_types.h#L74C8-L74C12</span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">page</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">union</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\t<span class=\"token comment\">/* Page cache and anonymous pages */</span>\n\t\t\t<span class=\"token comment\">/**\n\t\t\t * @lru: Pageout list, eg. active_list protected by\n\t\t\t * lruvec->lru_lock.  Sometimes used as a generic list\n\t\t\t * by the page owner.\n\t\t\t */</span>\n\t\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t\t\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">list_head</span> lru<span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t\t\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">address_space</span> <span class=\"token operator\">*</span>mapping<span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t\t\t<span class=\"token class-name\">pgoff_t</span> index<span class=\"token punctuation\">;</span>\t\n\t\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token class-name\">atomic_t</span> _refcount<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>virtual<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">_refcount</code> : 페이지의 레퍼런스 카운트를 뜻하며, <code class=\"language-text\">page_count()</code> 로 접근할 수 있다.</li>\n<li><code class=\"language-text\">lru</code> : LRU 캐시 교체(Cache replacement policies) 정책을 수행하는 Linux 데이터 구조의 항목이다.</li>\n<li><code class=\"language-text\">*mapping, index</code> : 위에서 다루었던 익명(Annoymous), 파일(File-backed) 매핑과 관련된 필드이다.</li>\n<li><code class=\"language-text\">*virtual</code> :물리적 프레임에 대응하는 커널 가상 주소</li>\n</ul>\n<p>이제 페이지 매핑과 관련해서 보도록하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">https<span class=\"token operator\">:</span><span class=\"token comment\">//github.com/torvalds/linux/blob/master/arch/arm/include/asm/memory.h#L318-L328</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">inline</span> <span class=\"token class-name\">phys_addr_t</span> <span class=\"token function\">virt_to_phys</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>x<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">inline</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">phys_to_virt</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">phys_addr_t</span> x<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre></div>\n<p>해당 함수는 물리적 주소를 가상 주소로 변환(<code class=\"language-text\">*phys_to_virt</code>)하거나 가상 주소를 물리적 주소로 변환(<code class=\"language-text\">virt_to_phys</code>)로 하는 작업을 해준다.</p>\n<p>이제 아래의 그림을 다시 봐보자.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/fxDD1wV.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://cs4118.github.io/www/2023-1/lect/21-linux-mm.html#struct-page-source-code\">그림 9. Users, Kernel Space Diagram, COMS W4118 Operating Systems 1 - Columbia univ, 2023</a></em>\n</p>\n<p>위 그림은 32bit 4GB 가상 주소 공간을 가정한 것이다. 전통적으로 3:1의 비율(유저공간:커널공간)로 분할되게 된다. (64bit는 달라질 수 있음)</p>\n<p><code class=\"language-text\">Highmem</code> 영역에서 프레임을 사용하기 위해서는 <code class=\"language-text\">struct page</code>를 <code class=\"language-text\">kmap()</code>을 사용해야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">//https://github.com/torvalds/linux/blob/master/include/linux/highmem.h#L37-L46</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">inline</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">kmap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">page</span> <span class=\"token operator\">*</span>page<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">inline</span> <span class=\"token keyword\">void</span> <span class=\"token function\">kunmap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">page</span> <span class=\"token operator\">*</span>page<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이 메서드는 <code class=\"language-text\">Highmem</code> 프레임을 <code class=\"language-text\">Lowmem</code>에 있는 것처럼 참조할 수 있도록 매핑을 생성하며, 이미 사용하고자하는 프레임이 <code class=\"language-text\">Lowmem</code>에 존재한다면 주소를 반환한다.\n이와 같은 <strong>메서드를 통해 프레임이 메모리에서 어디있는지 걱정하지 않고 사용</strong>할 수 있게 된다.\n그러나, 이 매핑에도 제한적인 부분이 존재하므로 <code class=\"language-text\">kunmap()</code> 을 통해서 매핑을 해제해줘야한다.</p>\n<h3 id=\"step-142-페이지-캐시\" style=\"position:relative;\"><a href=\"#step-142-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C\" aria-label=\"step 142 페이지 캐시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.4.2 페이지 캐시</h3>\n<p>위에서 잠깐 페이지에 대해서 다뤘는데 이제 페이지 캐시(Page Cache)<sup id=\"fnref-12\"><a href=\"#fn-12\" class=\"footnote-ref\">12</a></sup> 에 다뤄보고자 한다. 위에서 <code class=\"language-text\">vm_area_struct</code> 를 볼 때 아래와 같은 필드가 존재하였었다.\n<code class=\"language-text\">struct file * vm_file;</code> 여기서 <code class=\"language-text\">struct file</code>은  <code class=\"language-text\">struct inode</code> 의 참조 값이라 보면 된다. 그리고 <code class=\"language-text\">struct inode</code>는 내부에 <code class=\"language-text\">struct address_space *i_mapping</code> 과 같은 값을 갖고 있다.</p>\n<p>이것은 <code class=\"language-text\">inode</code>와 관련된 파일의 모든 프레임에 대한 참조이다. 이 구조는 <strong>파일 매핑만 사용하는 것이 아니라 캐시된 페이지를 보유</strong>할 수 있다.</p>\n<p>운영체제를 공부하셨던 분이라면 읽고 쓰는 작업이 항상 디스크까지 가서 확인하는 것은 아니라는 점을 알고 있을 것이다.\n그것이 가능한 이유는 캐시를 통해서 이미 한번 읽어드렸으면 잠시 메모리 영역에 들고 있게끔해서 디스크까지 내려가지않고 다시 읽게끔한다는 식으로 동작한다는 것을 말이다.</p>\n<p>그것이 <strong>바로 페이지 캐시의 역할</strong>이다. 이를 읽기와 쓰기를 나눠서 플로우를 살펴보자.</p>\n<ul>\n<li>\n<p><strong>읽기 작업 발생 시</strong></p>\n<ol>\n<li><code class=\"language-text\">read()</code> 시스템 콜 발생</li>\n<li>페이지 캐시가 존재한다면 -> 페이지 캐시를 리턴</li>\n<li>페이지 캐시가 존재하지 않는다면 -> 디스크에서 데이터를 읽고, 해당 데이터에 대한 페이지 할당 후에 <code class=\"language-text\">address_space</code>에 연결하여 캐싱</li>\n</ol>\n</li>\n<li>\n<p><strong>쓰기 작업 발생 시</strong></p>\n<ol>\n<li><code class=\"language-text\">write()</code> 시스템 콜 발생</li>\n<li>페이지 캐시가 존재하든 안하든 -> 페이지 캐시에 기록 및 페이지를 dirty로 표시(이것이 더티 페이지이다.)</li>\n<li><code class=\"language-text\">sync()</code> 를 통해서 디스크에 기록</li>\n</ol>\n</li>\n</ul>\n<p>쓰기 작업 부분은 페이지 캐시가 존재하든 안하든 결국 메모리에 캐시를 생성하는데 이를 write-back 캐시라 한다. 요청 시 캐시와 디스크에 동시 기록하는 것을 write-through 캐시라 부른다.\n리눅스는 기본적으로 write-back 캐시의 방식을 따른다고 알고있다.</p>\n<p>쓰기 작업 부분은 다른 포스팅에서도 다뤘는데 자세한 내용은 아래의 링크를 참고바란다.</p>\n<ul>\n<li>참고 : <a href=\"https://brewagebear.github.io/fundamental-os-page-cache/#step-221-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%99%80-%EB%8D%94%ED%8B%B0-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%8F%99%EA%B8%B0%ED%99%94\">https://brewagebear.github.io/fundamental-os-page-cache/#step-221-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%99%80-%EB%8D%94%ED%8B%B0-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%8F%99%EA%B8%B0%ED%99%94</a></li>\n</ul>\n<p>이 뿐만 아니라 하나더 봐야하는 작업이 있다 바로, MMIO 관련 작업이다.</p>\n<ul>\n<li><strong>MMIO 작업과 관련된 페이지 캐시</strong>\n<ol>\n<li>파일 매핑(File-backed Mapping)을 사용하는 경우에 페이지 캐시를 사용한다.\n<ul>\n<li>새로운 VMA가 생성 된 후 파일 내용이 메모리로 전달되려할 때 페이지 폴트가 발생 하고, 페이지 캐시의 페이지는 해당 작업의 페이지 테이블에 인입된다.</li>\n</ul>\n</li>\n<li><code class=\"language-text\">MAP_SHARED</code> 로 페이지를 공유하고 있는 경우에는 페이지 캐시의 동일한 페이지를 대상으로 동작한다.</li>\n</ol>\n</li>\n</ul>\n<p>시각화하면 다음과 같을 것이다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/eDm8R8E.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://cs4118.github.io/www/2023-1/lect/21-linux-mm.html#page-cache-visualized\">그림 10. Page Cache Visualized, COMS W4118 Operating Systems 1 - Columbia univ, 2023</a></em>\n</p>\n<h3 id=\"step-143-페이지-교체-정책\" style=\"position:relative;\"><a href=\"#step-143-%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-%EC%A0%95%EC%B1%85\" aria-label=\"step 143 페이지 교체 정책 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.4.3 페이지 교체 정책</h3>\n<p>페이징에서 정책에 대해서 좀 더 다룰 내용이라 여기서는 LRU 정책<sup id=\"fnref-13\"><a href=\"#fn-13\" class=\"footnote-ref\">13</a></sup>에 대해서만 다루고자 한다.\nLRU(Least Recently Used)의 약어로 잘 안쓰였던 페이지부터 교체하는 방식이다.</p>\n<p>리눅스 페이지는 LRU/2로 알려진 2Q 교체 정책을 사용한다.</p>\n<p>기존 LRU 알고리즘은 아래와 같은 패턴으로 사용할 경우 성능이 나쁘다고 볼 수 있다.</p>\n<blockquote>\n<p>한 프로세스가 큰 파일을 매핑 후 한번 읽은 후 다시 절대로 사용하지 않는다고 가정하자\n만약, 이 파일을 매핑하기 위해서 캐시 전체를 교체를 한 후 이 파일 1개만 있다면 어떻게 될까?\n이러한 일회성 액세스에 대해서 캐시를 보호하는 작업이 필요할 것이다.</p>\n</blockquote>\n<p>그림으로 봐보자.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/eMDgcCM.png\">\n</p>\n<p align=\"center\">\n    <em>그림 11. LRU 성능 최악의 케이스</em>\n</p>\n<p>이런식의 상황이다. 근데 이 파일은 절대로 접근하지 않는다고 가정한다. 그러면 다시 해당 캐시가 방출될 것이다.\n그러면, 기존에 자주 접근할 수도 있는 캐시 자체가 날라가버리니 다시 이 웜업하는데 시간이 많이 걸릴 것이다.</p>\n<p>이러한 문제를 해결 하기위해서 LRU/2라는 개념이 도입된 것이다.\n이 개념은 아주 간단하다. 캐시를 관리하는 리스트를 2개를 두는 것이다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/X0aMm4K.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://biriukov.dev/docs/page-cache/4-page-cache-eviction-and-page-reclaim/#theory\">그림 12. LRU/2, Viacheslav Biriukov</a></em>\n</p>\n<ol>\n<li>비활성 LRU 리스트(Inactive LRU List)\n<ul>\n<li>초기 페이지 부재가 발생한 후 페이지 캐시로 등록하고자하면 비활성 리스트에 인입되게 된다.</li>\n<li>이후 어떤 페이지가 자주 참조가 발생하면 활성 LRU 리스트로 승격(promotion)시킨다.</li>\n</ul>\n</li>\n<li>활성 LRU 리스트(Active LRU List)\n<ul>\n<li>자주 사용하지 않는 페이지가 발생하면 비활성 LRU 리스트로 좌천(demotion)된다.</li>\n<li>이때 좌천이 발생할 경우 <code class=\"language-text\">flush()</code> 가 호출되어 실제 디스크에 기록이 된다.</li>\n</ul>\n</li>\n</ol>\n<p>참고로, 이 구조는 MySQL의 버퍼풀이 그대로 따르고 있으니 참고해보기 바란다.</p>\n<ul>\n<li>참고 : [</li>\n</ul>\n<p>[MySQL] Innodb Buffer Pool 구조 및 캐시 전략\n](<a href=\"https://omty.tistory.com/58\">https://omty.tistory.com/58</a>)</p>\n<h2 id=\"step-2-본론\" style=\"position:relative;\"><a href=\"#step-2-%EB%B3%B8%EB%A1%A0\" aria-label=\"step 2 본론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2. 본론</h2>\n<p>역시나 이전 포스팅과 같이 어떠한 개념을 이해하기 위해서 배경지식이 많이 필요하였다.\n대충 위의 배경지식을 이해하였더라도 이제 본론의 내용에 대해서 충분히 숙지할 수 있는 기본 지식이 갖춰졌다고 생각한다.</p>\n<p>이번에 보려고 하는 내용은 <code class=\"language-text\">free</code> 명령어와 관련된 내용이다. 이 <code class=\"language-text\">free</code> 에 대한 내용을 다루기 위해서 멀리 돌아돌아왔다.\n이제 이 내용에 대해서 다뤄보겠다.</p>\n<h2 id=\"step-21-free-명령어-분석\" style=\"position:relative;\"><a href=\"#step-21-free-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%B6%84%EC%84%9D\" aria-label=\"step 21 free 명령어 분석 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.1 free 명령어 분석</h2>\n<p><code class=\"language-text\">free -m</code> 명령어는 아마도 다들 써본 명령어일 것이다. 명령어를 수행하면 아래와 같은 결과가 나온다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">ubuntu@ubuntu:~$ free -m\n               total        used        free      shared  buff/cache   available\nMem:            3911         129        3571           4         210        3632\nSwap:           3910           0        3910</code></pre></div>\n<p>하나씩 보도록 하자.</p>\n<ul>\n<li><code class=\"language-text\">used</code> : 시스템에서 사용하고 있는 메모리 양을 의미한다.</li>\n<li><code class=\"language-text\">free</code> : 시스템에서 사용하고 있지 않은 메모리 양을 의미한다.</li>\n<li><code class=\"language-text\">shared</code> : 프로세스 사이에 공유하고 있는 메모리 양을 의미한다.</li>\n<li><code class=\"language-text\">buff/cache</code> : 버퍼와 캐시 영역(페이지 캐시)의 총 메모리 양을 의미한다.</li>\n<li><code class=\"language-text\">available</code> : <code class=\"language-text\">buff/cache</code> 영역을 포함하여 사용하지 않는 영역의 메모리 양을 나타낸다. (그러나 단순 더하기는 아닌데 이건 밑에서 다룰 예정이다.)\n<ul>\n<li>원래는 <code class=\"language-text\">-/+ buffers/cache</code> 라는 지표가 Mem 라인 아래에 존재하였는데 <code class=\"language-text\">avaliable</code> 지표로 바뀌었다</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"step-211-buff와-cache-영역\" style=\"position:relative;\"><a href=\"#step-211-buff%EC%99%80-cache-%EC%98%81%EC%97%AD\" aria-label=\"step 211 buff와 cache 영역 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.1.1 buff와 cache 영역</h3>\n<p>페이지 캐시에 대해서 다룬 내용과 같이 매번 디스크 요청을 통해서 디스크를 읽는 행위는 비효율적이므로 페이지 캐시를 사용한다하였다.\n즉, 캐시 영역은 이 페이지 캐시가 할당된 영역이라고 봐도 된다.</p>\n<p>그렇다면 buff는 무엇을 나타낼까? 이 영역은 버퍼 캐시 혹은 버퍼 영역이라고도 부르며, <strong>블록 디바이스가 가지고 있는 블록 자체에 대한 캐시</strong>이다.\n사실 이 개념은 페이지 캐시도 동일하다. 커널 2.2 이전에는 두 영역이 분리되어있었지만 합치게 되면서 대부분 페이지 캐시가 담당하는 역할이 되었다.</p>\n<p>그럼에도 아직까지 버퍼 영역을 사용하는 부분이 있는데 아래의 그림을 잠깐 보자.\n<img src=\"https://i.imgur.com/DnIcuIh.png\" alt=\"\"></p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/DnIcuIh.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"\nhttps://lwn.net/Articles/736534/\">그림 13.The bio layer, LWN.net, 2017</a></em>\n</p>\n<p>보면 bio layer라는 추상화 계층이 껴있는 점을 볼 수 있다. 잠깐 위에서 보았던 페이지 캐시의 시각화 그림을 보자.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/eDm8R8E.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://cs4118.github.io/www/2023-1/lect/21-linux-mm.html#page-cache-visualized\">그림 10. Page Cache Visualized, COMS W4118 Operating Systems 1 - Columbia univ, 2023</a></em>\n</p>\n<p>보면 결국에는 <code class=\"language-text\">struct inode</code> 라는 값으로 관리가 되어지는 점을 볼 수가 있는데 실제 디스크에 쓰이게 될 경우에는 <code class=\"language-text\">struct bio</code> <sup id=\"fnref-14\"><a href=\"#fn-14\" class=\"footnote-ref\">14</a></sup> 라는 구조체로 변환되서 bio layer를 통해서 쓰여지게 된다.</p>\n<p>그런데, super block<sup id=\"fnref-15\"><a href=\"#fn-15\" class=\"footnote-ref\">15</a></sup>이나 inode block<sup id=\"fnref-15\"><a href=\"#fn-15\" class=\"footnote-ref\">15</a></sup> 과 같이 파일 시스템을 관리하기 위한 메타 데이터를 읽어올 경우에는 <code class=\"language-text\">struct bio</code> 를 사용하지 않고, 다이렉트로 디바이스 드라이버와 통신하여 디스크에 데이터를 읽어와서 페이지 캐시에 파일 내용을 채우게 된다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/s4CWITK.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.yes24.com/Product/Goods/44376723\">그림 14. 커널에서 사용하는 Page Cache와 Buffer Cache의 관계도, DevOps와 SE를 위한 리눅스 커널 이야기(강진우 저), 2017</a></em>\n</p>\n<p>즉, 페이지 캐시에서 데이터를 핸들링 하는 구조체는 <code class=\"language-text\">struct inode</code> 로 캐시 영역이나 버퍼 영역이든 동일한 구조체를 사용하지만 디스크 I/O 발생 시에 접근하는 영역에 따라 다른 구조체를 사용하는 것이다.</p>\n<h3 id=\"step-212-avaliable-지표\" style=\"position:relative;\"><a href=\"#step-212-avaliable-%EC%A7%80%ED%91%9C\" aria-label=\"step 212 avaliable 지표 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.1.2 avaliable 지표</h3>\n<p>위에서 캐시 영역과 버퍼 영역에 대해서 알게되었는데 <code class=\"language-text\">avaliable</code> 은 왜 이 두 영역을 제외한 가용 영역을 보여주게 되는 걸까?</p>\n<p><img src=\"https://i.imgur.com/ddqF2a0.png\" alt=\"\"></p>\n<p>이는 스왑관련하여 포스팅했을 때 사용했던 그림이다. 그때도 말했던 것처럼 리눅스 커널 자체는 메모리가 놀고 있는 것을 싫어하므로 다수를 캐시 영역으로 활용한다.\n위의 흐름을 보면 <strong>메모리가 부족할 경우 점점 캐시 영역을 반환하고 실제 메모리 할당을 늘리는 모습</strong>을 볼 수 있다.</p>\n<p>즉, <code class=\"language-text\">avaliable</code> 에서 <code class=\"language-text\">buff/cache</code> 부분을 포함하고, 계산하는 이유는 <strong>어차피 반환될 영역</strong>이기 때문이다.\n다시 <code class=\"language-text\">free</code> 명령어를 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">ubuntu@ubuntu:~$ free -m\n               total        used        free      shared  buff/cache   available\nMem:            3911         129        3571           4         210        3632\nSwap:           3910           0        3910</code></pre></div>\n<p>여기서 보면 단순히 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo>+</mo><mrow><mi>b</mi><mi>u</mi><mi>f</mi><mi>f</mi></mrow><mi mathvariant=\"normal\">/</mi><mrow><mi>c</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>e</mi></mrow><mo mathvariant=\"normal\">≠</mo><mi>a</mi><mi>v</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">free + {buff}/{cache} \\neq avaliable</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">ree</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">ff</span></span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">e</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">iab</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">e</span></span></span></span></span>  임을 볼 수 있는데 <code class=\"language-text\">avaliable</code>은 <code class=\"language-text\">buff/cache</code> 지표 중에서 즉시 반환될 수 있는 영역의 합이라 보면 된다.</p>\n<h2 id=\"step-22-procmeminfo-명령어-분석\" style=\"position:relative;\"><a href=\"#step-22-procmeminfo-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%B6%84%EC%84%9D\" aria-label=\"step 22 procmeminfo 명령어 분석 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.2 /proc/meminfo 명령어 분석</h2>\n<p>위에서는 <code class=\"language-text\">free</code> 에 대해서 다뤄봤었다.<code class=\"language-text\">free</code> 는 명령어 자체가 가용 메모리의 용량을 볼 수 있는 것에 초점이 맞춰져있어서 각 메모리가 시스템의 어느 부분에 사용되는지는 볼 수가 없다.\n이를 확인하기 위해서는 <code class=\"language-text\">/proc/meminfo</code> 명령을 사용하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">ubuntu@ubuntu:~/example$ cat /proc/meminfo\nMemTotal:        4005008 kB\nMemFree:         3651072 kB\nMemAvailable:    3715564 kB\nBuffers:           11096 kB\nCached:           180804 kB\nSwapCached:            0 kB\nActive:           100212 kB\nInactive:         123088 kB\nActive(anon):        568 kB\nInactive(anon):    43260 kB\nActive(file):      99644 kB\nInactive(file):    79828 kB\n...\nSwapTotal:       4004860 kB\nSwapFree:        4004860 kB\nDirty:                 0 kB\n...\nSlab:              59648 kB\nSReclaimable:      24508 kB\nSUnreclaim:        35140 kB\n...</code></pre></div>\n<p>모든 지표는 다루지 않고 중요한 지표만 몇개 다루고자 한다.</p>\n<ul>\n<li><code class=\"language-text\">SwapCached</code> : 스왑-아웃으로 스왑영역에 있다가 다시 스왑-인으로 캐시 영역으로 돌아온 영역</li>\n<li><code class=\"language-text\">Active(anon)</code> : MMIO에 대해서 파일 매핑된 영역이 아니라 익명 매핑된 영역에 대해서 나타내며, 위에서 LRU/2에서 본 활성 리스트라고도 봐도 무방하다. (따라서, 스와핑의 대상이 아님)</li>\n<li><code class=\"language-text\">Inactive(anon)</code> : 이 경우에는 비활성 리스트라고 보면되고, 스와핑이 발생할 수 있다.</li>\n<li><code class=\"language-text\">Active(file)</code> : MMIO 중에 파일 매핑된 케이스를 나타낸다. 위에서 본 <code class=\"language-text\">buff/cache</code> 영역이 여기에 속하며, 활성 리스트에 속한 데이터다. (따라서, 스와핑의 대상이 아님)</li>\n<li><code class=\"language-text\">Inactive(file)</code> : 위와 동일하며 차이는 비활성 리스트에 속해있고, 스와핑이 발생할 수 있다.</li>\n<li><code class=\"language-text\">Dirty</code> : 위에서 페이지 캐시 쓰기 방식을 다룰 때 더티 페이지를 얘기했는데 <code class=\"language-text\">Dirty</code> 메모리는 그 과정에 사용하는 영역이다.</li>\n</ul>\n<p>이전 포스팅에서 <code class=\"language-text\">malloc()</code> 을 통한 예제를 다뤘었는데 <code class=\"language-text\">malloc()</code> 은 또한 익명 매핑을 활용한다고 얘기하였다.</p>\n<blockquote>\n<p>💡 이제는 왜 malloc()이 익명 매핑을 활용하는 것인지 이해가 될 것이다. (이해가 안간다면 다시 서론부터 보고 오자.)\n서론을 보기 싫다면 설명을 해보겠다. 그 이유는 heap 영역 자체가 익명 매핑으로 되어있기 때문이다.\nmalloc()은 힙 영역의 메모리 할당을 늘리는 것이므로, 프로그램 브레이크를 늘리는 식으로 메모리 할당을 할 것이다. 따라서, malloc()은 익명 매핑 기반이다.</p>\n</blockquote>\n<p>이제 실제 <code class=\"language-text\">/proc/meminfo</code> 값을 모니터링 해보자.</p>\n<ul>\n<li>익명 매핑을 활용한 <code class=\"language-text\">mmap</code> 예제 코드</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;sys/mman.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;unistd.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdlib.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>myblock <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\tmyblock <span class=\"token operator\">=</span> <span class=\"token function\">mmap</span><span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1024</span> <span class=\"token operator\">*</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">,</span> PROT_READ <span class=\"token operator\">|</span> PROT_WRITE<span class=\"token punctuation\">,</span> MAP_PRIVATE <span class=\"token operator\">|</span> MAP_ANONYMOUS<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>myblock <span class=\"token operator\">==</span> MAP_FAILED<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t\n\t\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Currently allocating %dMB \\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">++</span>count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>count <span class=\"token operator\">==</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">600</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>책에서는 이전 포스팅에서 다룬 예제 코드(<code class=\"language-text\">malloc</code>)을 활용하지만,  캐시 웜업이 안되서인지 드라마틱하게 <code class=\"language-text\">Active(anon)</code> 이 증가하는 모습을 재현할 수가 없었다.\n따라서, <code class=\"language-text\">mmap()</code> 을 통해 강제로 익명매핑을 수행하는 식으로 짰고, LRU 정책에서 봤듯이 초기에는 비활성 리스트에 들어간 뒤 활성 리스트로 변경되어서 똑같은 코드를 여러번 돌려서 올리는 식으로 진행하였다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">root@ubuntu:~# cat /proc/meminfo | grep  anon\nActive(anon):         88 kB\nInactive(anon):    59268 kB\nroot@ubuntu:~# cat /proc/meminfo | grep  anon\nActive(anon):        104 kB\nInactive(anon):    62788 kB\nroot@ubuntu:~# cat /proc/meminfo | grep  anon\nActive(anon):        116 kB\nInactive(anon):    67092 kB\nroot@ubuntu:~# cat /proc/meminfo | grep  anon\nActive(anon):        124 kB\nInactive(anon):    71356 kB</code></pre></div>\n<p>조금씩 증가하는 모습을 볼 수 있다. 책에서는 (<code class=\"language-text\">x86_64</code>) 아키텍처에서 테스트를 하는 것 같은데 필자는 <code class=\"language-text\">arm64</code> 아키텍처에 돌려서 그런지 드라마틱하게 재현이 안된거같은데 이 부분은 좀 더 확인해봐야할거 같다. 이렇게 활성 &#x3C;-> 비활성 리스트를 관리하는 작업은 <code class=\"language-text\">kswapd</code> 데몬이 관리해준다</p>\n<h2 id=\"step-23-slab-메모리-영역\" style=\"position:relative;\"><a href=\"#step-23-slab-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD\" aria-label=\"step 23 slab 메모리 영역 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.3 slab 메모리 영역</h2>\n<h3 id=\"step-231-vmalloc과-kmalloc\" style=\"position:relative;\"><a href=\"#step-231-vmalloc%EA%B3%BC-kmalloc\" aria-label=\"step 231 vmalloc과 kmalloc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.3.1 vmalloc()과 kmalloc()</h3>\n<p>위에서 <code class=\"language-text\">buff/cache</code> 영역과 <code class=\"language-text\">anon</code> 에 대해서 알아보았다. 또 중요한 메모리 영역이 존재하는데 바로, <strong>커널이 내부적으로 사용하는 영역</strong>이다.</p>\n<p>커널 또한 프로세스의 일종이기 때문에 메모리가 필요하며, 조금 특별한 방법으로 메모리를 할당 받아서 사용한다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/Bh2GsmL.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.pf.is.s.u-tokyo.ac.jp/wp-content/uploads/2018/10/AdvancedOperatingSystems3.pdf\">그림 15. Low-Level Memory Allocatort, Advanced Operating Systems\n#3(Shinpei Kato, The University of Tokyo), 2018</a></em>\n</p>\n<p>위 그림은 커널 내 메모리 관리시스템을 추상화해놓은 그림이다.\n우리는 현재까지 유저 공간 메모리 관리와 관련되어서 이야기를 해왔었다.</p>\n<p><code class=\"language-text\">Slab</code>을 이해하기 위해서는 커널 공간 메모리 관리(그림에서 <strong>Kernel Dynamic Memory Allocation</strong>)에 대해서 이해할 필요가 있다.</p>\n<p>우리가 위에서 살펴본 내용처럼 커널은 메모리를 페이지 단위로 관리하고, 그림에서 보이듯 버디 시스템(Buddy System)<sup id=\"fnref-16\"><a href=\"#fn-16\" class=\"footnote-ref\">16</a></sup> 을 활용하여 물리 메모리 할당/해제 등을 처리한다.</p>\n<p>위에서 언급한 내용처럼 Kernel Dynamic Memory Allocation만 보면 아래와 같이 나눠진다.</p>\n<ul>\n<li>\n<p>Slab Allocator(<code class=\"language-text\">kmalloc()</code>)</p>\n<ul>\n<li>위에서 살펴봤던 내용 중에 <code class=\"language-text\">Lowmem</code> 에 대한 할당과 관련이 되어있다. MMU에 의해서 가상 주소로 변환된 물리적 주소를 리턴한다.</li>\n<li>바로 리턴할 수 있는 이유는 위에서 보았듯 선형 매핑(Linear Mapping)이 된 영역이라 가상 주소 공간 &#x3C;-> 물리 메모리 주소가 1:1 매핑이 되어있고, 연속적이기 때문이다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">vmalloc()</code></p>\n<ul>\n<li><code class=\"language-text\">Highmem</code> 과 연관되어있으며 간접 매핑(Indirect Mapping)으로 이뤄진 영역이다.</li>\n<li>따라서, 불연속적인 공간이 할당이 이뤄지고 <code class=\"language-text\">vmalloc()</code>은 그것을 대응하기 위한 함수이다.</li>\n</ul>\n</li>\n</ul>\n<p>그림을 보면 <code class=\"language-text\">kmalloc()</code> 은 연속적이고, 선형으로 매핑된 공간에 대한 처리를 위한 함수인데 <strong>이것을 Slab Allocator가 사용</strong>한다.</p>\n<p>위에서 잠깐 <code class=\"language-text\">Highmem</code> 내용을 다룰 때, <code class=\"language-text\">kmap()</code>, <code class=\"language-text\">kunmap()</code> 함수를 다뤘었는데 이 둘의 차이는 링크로 대체해본다.</p>\n<ul>\n<li><a href=\"https://kldp.org/node/137435\">영구커널매핑(kmap) 관련 질문</a> (마지막 댓글을 보면 될 것 같다.)</li>\n</ul>\n<h3 id=\"step-232-slab\" style=\"position:relative;\"><a href=\"#step-232-slab\" aria-label=\"step 232 slab permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.3.2 Slab</h3>\n<p>Slab은 무엇이길래 따로 이런식으로 관리를 해주는 것일까?</p>\n<p>커널도 일종의 프로세스이기 때문에 메모리를 관리를 해주어야하는데 버디 시스템에서는 기본적으로 <code class=\"language-text\">4KB</code> 크기로 페이지를 할당해준다.\n하지만 이 크기는 커널 입장에서는 큰 단위이고, 커널 입장에서는 이 정도의 영역이 필요없다.</p>\n<p>이렇게 큰 영역을 할당 받아서 커널이 사용하게 되면 단편화(Fragmentation)<sup id=\"fnref-16\"><a href=\"#fn-16\" class=\"footnote-ref\">16</a></sup> 현상도 발생할 수 있다. 이에 별도로 관리한다.</p>\n<p>**즉, <code class=\"language-text\">Slab</code>은 메모리 영역 중 커널이 직접 사용하는 영역이라고 볼 수 있으며 페이지 단위로 관리되기에는 단편화 문제 등이 발생할 수 있기 때문에 <code class=\"language-text\">Slab</code> 영역으로 따로 관리하는 것이다. **</p>\n<p>이 <code class=\"language-text\">Slab</code> 은 <code class=\"language-text\">cat /proc/meminfo</code> 를 통해서 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">Slab:              59648 kB\nSReclaimable:      24508 kB\nSUnreclaim:        35140 kB</code></pre></div>\n<p>위에서 나타나는 <code class=\"language-text\">Slab</code> 영역이 바로 그 영역이다.</p>\n<ul>\n<li><code class=\"language-text\">Slab</code> : 메모리 영역 중 커널이 직접 사용하는 영역 (<code class=\"language-text\">dentry cache, inode cache</code> 등이 존재)</li>\n<li><code class=\"language-text\">SReclaimable</code> : 영역 중 재사용될 수 있는 영역이다. (Slab 영역에도 캐시가 존재하는데 주로 그러한 캐시들이 여기에 속한다.)</li>\n<li><code class=\"language-text\">SUnreclaim</code> : 영역 중 재사용될 수 없는 영역이다. (커널이 현재 사용중인 영역이며, 해제해서 다른 용도로 사용할 수 없다.)</li>\n</ul>\n<p>해당 영역에 할당 정보를 자세히 보고 싶다면 <code class=\"language-text\">slabtop -o</code> 명령어를 통해서 볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\"> Active / Total Objects (% used)    : 607979 / 698801 (87.0%)\n Active / Total Slabs (% used)      : 22439 / 22439 (100.0%)\n Active / Total Caches (% used)     : 98 / 147 (66.7%)\n Active / Total Size (% used)       : 150031.97K / 161972.25K (92.6%)\n Minimum / Average / Maximum Object : 0.02K / 0.23K / 8.00K\n\n  OBJS ACTIVE  USE OBJ SIZE  SLABS OBJ/SLAB CACHE SIZE NAME\n202020 167860  83%    0.10K   5180       39     20720K buffer_head\n120204 113288  94%    0.19K   5724       21     22896K dentry\n 75310  72998  96%    0.02K    443      170      1772K numa_policy\n 62118  24756  39%    0.04K    609      102      2436K ext4_extent_status\n 52542  50402  95%    1.15K   1946       27     62272K ext4_inode_cache\n 35008  34889  99%    0.06K    547       64      2188K vmap_area\n 33120  32432  97%    0.12K   1035       32      4140K kmalloc-128</code></pre></div>\n<p>여기서 <code class=\"language-text\">kmalloc-128</code> 같은 것이 <code class=\"language-text\">Slab</code> 의 크기를 나타낸다. <code class=\"language-text\">kmalloc-128</code> 이면 <code class=\"language-text\">kmalloc(128)</code> 과 같이 호출하면 최소 페이지인 단위인 <code class=\"language-text\">4KB</code>가 아닌 <code class=\"language-text\">kmalloc-128</code> 캐시를 이용하여 128만큼 할당해준다. 그림으로 보면 아래와 같이 되어있다고 보면 될 것이다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/D8yEJRR.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.yes24.com/Product/Goods/44376723\">그림 16. slab 할당자의 메모리 사용 개념도, DevOps와 SE를 위한 리눅스 커널 이야기(강진우 저), 2017</a></em>\n</p>\n<p>이 중에서 <code class=\"language-text\">dentry cache</code> 와 <code class=\"language-text\">inode cache</code> 는 <code class=\"language-text\">slabtop -o</code> 명령어로 나타난 리스트 중에서 아래의 내용을 나타낸다.</p>\n<ul>\n<li><code class=\"language-text\">dentry</code> : 디렉토리의 계층 관계를 저장해둔다.</li>\n<li><code class=\"language-text\">ext4_inode_cache</code> : 파일의 inode에 대한 정보를 저장해둔다.</li>\n</ul>\n<p>그리고 <code class=\"language-text\">Slab</code> 또한 <code class=\"language-text\">free</code> 명령어 사용 시에 <code class=\"language-text\">used</code> 영역으로 계산된다. (<code class=\"language-text\">buff/cache</code> 가 아니다.)</p>\n<p>따라서, <strong>사용하는 메모리 영역을 모두 더하고도 <code class=\"language-text\">used</code>와 맞지 않을 경우 <code class=\"language-text\">Slab</code> 누수를 의심</strong>할 수 있다.</p>\n<h2 id=\"step-3-결론\" style=\"position:relative;\"><a href=\"#step-3-%EA%B2%B0%EB%A1%A0\" aria-label=\"step 3 결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3. 결론</h2>\n<p>리눅스 커널 메모리 관리에 대해서 많은 것을 공부하였다.</p>\n<ol>\n<li>리눅스 프로세스의 기본 단위인 <code class=\"language-text\">task_struct</code> 의 동작원리 이해</li>\n<li>실제 가상 주소 공간을 통해서 메모리 할당과 관련되어있는 <code class=\"language-text\">mm_struct</code> 에 대한 정보\n<ul>\n<li>이를 토대로 프로세스마다 스택, 힙, 데이터 영역이 어떤 식으로 관리되는지도 보았다. (실질적인 관리는 <code class=\"language-text\">vm_area_struct</code> 로 된다는 것도 말이다.)</li>\n</ul>\n</li>\n<li>실제 <code class=\"language-text\">mm_struct</code> 내에서 관리되는 가상 메모리 영역(VMA)에 대한 데이터 구조체 <code class=\"language-text\">vm_area_struct</code> 의 동작원리 이해\n<ul>\n<li>파일 매핑, 익명 매핑 등과 같이 실제 스택, 힙, 데이터 영역에 대한 관리에 대한 이해</li>\n</ul>\n</li>\n</ol>\n<p>위에는 이제 우리가 기본적인 메모리 관리를 이해하기 위한 필수적인 구조체들을 보았던 내용이다.</p>\n<p>그 이후에는 아래와 같은 것들을 보았다.</p>\n<ol>\n<li>물리 메모리 공간 &#x3C;-> 가상 주소 공간 사이의 실질적인 매핑 매커니즘</li>\n<li>페이지와 페이지 캐시의 개념과 실제 코드를 통한 구조체 내용</li>\n<li>페이지 캐시 관리 정책 등</li>\n</ol>\n<p>이 후 실제, 예제 코드를 통해서 <code class=\"language-text\">free</code> 명령어와 <code class=\"language-text\">cat /proc/meminfo</code> 를 통해서 세부 지표를 확인해보았다.</p>\n<h2 id=\"step-4-추신\" style=\"position:relative;\"><a href=\"#step-4-%EC%B6%94%EC%8B%A0\" aria-label=\"step 4 추신 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 4. 추신</h2>\n<p>책 내용을 처음 보았을 때 혼동하였던 부분은 LRU 캐시 정책을 따를 경우, 활성 리스트에 넣어진다고 혼동하였다.\n이에 혼동되는 부분에 대해서 저자님께 문의를 드렸었는데 아래와 같이 답변이 왔다.</p>\n<p><img src=\"https://i.imgur.com/cxTVKuo.png\" alt=\"\"></p>\n<p>사실 어떻게보면 필자같은 사람의 이메일을 무시할 수 있었을 수도 있다고 본다.\n더군다나 필자는 문의 이메일을 금요일 오후쯤에 보냈었는데 해당 내용에 대해서 내용을 주고 받고, 정리된 회신(위 사진)을 토요일날 주셨다.</p>\n<p>사회초년생인 필자의 혼동되는 부분에 대해서 평화로운 주말에 확인해주셨고, 정성스러운 피드백을 받았다.\n진우님의 자세에 대해서 많은 생각을 하게되었다. <strong>“앞으로 내가 가져야할 자세가 아닐까?”</strong> 라는 생각도 하게 되었다.</p>\n<p>대한민국에는 필자가 존경하는 개발자들이 많다. 유명한 개발자 분들도 존경하는 분들도 있지만 필자보다 나이가 어린 개발자 중에서도 존경하는 사람이 있다.\n필자가 존경하는 사람들의 공통점은 <strong>나이, 경력을 막론하고 어떠한 사람이 궁금한 점을 제시하면 이에 대해서 자신의 지식 내에서 끝내는 것이 아니라 같이 탐색한다는 점</strong>이다.</p>\n<p>얼마전까지 전세계의 뜨거운 감자는 초전도체였다.\n어떻게 보면 가능성과 신뢰도가 낮은 작은 논문이 아카이브에 올라온 후 전세계 과학자들이 열광하였다.</p>\n<p>초전도체는 지금 현재는 소강상태에 접어든 것 같다. 물론, 이게 진짜냐 가짜냐가 아니라 잠시 뜨거웠던 가슴을 가라앉히고 냉정한 이성으로 판단하는 시점으로 페이즈가 옮겨갔다고 생각한다.\n초전도체가 뜨거운 감자였을 때 생각해보면, 전세계 지식인들이 회의적인 반응을 가졌음에도 해당 연구를 하는 연구자분들은 검증을 위한 실험을 하였다.</p>\n<p>진짜인지 아닌지에 대한 검증을 떠나서, 해당 논문이 가능성과 신뢰도가 낮은걸 떠나서 만일 실재한다면 인류는 또다시 도약을 할 수 있기때문에 자신들의 리소스를 사용했다고 생각한다.\n이것이 필자가 존경하는 사람들이 가진 자세라고 생각한다. 사실, Computer Science라는 분야 자체가 타 공학에 비하면 나온지 얼마안됐고 빠르게 변화한다.</p>\n<p>그렇기에 이러한 자세를 유지하는 것이 중요하다고 본다. 나이, 경력을 막론하고 어떠한 지식에 대해서 궁금증을 타인이 물어보면, 적극적으로 같이 연구하여 검증하는 자세 말이다.\n필자도 이러한 자세를 갖기 위해서 부단히 노력을 해야겠다 생각한다.</p>\n<h1 id=\"레퍼런스\" style=\"position:relative;\"><a href=\"#%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4\" aria-label=\"레퍼런스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>레퍼런스</h1>\n<ol>\n<li><a href=\"https://cs4118.github.io/www/2023-1/lect/21-linux-mm.html\">Linux Memory Management,  COMS W4118 Operating Systems 1</a></li>\n<li><a href=\"https://cs4118.github.io/www/2023-1/lect/09-syscalls.html\">System Calls,  COMS W4118 Operating Systems 1</a></li>\n<li><a href=\"https://linux-kernel-labs.github.io/refs/heads/master/lectures/processes.html\">Processes, Linux Kernel Labs</a></li>\n<li><a href=\"https://41d3n.xyz/272\">[ Linux Kernel ] task_struct structure, Aiden</a></li>\n<li><a href=\"https://velog.io/@jinh2352/Linux-5-%EB%A6%AC%EB%88%85%EC%8A%A4%EC%9D%98-%ED%83%9C%EC%8A%A4%ED%81%AC-%EB%AA%A8%EB%8D%B8\">리눅스의 태스크 모델, ‘task_struct’ 자료구조, jinh2352</a></li>\n<li><a href=\"https://brunch.co.kr/@alden/25\">리눅스 페이지 캐시와 버퍼 캐시, 강진우님</a></li>\n<li>[The Maple Tree, A Modern Data Structure for a Complex Problem</li>\n</ol>\n<p>, Oracle Linux Blog](<a href=\"https://blogs.oracle.com/linux/post/the-maple-tree-a-modern-data-structure-for-a-complex-problem\">https://blogs.oracle.com/linux/post/the-maple-tree-a-modern-data-structure-for-a-complex-problem</a>)\n8. <a href=\"https://showx123.tistory.com/92\">리눅스 커널의 mm_struct / vm_area_struct 구조체, BlackStar</a>\n9. <a href=\"https://itecnote.com/tecnote/linux-vm_flags-vs-vm_page_prot/\">Linux – vm_flags vs vm_page_prot, iTecNote</a>\n10. <a href=\"https://www.sobyte.net/post/2022-08/linux-anonymous-pages-reverse-mapping\">Reverse mapping of anonymous pages in Linux, Sobyte</a>\n11. <a href=\"https://hyeyoo.com/95\">[Linux Kernel] 주소와 메모리 공간, Endless Learning</a>\n12. <a href=\"https://docs.kernel.org/admin-guide/device-mapper/cache.html\">Cache, Linux Kernel Admin Guide</a>\n13. <a href=\"https://biriukov.dev/docs/page-cache/4-page-cache-eviction-and-page-reclaim\">Page Cache eviction and page reclaim , Viacheslav Biriukov</a>\n14. <a href=\"https://pangyoalto.com/reduce-slab-memory/\">[Linux] Slab 메모리 줄이기, Pangyoalto</a></p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\"><a href=\"https://en.wikipedia.org/wiki/Virtual_address_space\">Virtual address space, Wikipedia</a><a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\"><a href=\"https://en.wikipedia.org/wiki/Process_control_block\">Process Control Block, Wikipedia</a><a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-3\"><a href=\"https://stackoverflow.com/questions/6338162/what-is-program-break-where-does-it-start-from-0x00\">Program Break, Stackoverflow</a><a href=\"#fnref-3\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-6\"><a href=\"https://en.wikipedia.org/wiki/Red%E2%80%93black_tree\">Red-Black Tree, Wikipedia</a><a href=\"#fnref-6\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-7\"><a href=\"https://docs.kernel.org/core-api/maple_tree.html\">Maple Tree, Kernel Core API</a><a href=\"#fnref-7\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-9\"><a href=\"https://www.kernel.org/doc/gorman/html/understand/understand006.html\">Page Table Management</a><a href=\"#fnref-9\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-4\"><a href=\"https://en.wikipedia.org/wiki/Page_table\">Page Table, Wikipedia</a><a href=\"#fnref-4\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-5\"><a href=\"https://en.wikipedia.org/wiki/Translation_lookaside_buffer\">Traslation Lookaside Buffer(TLB), Wikipedia</a><a href=\"#fnref-5\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-11\"><a href=\"https://en.wikipedia.org/wiki/Page_(computer_memory)\">Page, Wikipedia</a><a href=\"#fnref-11\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-12\"><a href=\"https://en.wikipedia.org/wiki/Page_cache\">Page Cache, Wikipedia</a><a href=\"#fnref-12\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-13\"><a href=\"https://en.wikipedia.org/wiki/Cache_replacement_policies\">Cache Replacement Policies</a><a href=\"#fnref-13\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-14\"><a href=\"https://github.com/torvalds/linux/blob/master/include/linux/blk_types.h#L264\">struct bio, Github</a><a href=\"#fnref-14\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-15\"><a href=\"https://en.wikipedia.org/wiki/Unix_File_System#Design\">Unix File System</a><a href=\"#fnref-15\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-16\"><a href=\"https://en.wikipedia.org/wiki/Fragmentation_(computing)\">Fregmentation</a><a href=\"#fnref-16\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>","excerpt":"개요 이전 포스팅 [Kernel] 리눅스 스케줄링 매커니즘과 Load Average 이전 내용에서는 커널을 이해하기 위한 배경지식과 더불어, 에서 나타내는 지표들을 읽는 법 그리고 Load Average가 어떤 부분을 나타내는 지 중점적으로 알아보았다. 이번 내용에서는 리눅스 내부 메모리 관리에 대해서 중점적으로 다루고자 한다.\n그 전에 앞서 역시 이 부분 또한, 배경지식이 필요하다보니 배경지식에 대해서 다루고, 메모리와 관련된 지표들에 대한 내용을 다뤄보고자 한다. STEP 1. 서론 STEP 1.1 가상 주소 공간 이전 장에서 이러한 그림을 토대로 가상 주소 공간(Virtual Address Spaces, VAS) 에 대해서 간략하게 다뤘었다.  메모리 관리에 들어가기 앞서 가상 주소 공간에 대해서 좀 더 알 필요가 존재하여 이에 대해서 다뤄보고자 한다. 이를 이해하기 위해서는 먼저 중요한 구조체 몇개를 파악할 필요가 있다. STEP 1.2 task_struct와 mm_stru…","frontmatter":{"date":"September 04, 2023","title":"[Kernel] 리눅스 메모리 관리 훑어보기","categories":"개발 인프라 독서요약","author":"개발한입","emoji":"💻"},"fields":{"slug":"/linux-kernel-internal-2/"}},"next":{"id":"addafc2f-d783-5e3c-9397-e7d16b087547","html":"<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#step-1-%EC%84%9C%EB%A1%A0\">STEP 1. 서론</a></p>\n<ul>\n<li>\n<p><a href=\"#step-11-%EB%B3%91%EB%A0%AC%EC%84%B1%EA%B3%BC-%EB%8F%99%EC%8B%9C%EC%84%B1\">STEP 1.1 병렬성과 동시성</a></p>\n</li>\n<li>\n<p><a href=\"#step-12-run-queue%EC%99%80-wait-queue\">STEP 1.2 Run Queue와 Wait Queue</a></p>\n<ul>\n<li><a href=\"#step-121-run-queue\">STEP 1.2.1 Run Queue</a></li>\n<li><a href=\"#step-122-wait-queue\">STEP 1.2.2 Wait Queue</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-13-%EB%A6%AC%EB%88%85%EC%8A%A4-%EB%82%B4%EC%97%90%EC%84%9C-%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9D%B8-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\">STEP 1.3 리눅스 내에서 기본적인 스케줄링</a></p>\n<ul>\n<li><a href=\"#step-131-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%83%81%ED%83%9C-%EB%B3%80%ED%99%94\">STEP 1.3.1 프로세스 상태 변화</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-14-%EA%B0%80%EC%83%81-%EC%A3%BC%EC%86%8C-%EA%B3%B5%EA%B0%84\">STEP 1.4 가상 주소 공간</a></p>\n</li>\n<li>\n<p><a href=\"#step-15-mmiomemory-mapped-io\">STEP 1.5 MMIO(Memory Mapped I/O)</a></p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-2-%EB%B3%B8%EB%A1%A0\">STEP 2. 본론</a></p>\n<ul>\n<li>\n<p><a href=\"#step-21-virt--res--shr\">STEP 2.1 VIRT &#x26; RES &#x26; SHR</a></p>\n</li>\n<li>\n<p><a href=\"#step-22-memory-commit\">STEP 2.2 Memory Commit</a></p>\n</li>\n<li>\n<p><a href=\"#step-23-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%81%ED%83%9C\">STEP 2.3 프로세스의 상태</a></p>\n</li>\n<li>\n<p><a href=\"#24-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84\">2.4 프로세스의 우선순위</a></p>\n</li>\n<li>\n<p><a href=\"#step-3-load-averrage%EC%99%80-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%B6%80%ED%95%98\">STEP 3. Load Averrage와 시스템 부하</a></p>\n<ul>\n<li><a href=\"#step-31-cpu-bound-vs-io-bound\">STEP 3.1 CPU Bound vs I/O Bound</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n<h1 id=\"개요\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EC%9A%94\" aria-label=\"개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개요</h1>\n<p>최근에 커널 책을 같이 읽고 정리하는 스터디를 시작하였다. 이를 다루기 앞서, 난이도가 조금 있다보니 배경지식이 조금 필요한 것으로 보인다.\n이에 따라, 중요한 개념 몇가지만 짚고 이와 연관된 내용으로 같이 얘기를 해보고자 한다.</p>\n<h2 id=\"step-1-서론\" style=\"position:relative;\"><a href=\"#step-1-%EC%84%9C%EB%A1%A0\" aria-label=\"step 1 서론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1. 서론</h2>\n<h3 id=\"step-11-병렬성과-동시성\" style=\"position:relative;\"><a href=\"#step-11-%EB%B3%91%EB%A0%AC%EC%84%B1%EA%B3%BC-%EB%8F%99%EC%8B%9C%EC%84%B1\" aria-label=\"step 11 병렬성과 동시성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.1 병렬성과 동시성</h3>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/KW1ffSd.png\">\n</p>\n<p align=\"center\">\n    <em>그림 1. 병렬성과 동시성</em>\n</p>\n<ol>\n<li>병렬성(Parallelism)\n<ul>\n<li>물리적 쓰레드에 연관이 있으며, 코어 당 만약 1개의 쓰레드를 가지게 되면 4개의 물리적 쓰레드를 갖게 된다.</li>\n<li>이 물리적 쓰레드는 실제로 분리된 코어 상에서 동작하므로 동시에 수행될 수 있다.</li>\n</ul>\n</li>\n</ol>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/vyDaj7R.png\">\n</p>\n<p align=\"center\">\n    <em>그림 2. 병렬성(Parallelism)</em>\n</p>\n<p>위와 같이 태스크들이 4개로 병렬 수행을 한다해도 문제 없이 동작을 할 수 있다. 이것이 병렬성이다.</p>\n<ol start=\"2\">\n<li>동시성(Concurrency)\n<ul>\n<li>프로세스 혹은 프로그램 상에서 생성한 논리적 쓰레드에 연관이 있다.</li>\n<li>실제로 동시 수행은 일어나지 않으나 시분할적으로 매우 빠르게 문맥교환이 일어나서 하나의 흐름처럼 동시에 보이는 것이다.</li>\n</ul>\n</li>\n</ol>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/YuGifc5.png\">\n</p>\n<p align=\"center\">\n    <em>그림 3. 동시성(Concurrency)</em>\n</p>\n<p>위의 그림에서 Process에 2개의 논리적 쓰레드가 있었는데 해당 쓰레드 2개가 어떠한 작업(<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mn>1</mn><mo separator=\"true\">,</mo><mi>T</mi><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">T1, T2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord\">2</span></span></span></span></span>)를 처리하는 상황을 그려본 것이다.</p>\n<p>그렇다면, 이 병렬성과 동시성의 개념이 왜 중요할까?</p>\n<p>밑에서 Run Queue와 Wait Queue를 다루면서 컨텍스트 스위칭에 대한 내용을 다룰 것인데 이 개념을 이해하기 위해서 중요하다고 보면 된다.</p>\n<h3 id=\"step-12-run-queue와-wait-queue\" style=\"position:relative;\"><a href=\"#step-12-run-queue%EC%99%80-wait-queue\" aria-label=\"step 12 run queue와 wait queue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.2 Run Queue와 Wait Queue</h3>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">/* Used in tsk->state: */</span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">TASK_RUNNING</span>\t\t\t<span class=\"token expression\"><span class=\"token number\">0x00000000</span></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">TASK_INTERRUPTIBLE</span>\t\t<span class=\"token expression\"><span class=\"token number\">0x00000001</span></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">TASK_UNINTERRUPTIBLE</span>\t\t<span class=\"token expression\"><span class=\"token number\">0x00000002</span></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">__TASK_STOPPED</span>\t\t\t<span class=\"token expression\"><span class=\"token number\">0x00000004</span></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">__TASK_TRACED</span>\t\t\t<span class=\"token expression\"><span class=\"token number\">0x00000008</span></span></span></code></pre></div>\n<ul>\n<li>참고 : <a href=\"https://github.com/torvalds/linux/blob/master/include/linux/sched.h#L86\">linux/sched.h</a></li>\n</ul>\n<p>위는 리눅스에서 작업(Task)의 상태를 나타내는 식별자이다.</p>\n<table>\n<thead>\n<tr>\n<th>상태</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">TASK_RUNNING</code></td>\n<td>작업 실행 가능 상태를 나타내며, 현재 실행 중이거나 실행 대기열(<code class=\"language-text\">Run Queue</code>)에서 대기중</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">TASK_INTERRUPTIBLE</code></td>\n<td>작업이 어떤 상황이 발생하는 동안 잠을 자는 상황, 신호가 수신되면 일찍 잠에서 깨울 수 있다.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">TASK_UNINTERRUPTIBLE</code></td>\n<td>작업이 어떤 상황이 발생하는 동안 잠을 자는 상황, 조기에 깨울 수 없다.</td>\n</tr>\n</tbody>\n</table>\n<p>이 큰 맥락말고도 실제 동작 유무에 따라서 아래와 같이 상태를 나타낼 수 있다.</p>\n<ol>\n<li><code class=\"language-text\">running</code> : <code class=\"language-text\">TASK_RUNNING</code> 상태이며, 현재 동작중인 작업</li>\n<li><code class=\"language-text\">runnable</code> : <code class=\"language-text\">TASK_RUNNING</code> 상태이며, <code class=\"language-text\">Run Queue</code>에 인입되어 실행되기를 기다리는 작업</li>\n<li><code class=\"language-text\">blocked</code> : <code class=\"language-text\">TASK_INTERRUPTIBLE</code> 혹은 <code class=\"language-text\">TASK_UNINTERRUPTIBLE</code> 인 작업 상태</li>\n</ol>\n<p>이제 실제 <code class=\"language-text\">Run Queue</code>의 구조를 보자.</p>\n<h4 id=\"step-121-run-queue\" style=\"position:relative;\"><a href=\"#step-121-run-queue\" aria-label=\"step 121 run queue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.2.1 Run Queue</h4>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/qW8dVbK.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://cs4118.github.io/www/2023-1/lect/10-run-wait-queues.html\">그림 4. Run Queue, COMS W4118 Operating Systems 1 - Columbia univ, 2023</a></em>\n</p>\n<p>위와 같은 <code class=\"language-text\">task_struct</code>의  <code class=\"language-text\">list_head</code> 포인터를 통해서 자식/형제 계층들이 연결이 된다.\n<code class=\"language-text\">run queue</code>는 상태가 <code class=\"language-text\">TASK_RUNNING</code>인 <code class=\"language-text\">list_head</code> 들과 연결이 된다. 따라서, <code class=\"language-text\">run queue</code> 용으로 <code class=\"language-text\">task_struct</code>에는 별도로 <code class=\"language-text\">list_head</code>가 있어야한다.</p>\n<p><code class=\"language-text\">run queue</code>는 코어당 존재를 하며, 4코어일 경우에는 각 코어마다 1개씩 존재하여 4개의 <code class=\"language-text\">run queue</code>가 존재하게 된다.</p>\n<p>그러나 주의할 점은 아래의 내용이다.</p>\n<ul>\n<li><code class=\"language-text\">run queue</code> 에 위치하는 부모/자식 작업은 동일한 CPU에서 실행되지 않을 수 있다.\n<ul>\n<li>Core1에 위치하던 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">T1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord\">1</span></span></span></span></span>이 Core2에서도 수행가능 (OS 스케줄러에 의한 로드밸런싱에 의거)</li>\n<li>그러나, CPU 선호도(CPU Affinity)나 캐시 워밍업때문에 같은 작업이 같은 코어에서 작업되는 것이 선호된다.</li>\n</ul>\n</li>\n<li><code class=\"language-text\">run queue</code>에 위치하는 부모/자식 작업은 모두 실행 중일 필요는 없다.</li>\n</ul>\n<p>이것이 어떻게 보면 병렬성이 보장되는 이유기도 하다. (각 코어마다 <code class=\"language-text\">run queue</code>가 존재하기에 이상적으로 4개의 작업이 4개의 코어의 <code class=\"language-text\">run queue</code>가 비워져있다면, 동시수행 가능)</p>\n<h4 id=\"step-122-wait-queue\" style=\"position:relative;\"><a href=\"#step-122-wait-queue\" aria-label=\"step 122 wait queue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.2.2 Wait Queue</h4>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/VZzy5ob.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://cs4118.github.io/www/2023-1/lect/10-run-wait-queues.html\">그림 5. Wait Queue, COMS W4118 Operating Systems 1 - Columbia univ, 2023</a></em>\n</p>\n<p><code class=\"language-text\">Wait Queue</code>는 <code class=\"language-text\">Run Queue</code>와 <code class=\"language-text\">TASK_INTERRUPTIBLE</code> 혹은 <code class=\"language-text\">TASK_UNINTERRUPTIBLE</code> 상태를 가진 작업과 연결이 된다.</p>\n<p>이 과정에 대한 이벤트 루프 방식은 아래와 같다.</p>\n<ol>\n<li><code class=\"language-text\">prepare_to_wait()</code> : <code class=\"language-text\">TASK_INTERRUPTIBLE</code>로 변경 후 <code class=\"language-text\">Wait Queue</code>에 작업을 인입시킨다.</li>\n<li><code class=\"language-text\">signal_pending(state)</code> : 작업에 시그널이 전달됐으면 <code class=\"language-text\">true</code> 아니면 <code class=\"language-text\">false</code> 를 리턴시킨다.\n<ul>\n<li>잠들기 전에 시그널을 받았으면 잠드는 대신에 루프를 탈출한다.</li>\n</ul>\n</li>\n<li><code class=\"language-text\">schedule()</code> : 실제로 잠들기를 수행한다.</li>\n<li><code class=\"language-text\">finish_wait()</code> : <code class=\"language-text\">TASK_RUNNING</code> 상태로 변경한 후에 해당 작업을 <code class=\"language-text\">Wait Queue</code>에서 제거한다.</li>\n</ol>\n<p>이러한 이벤트 루프가 존재하며, 1-4를 계속 반복한다고 보면 된다.</p>\n<h3 id=\"step-13-리눅스-내에서-기본적인-스케줄링\" style=\"position:relative;\"><a href=\"#step-13-%EB%A6%AC%EB%88%85%EC%8A%A4-%EB%82%B4%EC%97%90%EC%84%9C-%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9D%B8-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\" aria-label=\"step 13 리눅스 내에서 기본적인 스케줄링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.3 리눅스 내에서 기본적인 스케줄링</h3>\n<p>먼저, <a href=\"https://github.com/torvalds/linux/blob/master/kernel/sched/core.c#L6591-L6718\">linux/kernel/sched/core.c</a> 쪽을 보면 <code class=\"language-text\">schedule()</code> 이라는 함수가 있음을 확인할 수 있다.</p>\n<p>이 함수 내부적으로는 아래의 함수들도 사용된다.</p>\n<ol>\n<li><code class=\"language-text\">pick_next_task()</code> : run queue에서 꺼내서 실행시킬 새 작업을 선택하는 함수</li>\n<li><code class=\"language-text\">context_switch()</code> : 현재 작업을 휴면상태로 변경 후 위 함수에서 가져온 작업을 실행 시키는 함수</li>\n</ol>\n<p>이를 토대로, Wait Queue에 대한 스케줄링은 아래와 같이 나눠진다.</p>\n<ul>\n<li>\n<p>휴면상태 돌입</p>\n<ol>\n<li><a href=\"https://github.com/torvalds/linux/blob/master/include/linux/wait.h#L300-L322\">wait_event()</a>함수 호출</li>\n<li><a href=\"https://github.com/torvalds/linux/blob/master/kernel/sched/wait.c#L305-L339\">Wait Queue에 작업을 적재</a></li>\n<li><a href=\"https://github.com/torvalds/linux/blob/master/kernel/sched/core.c#L6591-L6718\">schedule()</a> 함수 호출</li>\n<li>Run Queue에 해당 작업 제거</li>\n<li><a href=\"https://github.com/torvalds/linux/blob/master/kernel/sched/core.c#L6674C9-L6674C23\">pick_next_task()</a> 함수 호출</li>\n<li><a href=\"https://github.com/torvalds/linux/blob/master/kernel/sched/core.c#L6710C8-L6710C22\">context_switch()</a> 함수 호출</li>\n<li>다른 작업 수행</li>\n</ol>\n</li>\n<li>\n<p>휴면상태를 깨우기</p>\n<ol>\n<li><a href=\"https://github.com/torvalds/linux/blob/master/kernel/sched/wait.c#L80-L121\">wake_up()</a>함수 호출</li>\n<li>각 작업마다 <a href=\"https://github.com/torvalds/linux/blob/master/kernel/sched/core.c#L4197-L4354\">try_to_wake_up()</a> 함수 호출</li>\n<li>각 작업을 Run Queue에 적재</li>\n<li><code class=\"language-text\">schedule()</code> 함수를 호출하고 이전에 잠들었던 태스크가 선택된다.\n<ul>\n<li>조건이 <code class=\"language-text\">false</code>면 : 계속 휴면상태에 있음</li>\n<li>조건이 <code class=\"language-text\">true</code>면 : 휴면상태를 끝내고, <a href=\"https://github.com/torvalds/linux/blob/master/include/linux/wait.h#L320C2-L320C13\">finish_wait()</a> 함수를 호출하여 Wait Queue에 작업을 제거</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"step-131-프로세스-상태-변화\" style=\"position:relative;\"><a href=\"#step-131-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%83%81%ED%83%9C-%EB%B3%80%ED%99%94\" aria-label=\"step 131 프로세스 상태 변화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.3.1 프로세스 상태 변화</h4>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/8492Pvm.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://cs4118.github.io/www/2023-1/lect/10-run-wait-queues.html\">그림 6. Process State Transitions, COMS W4118 Operating Systems 1 - Columbia univ, 2023</a></em>\n</p>\n<p>위 상태에서 <code class=\"language-text\">read()</code>라는 시스템콜이 유저모드에서 발생할 시 아래와 같이 처리가 된다.</p>\n<ol>\n<li>커널에 트랩이 발생\n<ul>\n<li>각 프로세스에 대한 레지스터를 커널 스택에 저장</li>\n</ul>\n</li>\n<li>디바이스 드라이버(DMA와 같은)가 I/O Request(IRQ)를 디바이스에 발행</li>\n<li>호출되는 프로세스를 휴면상태로 변화\n<ul>\n<li><code class=\"language-text\">wait_event()</code> -> <code class=\"language-text\">schedule()</code> -> <code class=\"language-text\">pick_next_task()</code> -> <code class=\"language-text\">context_switch()</code></li>\n</ul>\n</li>\n<li>다른 프로세스를 수행(문맥교환이 발생하였기 때문에)</li>\n<li>디바이스에서 IRQ를 성공적으로 처리하였으면, 하드웨어 인터럽트 발생</li>\n<li>커널에 트랩을 발생시킨 후, 인터럽트 핸들러로 PC를 이동\n<ul>\n<li><code class=\"language-text\">wake_up()</code> : 현재 블록킹 중인 작업을 Run Queue로 적재</li>\n<li>현재 태스크는 결과적으로 <code class=\"language-text\">schedule()</code> -> <code class=\"language-text\">pick_next_task()</code> -> <code class=\"language-text\">context_switch()</code>의 과정을 호출함.</li>\n</ul>\n</li>\n<li>다른 프로세스를 수행\n<ul>\n<li>여기서, 휴면상태에서 다시 동작하게끔 변경이 되었다면 이 프로세스는 <code class=\"language-text\">read()</code> 함수를 호출한 프로세스일 수도 있으며 아닐 경우 다른 프로세스일 수 있다.</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"step-14-가상-주소-공간\" style=\"position:relative;\"><a href=\"#step-14-%EA%B0%80%EC%83%81-%EC%A3%BC%EC%86%8C-%EA%B3%B5%EA%B0%84\" aria-label=\"step 14 가상 주소 공간 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.4 가상 주소 공간</h3>\n<p>C나 CPP같은 언어를 써서 <code class=\"language-text\">malloc()</code> 같은 시스템 메모리(Physical Memory)를 요구하는 함수를 호출한다 가정했을 때, 우리는 뭔가 <code class=\"language-text\">malloc()</code>을 호출하면 당연하게도 어떠한 시스템 메모리에 영역을 할당받는다고 생각했을 것이다.</p>\n<p>하지만, 리눅스에서도 가상 메모리라는 개념을 활용한다. 이는 SWAP 영역과는 별개의 가상 메모리라고 보면 될 것같다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/7uArXuJ.png\">\n</p>\n<p align=\"center\">\n    <em>그림 7. 리눅스의 가상 주소 공간 매핑 예시</em>\n</p>\n<blockquote>\n<p>위에서는 <code class=\"language-text\">malloc()</code> 호출 시 시스템 콜이 발생되는 가정으로 하였는데 실제로는 발생안하는 케이스도 있으니 참고하기 바란다.</p>\n</blockquote>\n<p>실제로는 위와 같이 바인딩이 된다고 보면된다. 실제로 어플리케이션을 사용할 때는 물리적 메모리에 대해서 가상공간으로 변환해서 사용하는데, 이 가상공간으로 변환되어서 사용되는 물리적 메모리 공간을 가상메모리라고 뜻한다고 보면된다. (이 작업은 MMU에서 처리해준다.)</p>\n<p>참고로, MMU나 가상 메모리를 사용하지 않는 시스템의 경우도 있다.</p>\n<h3 id=\"step-15-mmiomemory-mapped-io\" style=\"position:relative;\"><a href=\"#step-15-mmiomemory-mapped-io\" aria-label=\"step 15 mmiomemory mapped io permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.5 MMIO(Memory Mapped I/O)</h3>\n<p>MMIO는 위 가상메모리와 비슷하게, I/O 작업을 좀 더 빠르게 처리하기 위해서 사용하는 방식이다.</p>\n<p><code class=\"language-text\">malloc()</code> 이 아닌 <code class=\"language-text\">read()</code> 와 같은 시스템 콜을 활용하여 File I/O 처리가 필요하다고 가정해보자.\n그렇다면, <code class=\"language-text\">lseek()</code> 과 같은 시스템 콜을 통해서 파일을 접근 한후 실제 <code class=\"language-text\">read()</code>를 통해서 내용을 커널에서 유저 모드의 버퍼로 전달해야될 것이다.</p>\n<p>이런 과정은 어떻게 보면 느리며, 복잡할 수 있다. 이에 대한 대안은 파일의 영역을 가상 주소 공간에 매핑시키는 것이다. 아래와 같이 말이다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/AfVhSnr.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://cs4118.github.io/www/2023-1/lect/09-syscalls.html\">그림 8. File-backed mappings, COMS W4118 Operating Systems 1 - Columbia univ, 2023</a></em>\n</p>\n<p>매핑된 영역은 디스크에 의해 지원이 되는데 메모리 매핑된 영역에 대한 업데이트는 먼저 메모리로 가고, 후에 디스크로 플러시 된다고 보면된다.</p>\n<p>또한 이 매핑 영역은 두 가지 방식이 존재한다.</p>\n<ol>\n<li>Private Mapping : 파일의 스냅샷을 제공 받지만 변경 사항은 디스크로 플러시가 되지 않으며, 동일한 영역을 매핑하는 다른 프로세스에게는 보이지 않는다.</li>\n<li>Shared Mapping : 같은 메모리를 참조하며, 이런식으로 매핑된 데이터를 가진 프로세스는 서로의 업데이트를 확인할 수 있다.</li>\n</ol>\n<p>실제 동작원리는 잘 쓰여진 포스팅이 있어서 이로 대체한다.</p>\n<ul>\n<li>참고 : <a href=\"https://pr0gr4m.tistory.com/entry/Linux-Kernel-5-mmap\">Linux Kernel 5 mmap(매모리매핑) - Art of Pr0gr4m</a></li>\n</ul>\n<p>위에서는 File에 대한 매핑에 대한 예시라면, 때때로 파일에 의해 백업되지 않은 메모리를 매핑할 수도 있으면 좋겠다라는 요구사항이 발생할 수 있다.(<code class=\"language-text\">malloc()</code> 과 같은)</p>\n<p>이럴 때 사용하는 것이 익명 메모리 매핑이라고 보면된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">LEGACY_MAP_MASK</span> <span class=\"token expression\"><span class=\"token punctuation\">(</span>MAP_SHARED </span><span class=\"token punctuation\">\\</span>\n\t\t<span class=\"token expression\"><span class=\"token operator\">|</span> MAP_PRIVATE </span><span class=\"token punctuation\">\\</span>\n\t\t<span class=\"token expression\"><span class=\"token operator\">|</span> MAP_FIXED </span><span class=\"token punctuation\">\\</span>\n\t\t<span class=\"token expression\"><span class=\"token operator\">|</span> MAP_ANONYMOUS </span><span class=\"token punctuation\">\\</span>\n\t\t<span class=\"token expression\"><span class=\"token operator\">|</span> MAP_DENYWRITE </span><span class=\"token punctuation\">\\</span>\n\t\t<span class=\"token expression\"><span class=\"token operator\">|</span> MAP_EXECUTABLE </span><span class=\"token punctuation\">\\</span>\n\t\t<span class=\"token expression\"><span class=\"token operator\">|</span> MAP_UNINITIALIZED </span><span class=\"token punctuation\">\\</span>\n\t\t<span class=\"token expression\"><span class=\"token operator\">|</span> MAP_GROWSDOWN </span><span class=\"token punctuation\">\\</span>\n\t\t<span class=\"token expression\"><span class=\"token operator\">|</span> MAP_LOCKED </span><span class=\"token punctuation\">\\</span>\n\t\t<span class=\"token expression\"><span class=\"token operator\">|</span> MAP_NORESERVE </span><span class=\"token punctuation\">\\</span>\n\t\t<span class=\"token expression\"><span class=\"token operator\">|</span> MAP_POPULATE </span><span class=\"token punctuation\">\\</span>\n\t\t<span class=\"token expression\"><span class=\"token operator\">|</span> MAP_NONBLOCK </span><span class=\"token punctuation\">\\</span>\n\t\t<span class=\"token expression\"><span class=\"token operator\">|</span> MAP_STACK </span><span class=\"token punctuation\">\\</span>\n\t\t<span class=\"token expression\"><span class=\"token operator\">|</span> MAP_HUGETLB </span><span class=\"token punctuation\">\\</span>\n\t\t<span class=\"token expression\"><span class=\"token operator\">|</span> MAP_32BIT </span><span class=\"token punctuation\">\\</span>\n\t\t<span class=\"token expression\"><span class=\"token operator\">|</span> MAP_HUGE_2MB </span><span class=\"token punctuation\">\\</span>\n\t\t<span class=\"token expression\"><span class=\"token operator\">|</span> MAP_HUGE_1GB<span class=\"token punctuation\">)</span></span></span></code></pre></div>\n<p>위는 <a href=\"https://github.com/torvalds/linux/blob/master/include/linux/mman.h\">mman.h</a>에 대한 코드 중에서 매모리 매핑에 관련된 마스크에 대한 내용을 담고 있다.\n이때, 익명 메모리 매핑을 사용하기 위해서는 <code class=\"language-text\">MAP_ANONYMOUS</code> 를 둬서 처리하면 된다.</p>\n<p>이때도 마찬가지로 매핑을 공유할 지 안할 지 처리할 수 있는데 이 구조에 따라서 <code class=\"language-text\">fork()</code> 와 같은 시스템콜에 영향을 끼친다.</p>\n<p><code class=\"language-text\">MAP_PRIVATE</code> : <code class=\"language-text\">fork()</code> 와 같은 시스템콜로 생성된 자식 프로세스는 독립적인 복사본을 얻게된다. (<code class=\"language-text\">malloc()</code>과 같은)</p>\n<p><code class=\"language-text\">MAP_SHARED</code> : 자식 프로세스는 메모리 매핑을 공유하며, 서로의 업데이트를 볼 수 있다. 이렇게 될 경우 IPC 형태라 볼 수 있는데 이 방식으로 생성된 자식 프로세스는 <code class=\"language-text\">pipe()</code>와 같이 사용된다. 비슷한 IPC 형태는 공유 메모리에 의한 IPC라 보면될 것이다.</p>\n<h2 id=\"step-2-본론\" style=\"position:relative;\"><a href=\"#step-2-%EB%B3%B8%EB%A1%A0\" aria-label=\"step 2 본론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2. 본론</h2>\n<p>이제 본론으로 들어와보자.</p>\n<p>사실 위 내용을 다뤘던 이유는 현재 스터디 중인 책과 관련이 있다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/Wr6OE3y.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.yes24.com/Product/Goods/44376723\">그림 9. DevOps와 SE를 위한 리눅스 커널 , 강진우 저, 2017</a></em>\n</p>\n<p>현재, 이 책에 대한 스터디를 진행 중이었고, 1 ~ 3장을 각자 정리를 해오자라고 얘기가 나왔는데 보다 심층적으로 파악할 필요가 있어서 위와 같은 배경지식을 설명해보았다.\n이제 본격적으로 이 책에서 다뤘던 내용을 다뤄보고자한다.</p>\n<p>초점은 2 ~ 3장과 관련된 내용이라고 보면될 것이다.</p>\n<h3 id=\"step-21-virt--res--shr\" style=\"position:relative;\"><a href=\"#step-21-virt--res--shr\" aria-label=\"step 21 virt  res  shr permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.1 VIRT &#x26; RES &#x26; SHR</h3>\n<p>먼저, 리눅스의 top 명령어를 입력하게 되면 아래와 같은 화면을 볼 수 있다.</p>\n<p><img src=\"https://i.imgur.com/WjZnsOx.png\" alt=\"\"></p>\n<p>이 중에서 우리가 중점적으로 볼 지표는 <code class=\"language-text\">VIRT</code>, <code class=\"language-text\">RES</code>, <code class=\"language-text\">SHR</code> 이다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/sI9WtTX.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.yes24.com/Product/Goods/44376723\">그림 10. VIRT, RES, SHR의 관계, DevOps와 SE를 위한 리눅스 커널, p.24</a></em>\n</p>\n<ol>\n<li><code class=\"language-text\">VIRT</code> : <code class=\"language-text\">RES</code>와 <code class=\"language-text\">SHR</code> 그리고 SWAP영역까지 프로세스가 사용되는 메모리의 전체 용량</li>\n<li><code class=\"language-text\">RES</code> :  프로세스가 사용 중인 물리 메모리(Physical Memory)의 용량</li>\n<li><code class=\"language-text\">SHR</code> :  프로세스가 사용 중인 공유 메모리의 용량</li>\n</ol>\n<p>여기서 헷갈렸던 부분은 책에서는 <code class=\"language-text\">VIRT</code>에 대해서 가상메모리(Virtual Memory)의 전체 용량으로 얘기했어서 이것이 위에서 보았던 가상 주소 공간(Virtual Address Area)의 용량을 나타내는 것인지 아니면 실제 HDD나 SDD를 메모리처럼 활용하기 위한 가상메모리인 SWAP 영역을 나타내는지 궁금해졌다.</p>\n<p>찾아보니 <code class=\"language-text\">VIRT</code>가 나타내는 메모리 총 용량은 아래와 같이 계산된다.</p>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>I</mi><mi>R</mi><mi>T</mi><mo>=</mo><mi>R</mi><mi>E</mi><mi>S</mi><mo>+</mo><mi>S</mi><mi>W</mi><mi>A</mi><mi>P</mi><mo>+</mo><mi>S</mi><mi>H</mi><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">VIRT = RES + SWAP + SHR</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">RT</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">RES</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span></span></p>\n<p>즉, 물리메모리, 공유메모리, 가상메모리(SWAP)에 대한 프로세스가 점유하고 있는 메모리 총 용량이라고 볼 수 있다.\n따라서, <code class=\"language-text\">VIRT</code>를 통해서 어떤 프로세스가 스왑메모리를 많이 사용하는지도 파악이 가능할 수 있다.</p>\n<p>왜냐면, 스왑메모리는 가상메모리의 일종이므로 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>I</mi><mi>R</mi><mi>T</mi><mo>></mo><mi>T</mi><mi>O</mi><mi>T</mi><mi>A</mi><mi>L</mi><mtext>  </mtext><mi>M</mi><mi>E</mi><mi>M</mi><mi>O</mi><mi>R</mi><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">VIRT > TOTAL \\; MEMORY</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7224em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">RT</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">TOT</span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">MEMOR</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span></span> 인 상황이면 스왑메모리를 사용하는 것을 추측할 수 있다. (<code class=\"language-text\">SHR</code> 의 크기는 그리 크지 않기 때문이다.)\n이를 토대로 <code class=\"language-text\">SWAP</code> 을 최소화해서 사용해야하는 어플리케이션의 사용량을 추적할 수도 있어보인다.</p>\n<p>어떤 케이스에 SWAP 영역을 최소화 해야되는지 궁금하다면 제 블로그의 아래의 아티클을 읽어보기를 추천한다.</p>\n<ul>\n<li>참고 : <a href=\"https://brewagebear.github.io/fundamental-os-page-cache/\">왜 처리량이 중요한 JVM 어플리케이션은 vm.swappiness = 1로 설정하라고 할까?</a></li>\n</ul>\n<p>그리고 <code class=\"language-text\">VIRT</code>가 Virtual을 나타내는 것과 같이 보이는데 위에서 얘기했던 내용에 대해서 첨언하면, <code class=\"language-text\">VIRT</code>는 <strong>가상 주소 공간에 대한 용량이 맞다</strong>고 보면 된다.</p>\n<blockquote>\n<p>💡즉, 가상 주소 공간에 메모리 할당을 할 때 SWAP에 처리되는 페이지 캐시나 기타 데이터도 이 영역에 할당이 되어지는 것이다.\n이 부분은 서론에서 얘기했듯이 MMU가 관리하고, 스왑-아웃을 통해서 스왑 영역으로 페이지가 이동되더라도 가상 주소 공간에서 할당이 일관되게 유지되는 것이다.</p>\n</blockquote>\n<p>오해의 소지가 있어보이므로 앞으로 물리 메모리와 실제 매핑되서 MMU에 관리되는 부분을 가상 주소 공간, 보조기억장치와 메모리 영역 사이에서 관리되는 부분을 SWAP이라고 명시하도록 하겠다.</p>\n<h3 id=\"step-22-memory-commit\" style=\"position:relative;\"><a href=\"#step-22-memory-commit\" aria-label=\"step 22 memory commit permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.2 Memory Commit</h3>\n<p>자 그러면, 리눅스에서 왜 <code class=\"language-text\">VIRT</code>와 <code class=\"language-text\">SHR</code>를 따로 나눠서 관리를 할까?\n이는 메모리 커밋과 관련이 있다.</p>\n<p>서론에서 얘기한 바와 같이 <code class=\"language-text\">malloc()</code> 등으로 메모리 할당을 요청하면 가상 주소 공간에 대한 주소를 넘겨준다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/wXo9CGA.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.yes24.com/Product/Goods/44376723\">그림 11. VIRT, RES, SHR의 관계, DevOps와 SE를 위한 리눅스 커널, p.25</a></em>\n</p>\n<p>하지만, 이때도 실제 물리 메모리에 해당 영역이 할당된 상태는 아니라는 것이다.\n예약은 해두고 가상 주소 공간에서 주소를 넘겨받는 이러한 동작 방식을 <code class=\"language-text\">Memory Commit</code> 이라 한다.</p>\n<p>그러면 실제 물리 메모리에 언제 바인딩이 될까? 그것은 바로 직접적으로 쓰기 작업이 발생할 때이다.\n쓰기 작업을 수행하면 페이지 부재(Page Fault)가 발생할 것이고 내부적인 매커니즘에 따라서 처리가 된다. (참고로, 페이지 부재(Page Fault)에 대한 처리는 아키텍처마다 다르다.)</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">/*\n*문제의 VMA(가상 메모리 영역)가 거대한 페이지(HugeTLB)에 의해 지원되는 경우 커널은 결함 처리를 `hugetlb_fault` 기능에 위임. \n* 이 기능은 크기 및 관리 방식으로 인해 일반 페이지와 다르게 처리되는 대형 페이지와 특히 관련된 오류를 처리.\n*/</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">unlikely</span><span class=\"token punctuation\">(</span><span class=\"token function\">is_vm_hugetlb_page</span><span class=\"token punctuation\">(</span>vma<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> ret <span class=\"token operator\">=</span> <span class=\"token function\">hugetlb_fault</span><span class=\"token punctuation\">(</span>vma<span class=\"token operator\">-></span>vm_mm<span class=\"token punctuation\">,</span> vma<span class=\"token punctuation\">,</span> address<span class=\"token punctuation\">,</span> flags<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\n<span class=\"token comment\">/*\n* 거대한 페이지 폴트가 아닌 경우 `__handle_mm_fault` 함수로 페이지 부재를 전달. 이 함수에는 표준 페이지 오류를 처리하는 기본 논리가 포함되어 있고, 여기에는 여러 작업이 포함될 수 있다.\n* 1. 페이지가 이미 메모리에 있지만 프로세스의 페이지 테이블에 매핑되지 않았는지 확인(사소한 결함).\n* 2. 이전에 교체된 경우(스와핑) 교체 공간(스왑 영역)에서 페이지를 로드.\n* 3. 파일 기반 매핑인 경우 백업 저장소(예: 디스크의 파일)에서 페이지를 가져옴.\n* 4. 이전에 기록되지 않은 익명 매핑인 경우 새로운 제로 페이지 할당.\n*/</span>\n<span class=\"token keyword\">else</span> ret <span class=\"token operator\">=</span> <span class=\"token function\">__handle_mm_fault</span><span class=\"token punctuation\">(</span>vma<span class=\"token punctuation\">,</span> address<span class=\"token punctuation\">,</span> flags<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>\n<p>참고 코드 1 : <a href=\"https://github.com/torvalds/linux/blob/master/arch/arm64/mm/fault.c#L500C1-L500C1\">linux/arch/arm64/mm/fault.c</a></p>\n</li>\n<li>\n<p>참고 코드 2 : <a href=\"https://github.com/torvalds/linux/blob/master/mm/memory.c#L5201\">linux/mm/memory.c</a></p>\n</li>\n<li>\n<p>참고 코드 3 : <a href=\"https://github.com/torvalds/linux/blob/master/mm/page_alloc.c#L4594C5-L4594C5\">linux/mm/page_alloc.c</a></p>\n</li>\n</ul>\n<p>즉, 새로 할당을 하는 케이스면 4번에 해당될 것이고 새로운 제로 페이지를 할당 받는 것이다.<br>\n이렇게 바인딩된 값을 페이지 테이블(Page Table)이라 부르며, 물리 메모리에 실제 바인딩된 영역이 <code class=\"language-text\">RES</code>로 계산된다.</p>\n<p>책에서도 나오지만 그렇다면 위 방식과 같이 처리할 경우 무제한으로 <code class=\"language-text\">malloc</code> 과 같은 시스템 콜을 사용할 수 있는가에 대해서 나온다.\n이에 대한 짧은 코드도 제시해주는데 실제로 돌려보면 비슷한 결과를 얻을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;unistd.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdlib.h></span></span>\n\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">MEGABYTE</span> <span class=\"token expression\"><span class=\"token number\">1024</span><span class=\"token operator\">*</span><span class=\"token number\">1024</span></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>myblock <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span> \n\t<span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\tmyblock <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span>MEGABYTE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>myblock<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span>“Error<span class=\"token operator\">!</span>”<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span> \n\t\t<span class=\"token punctuation\">}</span>\n\n\t\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span>“Currently allocating <span class=\"token operator\">%</span>d MB\\n”<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">++</span>count<span class=\"token punctuation\">)</span><span class=\"token operator\">*</span>MEGABYTE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\t\t<span class=\"token comment\">// memset(myblock, 1, MEGABYTE);</span>\n\t\t<span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 코드를 <code class=\"language-text\">gcc example1.c</code> 로 <code class=\"language-text\">a.out</code> 실행 파일을 얻어서 돌려본 결과를 아래와 같다.</p>\n<p><img src=\"https://i.imgur.com/2A5yc1J.png\" alt=\"\"></p>\n<p>보면 세번째 (6XXXX) 숫자가 <code class=\"language-text\">VIRT</code>고 1548 값이 <code class=\"language-text\">RES</code> 값이다.  <code class=\"language-text\">//memset(myblock, 1, MEGABYTE);</code> 이 주석처리 되어있어서 우리가 이론 상으로 배웠던 내용처럼 <code class=\"language-text\">RES</code>는 증가하지 않는 모습을 보여준다.\n그렇다면 주석을 해제하고 돌려보면 어떻게 될까?</p>\n<p><img src=\"https://i.imgur.com/7lkKwqL.png\" alt=\"\"></p>\n<p>3152였던 <code class=\"language-text\">RES</code> 값이 실제로 증가함을 확인할 수 있다. 동일한 값이 나오는 이유는 VM에 돌리는 환경이다보니 메모리가 한정적이라 <code class=\"language-text\">sleep(2)</code>로 둬서 2초의 간격이 생겨서 그런거라고 보면 된다.\n자 이제 실제 메모리 쓰기 전까지는 <code class=\"language-text\">VIRT</code>만 증가하고, 실제 메모리가 쓰여질 때 물리 메모리인 <code class=\"language-text\">RES</code>를 할당받는다는 점을 알게되었다.</p>\n<p>그렇다면, <code class=\"language-text\">VIRT</code>는 무한정 늘어날 수 있을까? 그 부분에 관련된 커널 파라미터(<code class=\"language-text\">vm.overcommit_memory</code>)의 값에 따라서 달라진다.\n그러면 왜 리눅스 커널은 이런식으로 메모리 커밋을 수행하면 바로 할당되는 것이 아니라 지연되게끔 개발 되었을까?</p>\n<p>이유는 새로운 프로세스를 만드는 <code class=\"language-text\">fork()</code> 와 같은 시스템 콜을 처리해야되기 때문이다.</p>\n<p>서론에서도 잠깐 언급된 <code class=\"language-text\">fork()</code> 시스템 콜은 현재 커널에 실행 중인 프로세스와 똑같은 프로세스를 하나 만들게 된다. 그 프로세스는 후에 <code class=\"language-text\">exec()</code>와 같은 시스템 콜을 통해서 다른 프로세스로 변화한다.\n이러한 상황이다보니 <strong>확보한 메모리가 대부분 쓸모가 없어질 수도 있는 것</strong>이다.</p>\n<p>그래서 COW(Copy-On-Write)라는 기법을 통해서 복사된 메모리에 실제 쓰기 작업이 발생한 후에야 실질적인 메모리 할당을 시작한다.\n이를 위해서 메모리 커밋이 필요하다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/ODNgVTH.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"http://csl.snu.ac.kr/courses/4190.307/2020-1/9-mmap.pdf\">그림 12. COW(Copy-On-Write), Memory Mapping, SNU</a></em>\n</p>\n<p>위는 <code class=\"language-text\">fork()</code> 시스템 콜 상황에서 COW가 동작하는 원리를 보여준다. 이렇게 처리되기 때문에 메모리 커밋이 없으면 다음과 같은 상황이 발생할 수 있다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/h0lAhWM.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.yes24.com/Product/Goods/44376723\">그림 13. fork()와 Memory Commit, DevOps와 SE를 위한 리눅스 커널, p.28</a></em>\n</p>\n<p>1기가의 가용메모리가 있고, 3GB의 프로세스를 <code class=\"language-text\">fork()</code> 를 통해서 복제한 상황이다. 이 케이스에 만약, 메모리 커밋처럼 지연처리가 없다면 OOM과 같은 문제도 발생할 수 있다.\n어쨋든 메모리 커밋으로 위와 같은 상황에서도 오버커밋이 되긴했지만 쓰이기 전까지는 지연처리 되니 보다 안정성을 제공한다 볼 수 있다.</p>\n<p>이 커밋 비율을 보기 위해서는 <code class=\"language-text\">sar</code> 와 같은 모니터링 도구를 활용할 수 있다. 커밋된 비율도 중요한 점이 순간적으로 시스템에 부하나 장애를 야기할 수 있기 때문에 위에서 잠깐 보았던 커널 파라미터인 <code class=\"language-text\">vm.overcommit_memory</code>를 통해 메모리 커밋에 대한 제어권을 사용자가 선택할 수 있게 하였다.</p>\n<table>\n<thead>\n<tr>\n<th>파라미터 옵션</th>\n<th>동작 방시</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>기본동작 방식이며, overcommit 최댓값은 page cache + swap area + slab reclaimable 이다. (현재 가용 메모리 영역은 보지 않는다.)</td>\n</tr>\n<tr>\n<td>1</td>\n<td>무조건 commit을 진행한다. 아무것도 계산하지 않으면 요청 온 모든 메모리에 대한 commit이 발생한다.</td>\n</tr>\n<tr>\n<td>2</td>\n<td>제한적으로 commit을 진행한다. <code class=\"language-text\">vm.overcommit_ratio</code>에 대한 비율과 swap 영역에 대한 크기를 토대로 계산된다. (/proc/meminfo 에서 확인가능)</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"step-23-프로세스의-상태\" style=\"position:relative;\"><a href=\"#step-23-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%81%ED%83%9C\" aria-label=\"step 23 프로세스의 상태 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.3 프로세스의 상태</h3>\n<p>위에서는 <code class=\"language-text\">VIRT</code>, <code class=\"language-text\">RES</code>, <code class=\"language-text\">SHR</code>를 다루면서 메모리 커밋에 대해서도 다뤘었다. 이제 <code class=\"language-text\">top</code> 명령어를 볼 수 있는 지표 중에 프로세스의 상태를 보는 지표를 확인할 차례이다.</p>\n<p><img src=\"https://i.imgur.com/CN6oaqZ.png\" alt=\"\"></p>\n<p>해당 지표는 <code class=\"language-text\">SHR</code> 옆에 보이는 <code class=\"language-text\">S</code>라는 값이며 각 프로세스의 상태를 나타낸다.\n프로세스의 상태는 아래와 같다.</p>\n<table>\n<thead>\n<tr>\n<th>상태 플래그 값</th>\n<th>상태</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>D</td>\n<td>디스크 혹은 네트워크 I/O를 대기하는 프로세스 (<code class=\"language-text\">TASK_UNINTERRUPTIBLE</code> 상태와 비슷)</td>\n</tr>\n<tr>\n<td>R</td>\n<td>실행 중인 프로세스를 의미하며, 실제로 CPU 자원을 소모하고 있는 프로세스 (<code class=\"language-text\">TASK_RUNNING</code> 상태와 비슷)</td>\n</tr>\n<tr>\n<td>S</td>\n<td>D 상태와 비슷하지만, 조기에 깨울 수 있는 상태의 프로세스 (<code class=\"language-text\">TASK_INTERRUPTIBLE</code> 상태와 비슷)</td>\n</tr>\n<tr>\n<td>T</td>\n<td><code class=\"language-text\">strace</code> 등으로 프로세스의 시스템 콜을 추적하고 있는 상태의 프로세스(<code class=\"language-text\">__TASK_TRACED</code> 혹은 <code class=\"language-text\">__TASK_STOPPED</code> 상태와 비슷)</td>\n</tr>\n<tr>\n<td>Z</td>\n<td>좀비상태의 프로세스로, 부모 프로세스가 죽은 자식 프로세스이다.</td>\n</tr>\n</tbody>\n</table>\n<p>위 값을 잘보면 우리가 서론에서 Run Queue와 Wait Queue를 다루면서 했던 내용과 흡사하다고 볼 수 있다.\n우리는 어느정도 이 개념에 대해서 알고 있으니 바로 프로세스 상태 변화표를 확인해보자.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/zmNE7a6.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.yes24.com/Product/Goods/44376723\">그림 14. 프로세스 상태 변화, DevOps와 SE를 위한 리눅스 커널, p.28</a></em>\n</p>\n<p>아마도 서론을 잘 읽었던 분이라면 이 부분에 대해서 이해하기 수월할 것이라고 생각한다.  위에서 다루지 않았던 내용은 좀비 상태 뿐인데 이건 아래의 표로 설명이 가능하다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/dVDQC44.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.yes24.com/Product/Goods/44376723\">그림 15. 프로세스 생성과 종료, DevOps와 SE를 위한 리눅스 커널, p.33</a></em>\n</p>\n<p>위 그림은 <code class=\"language-text\">fork()</code>를 통해서 자식 프로세스가 생성되는 모습을 보여주고 있다. 이런 케이스에 부모 프로세스가 죽었는데 자식 프로세스가 남아 있거나 자식 프로세스의 비정상 동작으로 부모 프로세스가 죽을 수 있다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/4wG4l9Q.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.yes24.com/Product/Goods/44376723\">그림 16. 좀비 프로세스가 되는 경우, DevOps와 SE를 위한 리눅스 커널, p.33</a></em>\n</p>\n<p>위와 같은 케이스가 좀비 프로세스가 된다고 보면 된다. 좀비 프로세스는 시스템의 리소스를 차지하지 않으므로 큰 문제는 되지 않으나 PID는 대략 65536개로 생성이 가능하기때문에 이 PID를 점유하고 있고, 새로운 프로세스가 할당될 PID가 부족하여 PID 고갈을 야기할 수 있다.</p>\n<h3 id=\"24-프로세스의-우선순위\" style=\"position:relative;\"><a href=\"#24-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84\" aria-label=\"24 프로세스의 우선순위 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.4 프로세스의 우선순위</h3>\n<p>이제는 <code class=\"language-text\">top</code> 명령어에서 볼 수 있는 지표인 <code class=\"language-text\">PR</code>과 <code class=\"language-text\">NI</code>에 대해서 알아보고자 한다.</p>\n<p><img src=\"https://i.imgur.com/n6IROxy.png\" alt=\"\"></p>\n<p>이 두 개의 값은 모두 프로세스 우선순위와 연관되어있다.\nRun Queue와 Wait Queue 과정에서 각 프로세스들이 어떻게 휴면상태로 바뀌고 다시 런상태로 바뀌고, 스케줄러가 해당 태스크들을 처리한다고 하였다.\n이때, 실행될 프로세스의 우선순위를 통해서 스케줄러가 디스패처라는 개념에게 해당 프로세스에 대한 정보를 넘겨준다고 보면된다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/bXW9o3Q.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.yes24.com/Product/Goods/44376723\">그림 17. 스케줄러의 기본 동작, DevOps와 SE를 위한 리눅스 커널, p.35</a></em>\n</p>\n<p>그렇다면, <code class=\"language-text\">PR</code>과 <code class=\"language-text\">NI</code> 지표는 어떤 것을 나타낼까?</p>\n<table>\n<thead>\n<tr>\n<th>지표</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>PR</td>\n<td>커널에서 인식하는 해당 프로세스의 실제 우선순위 값</td>\n</tr>\n<tr>\n<td>NI</td>\n<td>nice값이라 부르며, 명령어를 통해 우선순위를 낮출 때 사용된다. (즉, 이 값을 통해서 PR 값을 낮출 수 있다.)</td>\n</tr>\n</tbody>\n</table>\n<p>실제로 nice 값을 낮추면 우선순위 낮은 프로세스가 먼저 수행될까?</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">#!/usr/bin/python\n\nimport datetime\n\nstart_time = datetime.datetime.now()\nprint(&quot;START : &quot; + str(start_time))\n\nsum = 0\n\nfor i in range(1,1000000000):\n    sum = sum + i\n    #print(i)\nprint(sum)\n\nend_time = datetime.datetime.now()\nprint(&quot;END : &quot; + str(end_time))\n\nelapsed_time = end_time - start_time\nprint(&quot;Elapsed : &quot; + str(elapsed_time))</code></pre></div>\n<p>위와 같은 파이썬 코드를 주고, 아래와 같이 두 개의 프로세스를 구동 시켰다.</p>\n<p><img src=\"https://i.imgur.com/tT3WdYH.png\" alt=\"\"></p>\n<p>책에서는 5000만건으로 처리했는데 M1 Pro 프로세서의 단일 코어 성능이 좋아서 그런지 원하던 결과가 안나와서 10억번 반복을 돌도록 처리하였다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">ubuntu@ubuntu:~/example$ sudo python3 ex.py\nSTART : 2023-08-23 10:53:48.624415\n499999999500000000\nEND : 2023-08-23 10:55:23.304349\nElapsed : 0:01:34.679934\n\nubuntu@ubuntu:~/example$ sudo nice -n -20 python3 ex.py\nSTART : 2023-08-23 10:53:48.879665 # nice를 -20으로 우선순위(PR)을 0으로 할당된 프로세스가 아래의 프로세스보다 늦게 수행\n499999999500000000\nEND : 2023-08-23 10:55:21.738873 # 그러나 더 빨리 처리된 모습을 볼 수 있다.\nElapsed : 0:01:32.859208\n\nubuntu@ubuntu:~/example$ grep -c processor /proc/cpuinfo\n1</code></pre></div>\n<p>VM으로 단일 코어로 처리했을 경우에 나오는 결과이다.\n그러나, 단일 코어가 아닐 경우에는 위와 같이 nice값으로 우선순위를 올린 프로세스가 먼저 끝나는 것을 보장할 수가 없다.</p>\n<p>이유는 바로 병렬성과 관련되어있다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/w1oQ1VG.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.yes24.com/Product/Goods/44376723\">그림 18. nice의 효과를 못 받는 경우, DevOps와 SE를 위한 리눅스 커널, p.37</a></em>\n</p>\n<p>2개 코어라고 가정하였을 경우 각각 코어 마다 Run Queue가 위치한다고 말했었다. 그러다보니 nice 값을 낮춰도 다른 코어에서 프로세스를 충분히 돌릴 수 있다면 nice 값을 낮춘 프로세스보다 빨리 끝날 수 있다.\n실제 시작할 프로세스에 대한 nice 값은 <code class=\"language-text\">nice</code> 명령어로 처리할 수 있으며, 동작 중인 프로세스에 대한 핸들링은 <code class=\"language-text\">renice</code> 명령을 통해서 낮출 수 있다.</p>\n<p>이때 사용되는 스케줄 방식이 바로 CFS(Completely Fair Scheduling)이다.</p>\n<h3 id=\"step-3-load-averrage와-시스템-부하\" style=\"position:relative;\"><a href=\"#step-3-load-averrage%EC%99%80-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%B6%80%ED%95%98\" aria-label=\"step 3 load averrage와 시스템 부하 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3. Load Averrage와 시스템 부하</h3>\n<p>리눅스에서는 Load Average를 아래와 같이 정의한다.</p>\n<blockquote>\n<p>R과 D인 상태의 프로세스의 개수의 1분, 5분, 15분마다의 평균 값</p>\n</blockquote>\n<p>즉, 얼마나 많은 프로세스가 실행 / 실행 대기 중이냐를 의미하는 수치이다.\n이 값이 높다면 많은 수의 프로세스가 실행 중이거나 I/O를 처리하기 위해 대기 상태 있다는 것이고 낮으면 적은 수의 프로세스가 그렇다는 것이다.</p>\n<p>이는 위에서 본 바와 같이 CPU 코어 수에 따라서 상대적이다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/OtiERRi.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.yes24.com/Product/Goods/44376723\">그림 19. CPU 코어와 프로세스의 관계, DevOps와 SE를 위한 리눅스 커널 이야기, p.42</a></em>\n</p>\n<p>두 개 모두 Load Average값은 2의 근사 값이 나올 것이다. (프로세스의 개수를 뜻하기 때문에) 그러나, 단일 코어일 경우에는 Run Queue에 두 개의 프로세스가 있으며, 듀얼 코어일 경우에는 각 Run Queue에 분리되어서 동작한다.\n즉, 병렬성이 보장되므로 듀얼코어인 케이스가 싱글코어인 케이스보다 대기 상태가 적을 수 밖에 없다.</p>\n<p>따라서, 같은 Load Average라고 해도 CPU 코어 수에 따라 의미가 달라질 수 있다.</p>\n<p>실제 커널 코드는 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// linux/kernel/sched/ladavg.c</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">get_avenrun</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> <span class=\"token operator\">*</span>loads<span class=\"token punctuation\">,</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> offset<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> shift<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\tloads<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>avenrun<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> offset<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> shift<span class=\"token punctuation\">;</span>\n\tloads<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>avenrun<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> offset<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> shift<span class=\"token punctuation\">;</span>\n\tloads<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>avenrun<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> offset<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> shift<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">calc_global_load</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">(</span>중략<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t\n\tactive <span class=\"token operator\">=</span> <span class=\"token function\">atomic_long_read</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>calc_load_tasks<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// calc_load_tasks 값을 atomic_long_read() 매크로 함수를 통해서 읽은 후 active에 넣는다.</span>\n\tactive <span class=\"token operator\">=</span> active <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span> active <span class=\"token operator\">*</span> FIXED_1 <span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n\tavenrun<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">calc_load</span><span class=\"token punctuation\">(</span>avenrun<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> EXP_1<span class=\"token punctuation\">,</span> active<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tavenrun<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">calc_load</span><span class=\"token punctuation\">(</span>avenrun<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> EXP_5<span class=\"token punctuation\">,</span> active<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tavenrun<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">calc_load</span><span class=\"token punctuation\">(</span>avenrun<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> EXP_15<span class=\"token punctuation\">,</span> active<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// active 값을 바탕으로 avenrun[] 배열에 있는 값들을 calc_load_n() 함수를 이용해서 계산한다.</span>\n\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">(</span>중략<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">long</span> <span class=\"token function\">calc_load_fold_active</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">rq</span> <span class=\"token operator\">*</span>this_rq<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> adjust<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">long</span> nr_active<span class=\"token punctuation\">,</span> delta <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n\tnr_active <span class=\"token operator\">=</span> this_rq<span class=\"token operator\">-></span>nr_running <span class=\"token operator\">-</span> adjust<span class=\"token punctuation\">;</span> <span class=\"token comment\">// nr_active 변수에 Run Queue기준으로 nr_running 상태의 개수를 adjust값을 뺴서 입력한다. (R 상태 프로세스)</span>\n\tnr_active <span class=\"token operator\">+=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>this_rq<span class=\"token operator\">-></span>nr_uninterruptible<span class=\"token punctuation\">;</span> <span class=\"token comment\">// nr_uniterruptible 프로세스 개수도 nr_active 변수에 더해준다 (D 상태 프로세스)</span>\n\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nr_active <span class=\"token operator\">!=</span> this_rq<span class=\"token operator\">-></span>calc_load_active<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\tdelta <span class=\"token operator\">=</span> nr_active <span class=\"token operator\">-</span> this_rq<span class=\"token operator\">-></span>calc_load_active<span class=\"token punctuation\">;</span> \n\t\tthis_rq<span class=\"token operator\">-></span>calc_load_active <span class=\"token operator\">=</span> nr_active<span class=\"token punctuation\">;</span> <span class=\"token comment\">// nr_active 값이 기존 값과 다르면 clac_load_active 변수에 입력한다.</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">return</span> delta<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<ul>\n<li>참고 코드 1: <a href=\"https://github.com/torvalds/linux/blob/master/kernel/sched/loadavg.c#L71C1-L76\">linux/kernel/sched/loadavg.c - L71 ~ 76</a></li>\n<li>참고 코드 2 : <a href=\"https://github.com/torvalds/linux/blob/master/kernel/sched/loadavg.c#L349C1-L380C1\">linux/kernel/sched/loadavg.c - - L349 ~ 380</a></li>\n<li>참고 코드 3 : <a href=\"https://github.com/torvalds/linux/blob/master/kernel/sched/loadavg.c#L78-L91\">linux/kernel/sched/loadavg.c - L78 ~ 91</a></li>\n</ul>\n<p>책에서 사용하는 커널버전과 다르다보니 좀 더 변경된 부분이 있으나, 매번 Tick 주기에 호출되는 <a href=\"https://github.com/torvalds/linux/blob/master/kernel/sched/core.c#L5640\">schedule_tick(void)</a> 함수를 보면 책에 나온 <code class=\"language-text\">calc_laod_account_active()</code> 함수 대신 <code class=\"language-text\">calc_global_load_tick()</code> 함수로 변경되었고, 이 함수 내부적으로 <code class=\"language-text\">calc_load_fold_active()</code> 함수를 호출하는 방식을 볼 수 있다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/awmZ9Ts.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.yes24.com/Product/Goods/44376723\">그림 20. Load Average의 계산 과정, DevOps와 SE를 위한 리눅스 커널 이야기, p.47</a></em>\n</p>\n<p>위 내용을 정리하면 위와 같이 볼 수 있다. 함수명은 위에서 말한 듯이 커널 버전이 올라감에 따라 달라진 부분이 있으니 참고바란다.\n결국 서두에서도 얘기했듯 R과 D 상태의 프로세스의 개수를 세는 것을 Load Average로 볼 수 있다.</p>\n<h4 id=\"step-31-cpu-bound-vs-io-bound\" style=\"position:relative;\"><a href=\"#step-31-cpu-bound-vs-io-bound\" aria-label=\"step 31 cpu bound vs io bound permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.1 CPU Bound vs I/O Bound</h4>\n<p>따라서, Load Average 값이 높은 부분은 CPU가 많이 사용되는 프로세스(R)가 많을 수도 있고, I/O 대기에 따른 프로세스(D)가 많아서 일수 있다.\n즉, 이 값만으로는 어떤 부하가 시스템이 겪고 있는지 알기가 힘든 것이다.</p>\n<p>이를 단순하게 확인하기 위해서 아래 2가지 파이썬 코드를 돌려보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">#!/usr/bin/python\n### CPU Bound 어플리케이션 예시\n\ntest = 0\n\n\nwhile True:\n\ttest = test + 1\n\n#!/usr/bin/python\n### I/O Bound 어플리케이션 예시\n\nwhile True:\n\tf = open(&quot;./io_test.txt&quot;, &#39;w&#39;)\n\tf.write(&quot;test&quot;)\n\tf.close()</code></pre></div>\n<p>자 이 두가지 스크립트를 돌려보자\n먼저 CPU Bound 어플리케이션일 경우다.</p>\n<p><img src=\"https://i.imgur.com/sctfpuy.png\" alt=\"\"></p>\n<p>실제로 Load Average가 올라감을 확인할 수 있다.\n그렇다면, I/O Bound 어플리케이션은 어떨까?</p>\n<p><img src=\"https://i.imgur.com/BEitHl1.png\" alt=\"\"></p>\n<p>어떻게 보면 둘다 비슷한 Load Average를 보여주지만 실제로 주는 부하의 형태는 매우 다르다.\n부하의 종류에 따라서 해결방법도 달라진다.</p>\n<p>여기서는 단순한 파이썬 스크립트를 통해서 보여줬지만 실제 웹 어플리케이션이나 실무에서 겪는 문제에서도 이 문제를 해결하는 방식은 달라진다.\nCPU Bound 어플리케이션으로 인해 부하가 발생하면 신규 인스턴스를 투입하거나 로드밸런싱으로 부하분산을 할 수 있으나 I/O같은 경우에는 주로 DB같은데서 부하가 발생하므로 이중화해도 결국 똑같은 문제이다.\n이는 별도로 처리를 해줘야한다.</p>\n<p>이에 대해서 아주 자세히 설명한 강의가 있어서 이를 링크로 남겨본다.</p>\n<ul>\n<li><a href=\"https://class101.net/classic/products/T6HT0bUDKIH1V5i3Ji2M\">현직 대기업 개발자 푸와 함께하는 진짜 백엔드 시스템 실무!</a></li>\n</ul>\n<p>그렇다면, Load Average가 부하의 성격은 보여주지 않는데 CPU Bound인지 I/O Bound인지 파악할 수 있는 방법이 있을까?\n바로 <code class=\"language-text\">vmstat</code> 을 통해서 해결할 수 있다.</p>\n<p>CPU Bound 어플리케이션을 수행 후에 확인해보자.</p>\n<p><img src=\"https://i.imgur.com/f1akP5D.png\" alt=\"\"></p>\n<p>이제 I/O Bound 어플리케이션을 수행 후에 확인해보자.</p>\n<p><img src=\"https://i.imgur.com/dAtEzvt.png\" alt=\"\"></p>\n<p>포인트는 바로 <code class=\"language-text\">r</code> 과 <code class=\"language-text\">b</code> 열이다</p>\n<ul>\n<li>r : 실행되기를 기다리거나 현재 실행되고 있는 프로세스의 개수 (nr_running)</li>\n<li>b : I/O를 위해 대기열에 있는 프로세스의 개수 (nr_uniterruptible)</li>\n</ul>\n<p>실제로 이러한 부하는 운영하는 입장에서 시스템에 미치는 영향은 다양하다.\n이 때문에 실무에서 이러한 지표를 수집하는 것이라 볼 수 있다.</p>\n<h1 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h1>\n<p>이 책은 어떠한 명령어를 통해서 어떤 지표를 봐야하는 지와 그와 관련된 커널 내부 매커니즘을 설명한다.\n그렇다보니 OS에 대한 기본 배경지식이 없다면 읽기에 난이도가 높을 수 있다고 볼 수 있다.</p>\n<p>하지만, 책 자체가 친절하게 적혀있어서 더 궁금한 부분은 독자들의 몫으로 남겨줬다고 생각한다.</p>\n<p>우리는 초기에 이 기본 개념들을 이해하기 위한 최소한의 배경지식을 배웠고, 그 뒤로 커널 스케줄링이나 컨텍스트 스위치 개념 그리고 Load Average에 대한 개념을 배우게 되었다.\n책에서는 웹서버를 실제로 열어서 Load Average를 재곤했는데 이 부분은 생략하였다.</p>\n<p>궁금하신 분이 계시다면 책을 사서 읽기를 추천드린다.</p>\n<p>커널 공부를 하면서 느끼는 점은 결국 기본기가 매우 중요하다는 점이다.\n특히, 운영체제는 공부할 내용도 방대하고 엄두가 안날 때가 많다. 하지만 운영체제에서 쓰이는 개념들은 결국 웹 어플리케이션이나 프로그래밍 언어에서도 쓰인다.</p>\n<p>대표적으로 자바의 NIO에서는 기존 I/O의 성능을 올리기 위해서 OS 레벨의 기능들을 제공해주는데 그 중 대표적인 기능이 MMIO다.\n또한, 실제 어플리케이션들을 운영할 때 왜 이런식으로 튜닝하기를 권장하는 지 등도 운영체제를 공부하는데 도움이 된다.</p>\n<p>위 내용과 관련된 필자의 포스팅은 아래와 같다.</p>\n<ol>\n<li><a href=\"https://brewagebear.github.io/fundamental-nio-and-io-models/\">자바 NIO의 동작원리 및 IO 모델</a></li>\n<li><a href=\"https://brewagebear.github.io/fundamental-os-page-cache/\">왜 처리량이 중요한 JVM 어플리케이션은 vm.swappiness = 1로 설정하라고 할까?</a></li>\n</ol>\n<p>필자는 무협소설이나 웹툰을 좋아하는 편인데 무협지에는 이러한 대사가 많이 나온다.</p>\n<blockquote>\n<p>수단과 과정은 달라도 극에 달하면 결국 같은 걸로 귀결 된다. 정파든 사파든 마도든 극에 이르는 것은 같다.</p>\n</blockquote>\n<p>즉, 만류귀종이라고 볼 수 있다. 요즘 추상화된 레벨보다는 로우레벨 배경의 공부를 하다보니 문뜩 든 생각이었다.\n어? 이 개념 이거랑 같은데? 보면 비슷하고 그랬었다. 아직은 무림초출급 내공이지만 언젠가 공부를 계속하다보면 극에 달할 때가 올까?</p>\n<p>그 부분은 모르겠지만 궁금해서 하는 공부가 제일 재밌는 것 같다.</p>\n<h1 id=\"참고자료\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\" aria-label=\"참고자료 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고자료</h1>\n<ol>\n<li><a href=\"https://cs4118.github.io/www/2023-1/\">COMS W4118 Operating Systems 1 - Columbia University</a></li>\n<li><a href=\"https://blog.naver.com/PostView.naver?blogId=crushhh&#x26;logNo=221568455956\">시그널: 유저 공간에서 pause() 함수 호출 시 커널 실행 흐름 파악하기 - Austin Kim</a></li>\n<li><a href=\"http://books.gigatux.nl/mirror/kerneldevelopment/0672327201/ch04lev1sec2.html\">The Liunx Scheduling Algorithm - Team LiB</a></li>\n<li><a href=\"https://blog.naver.com/sysapi/20011482139\">wait Queue - 달려라</a></li>\n<li><a href=\"http://csl.snu.ac.kr/courses/4190.307/2020-1/9-mmap.pdf\">Memory Mapping - Seoul National University</a></li>\n<li><a href=\"https://docs.kernel.org/admin-guide/mm/concepts.html\">Concepts overview - The Linux Kernel Admin Guide</a></li>\n</ol>\n<h1 id=\"읽을거리\" style=\"position:relative;\"><a href=\"#%EC%9D%BD%EC%9D%84%EA%B1%B0%EB%A6%AC\" aria-label=\"읽을거리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>읽을거리</h1>\n<ol>\n<li><a href=\"https://freecontent.manning.com/concurrency-vs-parallelism/\">concurrency-vs-parallelism</a></li>\n<li><a href=\"https://class101.net/classic/products/T6HT0bUDKIH1V5i3Ji2M\">현직 대기업 개발자 푸와 함께하는 진짜 백엔드 시스템 실무!</a></li>\n<li><a href=\"https://brewagebear.github.io/fundamental-nio-and-io-models/\">자바 NIO의 동작원리 및 IO 모델</a></li>\n<li><a href=\"https://brewagebear.github.io/fundamental-os-page-cache/\">왜 처리량이 중요한 JVM 어플리케이션은 vm.swappiness = 1로 설정하라고 할까?</a></li>\n</ol>","frontmatter":{"date":"August 23, 2023","title":"[Kernel] 리눅스 스케줄링 매커니즘과 Load Average","categories":"개발 인프라 독서요약","author":"개발한입","emoji":"💻"},"fields":{"slug":"/linux-kernel-internal-1/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://brewagebear.github.io","comments":{"utterances":{"repo":"brewagebear/blog-comments"}}}}},"pageContext":{"slug":"/linux-kernel-internal-2/","nextSlug":"/linux-kernel-internal-1/","prevSlug":""}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}