{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/linux-kernel-internal-2/",
    "result": {"data":{"cur":{"id":"4df41ab3-4636-55ae-99e1-06ce85d287e2","html":"<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#step-1-%EC%84%9C%EB%A1%A0\">STEP 1. 서론</a></p>\n</li>\n<li>\n<p><a href=\"#step-11-%EA%B0%80%EC%83%81-%EC%A3%BC%EC%86%8C-%EA%B3%B5%EA%B0%84\">STEP 1.1 가상 주소 공간</a></p>\n</li>\n<li>\n<p><a href=\"#step-12-task_struct%EC%99%80-mm_struct%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%B4%ED%95%B4\">STEP 1.2 task_struct와 mm_struct에 대한 이해</a></p>\n</li>\n<li>\n<p><a href=\"#step-13-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%ADvirtual-memory-area-vma\">STEP 1.3 가상 메모리 영역(Virtual Memory Area, VMA)</a></p>\n</li>\n<li>\n<p><a href=\"#step-14-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EA%B0%80-%EA%B0%80%EC%83%81-%EC%A3%BC%EC%86%8C-%EA%B3%B5%EA%B0%84%EC%97%90-%EB%A7%A4%ED%95%91%EB%90%98%EB%8A%94-%EB%B0%A9%EC%8B%9D\">STEP 1.4 프로세스가 가상 주소 공간에 매핑되는 방식</a></p>\n</li>\n<li>\n<p><a href=\"#step-14-%ED%8E%98%EC%9D%B4%EC%A7%80%EC%99%80-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C\">STEP 1.4 페이지와 페이지 캐시</a></p>\n<ul>\n<li><a href=\"#step-141-%ED%8E%98%EC%9D%B4%EC%A7%80\">STEP 1.4.1 페이지</a></li>\n<li><a href=\"#step-142-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C\">STEP 1.4.2 페이지 캐시</a></li>\n<li><a href=\"#step-143-%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-%EC%A0%95%EC%B1%85\">STEP 1.4.3 페이지 교체 정책</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-2-%EB%B3%B8%EB%A1%A0\">STEP 2. 본론</a></p>\n</li>\n<li>\n<p><a href=\"#step-21-free-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%B6%84%EC%84%9D\">STEP 2.1 free 명령어 분석</a></p>\n<ul>\n<li><a href=\"#step-211-buff%EC%99%80-cache-%EC%98%81%EC%97%AD\">STEP 2.1.1 buff와 cache 영역</a></li>\n<li><a href=\"#step-212-avaliable-%EC%A7%80%ED%91%9C\">STEP 2.1.2 avaliable 지표</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-22-procmeminfo-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%B6%84%EC%84%9D\">STEP 2.2 /proc/meminfo 명령어 분석</a></p>\n</li>\n<li>\n<p><a href=\"#step-23-slab-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD\">STEP 2.3 slab 메모리 영역</a></p>\n<ul>\n<li><a href=\"#step-231-vmalloc%EA%B3%BC-kmalloc\">STEP 2.3.1 vmalloc()과 kmalloc()</a></li>\n<li><a href=\"#step-232-slab\">STEP 2.3.2 Slab</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-3-%EA%B2%B0%EB%A1%A0\">STEP 3. 결론</a></p>\n</li>\n<li>\n<p><a href=\"#step-4-%EC%B6%94%EC%8B%A0\">STEP 4. 추신</a></p>\n</li>\n</ul>\n</div>\n<h1 id=\"개요\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EC%9A%94\" aria-label=\"개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개요</h1>\n<p>이전 포스팅</p>\n<ol>\n<li><a href=\"https://brewagebear.github.io/linux-kernel-internal-1/\">[Kernel] 리눅스 스케줄링 매커니즘과 Load Average</a></li>\n</ol>\n<p>이전 내용에서는 커널을 이해하기 위한 배경지식과 더불어, <code class=\"language-text\">top</code>에서 나타내는 지표들을 읽는 법 그리고 Load Average가 어떤 부분을 나타내는 지 중점적으로 알아보았다.</p>\n<p>이번 내용에서는 리눅스 내부 메모리 관리에 대해서 중점적으로 다룬 후 <code class=\"language-text\">free</code> 와 <code class=\"language-text\">proc/meminfo</code> 가 나타내는 지표들에 대해서 보고자 한다. 그 전에 앞서 역시 이 부분 또한, 배경지식이 필요하다보니 배경지식에 대해서 다루고, 메모리와 관련된 지표들에 대한 내용을 다뤄보고자 한다.</p>\n<h2 id=\"step-1-서론\" style=\"position:relative;\"><a href=\"#step-1-%EC%84%9C%EB%A1%A0\" aria-label=\"step 1 서론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1. 서론</h2>\n<h2 id=\"step-11-가상-주소-공간\" style=\"position:relative;\"><a href=\"#step-11-%EA%B0%80%EC%83%81-%EC%A3%BC%EC%86%8C-%EA%B3%B5%EA%B0%84\" aria-label=\"step 11 가상 주소 공간 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.1 가상 주소 공간</h2>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/7uArXuJ.png\">\n</p>\n<p align=\"center\">\n    <em>그림 1. 리눅스의 가상 주소 공간 매핑 예시</em>\n</p>\n<p>이전 장에서 이러한 그림을 토대로 가상 주소 공간(Virtual Address Spaces, VAS)<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup> 에 대해서 간략하게 다뤘었다.  메모리 관리에 들어가기 앞서 가상 주소 공간에 대해서 좀 더 알 필요가 존재하여 이에 대해서 다뤄보고자 한다.</p>\n<p>이를 이해하기 위해서는 먼저 중요한 구조체 몇개를 파악할 필요가 있다.</p>\n<h2 id=\"step-12-task_struct와-mm_struct에-대한-이해\" style=\"position:relative;\"><a href=\"#step-12-task_struct%EC%99%80-mm_struct%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%B4%ED%95%B4\" aria-label=\"step 12 task_struct와 mm_struct에 대한 이해 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.2 task_struct와 mm_struct에 대한 이해</h2>\n<p><code class=\"language-text\">task_struct</code>는 이전 포스팅에서 Run Queue를 다루면서 잠깐 설명을 했었던 적이 있다.\n이 <code class=\"language-text\">task_struct</code> 구조체는 리눅스 커널에서 매우 중요한 구조체이므로, 이야기를 하고 넘어가고자 한다.</p>\n<p>먼저, 리눅스에서는 작업의 기본 단위를 태스크(Task)라 부른다. 태스크는 프로세스와 동치되는 개념이라고 생각하면 된다.\n운영체제도 소프트웨어다보니 이 태스크를 나타내거나 처리할 자료구조가 필요할 것이다. 그것이 <code class=\"language-text\">task_struct</code> 이다.</p>\n<p>근데, 여기서만 이야기를 끝내면 안된다. 학부생때 운영체제 과목을 수강했다면 프로세스 제어 블록(Process Control Block, PCB)<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup> 라는 단어를 들었던 기억이 어렴풋이 날 것이다.</p>\n<p>그  PCB도 <code class=\"language-text\">task_struct</code> 라는 구조체로 구현이 된다. 따라서, 기본 작업인 태스크와 PCB도 모두 <code class=\"language-text\">task_struct</code> 라는 구조체로 이뤄진다는 점이다.</p>\n<p>그렇다면 쓰레드의 경우에는 어떨까? 이는 운영체제에 따라 다르다.</p>\n<ul>\n<li>Windows (NT Kernel)</li>\n</ul>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/qrf20s5.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://linux-kernel-labs.github.io/refs/heads/master/lectures/processes.html\">그림 2. Windows 커널의 쓰레드 구조, The Linux Kernel(5.10.14), Processes </a></em>\n</p>\n<p>윈도우즈의 경우를 본다면, 위 그림과 같이 <code class=\"language-text\">Thread list</code>에 각 쓰레드 구조에 대한 포인터가 등록되는 식으로 관리된다고 보면 된다.  그러나, 리눅스의 경우에는 아래 그림과 같다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/qrf20s5.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://i.imgur.com/c9oEUO6.png\">그림 3. Linux 커널의 쓰레드 구조, The Linux Kernel(5.10.14), Processes </a></em>\n</p>\n<p>위 그림은 같은 프로세스 내에 쓰레드가 2개가 있다고 가정한 모습이다. 각 쓰레드 또한 <code class=\"language-text\">task_struct</code>를 활용하여 구현되며 단순히 같은 프로세스 내의 쓰레드라면 동일한 리소스 구조 인스턴스를 가르킬 뿐이다.</p>\n<p>실제 <code class=\"language-text\">task_struct</code> 코드 중에서 중요한 부분만 발췌하면 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// https://github.com/torvalds/linux/blob/master/include/linux/sched.h#L743</span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">task_struct</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">thread_info</span>\t\tthread_info<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span>\t\t\t__state<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">sched_info</span>\t\tsched_info<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">list_head</span>\t\ttasks<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">mm_struct</span>\t\t<span class=\"token operator\">*</span>mm<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">mm_struct</span>\t\t<span class=\"token operator\">*</span>active_mm<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 코드에서 중점적으로 볼 내용은 <code class=\"language-text\">mm_struct</code> 이다.  태스크도 <code class=\"language-text\">task_struct</code> 를 통해서 만들어진다고 하였는데 그렇다면 우리가 기존에 알고 있던 <code class=\"language-text\">stack</code> , <code class=\"language-text\">heap</code> 영역은 어디에 할당되는지 궁금하지 않은가?</p>\n<p>그 공간이 바로 <code class=\"language-text\">mm_struct</code> 구조체로 관리된다. 이 구조체는 가상 주소 공간을 관리하기 위한 여러 정보를 포함하고 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// https://github.com/torvalds/linux/blob/master/include/linux/mm_types.h#L598</span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">mm_struct</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">maple_tree</span> mm_mt<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> start_code<span class=\"token punctuation\">,</span> end_code<span class=\"token punctuation\">,</span> start_data<span class=\"token punctuation\">,</span> end_data<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> start_brk<span class=\"token punctuation\">,</span> brk<span class=\"token punctuation\">,</span> start_stack<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 구조체도 매우 복잡한데 현재 설명할 내용과 관련된 필드는 위에 나온 정도라 보면된다. (<code class=\"language-text\">maple_tree</code>는 후에 설명한다.)</p>\n<ul>\n<li><code class=\"language-text\">start_code / end_code</code> : 프로세스의 코드 영역의 시작과 끝을 나타냄</li>\n<li><code class=\"language-text\">start_data / end_data</code> : 프로세스의 데이터 영역의 시작과 끝을 나타냄</li>\n<li><code class=\"language-text\">start_brk / brk</code> : 프로세스의 힙 영역의 시작과 끝을 나타냄</li>\n<li><code class=\"language-text\">start_stack</code> :  스택 영역의 시작을 나타냄</li>\n</ul>\n<p>이제 아래의 그림을 이해할 수 있을 것이다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/uef6DfS.png\">\n</p>\n<p align=\"center\">\n    <em>그림 4. 리눅스 가상 메모리 영역 시각화</em>\n</p>\n<p>프로세스 내부의 <code class=\"language-text\">mm_struct</code> 를 시각화한 그림이다. 우리가 힙 영역을 늘리고 싶다면, <code class=\"language-text\">brk()</code> 라는 시스템 콜을 통해서 늘리거나 줄일 수 있다.</p>\n<p><code class=\"language-text\">brk()</code> 시스템콜은 프로그램 브레이크(Program Break)<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup> 를 제어하는 시스템 콜이라고 보면 된다. 위에서 보면 알겠지만 <code class=\"language-text\">brk</code> 라는 값을 통해서 <code class=\"language-text\">heap</code> 크기를 늘리고 줄일 수 있는 것을 볼 수 있다.</p>\n<p>이 <code class=\"language-text\">brk()</code> 시스템 콜을 통해 프로그램 브레이크를 증가시키면, <strong>프로세스에 메모리가 할당</strong>되고 감소하면 <strong>프로세스의 메모리를 해제</strong>할 수 있는 것이다.</p>\n<h2 id=\"step-13-가상-메모리-영역virtual-memory-area-vma\" style=\"position:relative;\"><a href=\"#step-13-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%ADvirtual-memory-area-vma\" aria-label=\"step 13 가상 메모리 영역virtual memory area vma permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.3 가상 메모리 영역(Virtual Memory Area, VMA)</h2>\n<p>위 <code class=\"language-text\">mm_struct</code>필드 중에서 <code class=\"language-text\">maple_tree</code> 의 타입을 갖는 <code class=\"language-text\">mm_mt</code> 라는 값이 존재하였는데 이 부분도 중요하다보니 다루고자 한다.\n이를 이해하기 위해서는 이전 커널 버전을 볼 필요가 존재한다.</p>\n<ul>\n<li>6.1 이전 커널의 <code class=\"language-text\">mm_struct</code></li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">mm_struct</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">vm_area_struct</span> <span class=\"token operator\">*</span>mmap<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* list of VMAs */</span>\n\t\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">rb_root</span> mm_rb<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 레드블랙트리의 루트</span>\n\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre></div>\n<p>이러한 코드로 <code class=\"language-text\">vm_area_struct</code> 를 사용하였다.  그러나 6.5 이후는 위에서 본 코드와 같이 <code class=\"language-text\">*mmap</code> 부분이 <code class=\"language-text\">maple_tree</code>로 변경되었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">mm_struct</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">maple_tree</span> mm_mt<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre></div>\n<p>이에 대한 구체적인 내용은 아래 링크를 참고 바란다.</p>\n<ul>\n<li>참고 커밋 : <a href=\"https://github.com/torvalds/linux/commit/d4af56c5c7c6781ca6ca8075e2cf5bc119ed33d1#diff-dc57f7b72015cf5f95444ec4f8a60f85d773f40b96ac59bf55b281cd63c06142\">mm: start tracking VMAs with maple tree, Github</a></li>\n<li>참고 자료 : <a href=\"https://blogs.oracle.com/linux/post/the-maple-tree-a-modern-data-structure-for-a-complex-problem\">The Maple Tree, A Modern Data Structure for a Complex Problem, Oracle</a></li>\n</ul>\n<p><code class=\"language-text\">vm_area_struct</code>가 기존에는 레드블랙트리(<code class=\"language-text\">rbtree</code>)<sup id=\"fnref-6\"><a href=\"#fn-6\" class=\"footnote-ref\">6</a></sup> 로 추적되었는데  숫자 순서로 노드를 탐색하는 것이 효율적이지 않았고, 기존 락에 대한 문제점이 존재하였다고 한다.\n이에 대해서 새로운 데이터 구조가 필요하였고, 메이플트리(Maple Tree)<sup id=\"fnref-7\"><a href=\"#fn-7\" class=\"footnote-ref\">7</a></sup> 를 제안하였다고 한다.</p>\n<p><code class=\"language-text\">mm_mt</code> 값은 VMA를 순회를 할 때 사용된다고 보면 된다.  중요한 점은 <code class=\"language-text\">vm_area_struct</code> 로 관리되던게  <code class=\"language-text\">maple_tree</code> 로 변경되었다는 점이고, 실제 내부 값은 <code class=\"language-text\">vm_area_struct</code> 를 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// @mas : the maple state</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">vma_mas_store</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">vm_area_struct</span> <span class=\"token operator\">*</span>vma<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">ma_state</span> <span class=\"token operator\">*</span>mas<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이제, <code class=\"language-text\">vm_area_struct</code>에 대해 이해해보자.</p>\n<p>위에서 <code class=\"language-text\">mm_struct</code> 에 대해서 네 가지 구조로 나눌 수 있다고 말했었다.</p>\n<ol>\n<li>스택 영역</li>\n<li>힙 영역</li>\n<li>데이터 영역</li>\n<li>코드 영역</li>\n</ol>\n<p>이 영역들을 통틀어 <strong>가상 메모리 영역(Virtual Memory Area, VMA)</strong> 이라 한다. 즉, <code class=\"language-text\">vm_area_struct</code> 는 가상 메모리 영역에 대한 데이터 구조를 나타낸다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">//https://github.com/torvalds/linux/blob/master/include/linux/mm_types.h#L565</span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">vm_area_struct</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">union</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token comment\">/* VMA covers [vm_start; vm_end) addresses within mm */</span>\n\t\t\t<span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> vm_start<span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> vm_end<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">mm_struct</span> <span class=\"token operator\">*</span>vm_mm<span class=\"token punctuation\">;</span>\n\t<span class=\"token class-name\">pgprot_t</span> vm_page_prot<span class=\"token punctuation\">;</span>          <span class=\"token comment\">/* Access permissions of this VMA. */</span>\n\t\n\t<span class=\"token keyword\">union</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">const</span> <span class=\"token class-name\">vm_flags_t</span> vm_flags<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token class-name\">vm_flags_t</span> __private __vm_flags<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">list_head</span> anon_vma_chain<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* Serialized by mmap_lock &amp;  page_table_lock */</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">anon_vma</span> <span class=\"token operator\">*</span>anon_vma<span class=\"token punctuation\">;</span>\t<span class=\"token comment\">/* Serialized by page_table_lock */</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> vm_pgoff<span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">/* Offset (within vm_file) in PAGE_SIZE units */</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">file</span> <span class=\"token operator\">*</span> vm_file<span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">/* File we map to (can be NULL). */</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\t\n</code></pre></div>\n<p>중요한 필드 몇 가지만 봐보자.</p>\n<ul>\n<li><code class=\"language-text\">vm_start, vm_end</code> : VMA 영역의 시작 주소와 끝 주소를 나타냄 (<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>M</mi><msub><mi>A</mi><mrow><mi>S</mi><mi>I</mi><mi>Z</mi><mi>E</mi></mrow></msub><mo>=</mo><mi>V</mi><msub><mi>M</mi><mrow><mi>E</mi><mi>N</mi><mi>D</mi></mrow></msub><mo>−</mo><mi>V</mi><msub><mi>M</mi><mrow><mi>S</mi><mi>T</mi><mi>A</mi><mi>R</mi><mi>T</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">VMA_{SIZE} = VM_{END} - VM_{START }</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">ZE</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">EN</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">ST</span><span class=\"mord mathnormal mtight\">A</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">RT</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>)</li>\n<li><code class=\"language-text\">*vm_mm</code> : 해당 VMA가 속해있는 <code class=\"language-text\">mm_struct</code>를 나타낸다.</li>\n<li><code class=\"language-text\">vm_page_prot</code> : 해당 VMA에 접근하고자할 경우에 대한 권한 값 (read only, rw 등)</li>\n<li><code class=\"language-text\">vm_flags</code> : <code class=\"language-text\">vm_page_prot</code>의 권한 하위 집합을 지정할 수 있다. (<code class=\"language-text\">VM_READ | VM_WRITE | VM_GROWS_DOWN</code> 등..)\n<ul>\n<li>참고 : <a href=\"https://itecnote.com/tecnote/linux-vm_flags-vs-vm_page_prot/\">Linux – vm_flags vs vm_page_prot, iTecNote</a></li>\n</ul>\n</li>\n</ul>\n<p>이 후 값은 MMIO에 대한 이해가 필요하니 이전 포스팅에서 익명 매핑(Anonymous Mapping)과 파일 매핑(File-backed Mapping)에 대해서 알고 오길 추천드린다.</p>\n<p>위에서 <code class=\"language-text\">anon_vma, anon_vma_chain</code> 은 익명 매핑 시에 사용되고, <code class=\"language-text\">vm_pgoff, vm_file</code>은 파일 매핑 시에 사용이 된다.</p>\n<p>두 가지 구조로 따로 나눈 이유는 역방향 매핑과 관련되어 있는데 이 부분은 페이징때 자세히 다루도록 하고 간단하게 링크만 달아두도록 하겠다.</p>\n<ul>\n<li>\n<p><code class=\"language-text\">vm_file</code> : 파일 매핑을 사용할 경우 사용되는 실제 파일에 대한 링크를 갖는 구조체</p>\n</li>\n<li>\n<p><code class=\"language-text\">vm_pageoff</code> : 해당 파일 내의 offset을 나타낸다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">anon_vma</code> : 익명 매핑을 사용할 경우 사용되는 구조체</p>\n</li>\n<li>\n<p><code class=\"language-text\">anon_vma_chain</code> : <code class=\"language-text\">anon_vma</code> 만 사용하였을 경우 문제점을 해결하기 위해 도입된 필드</p>\n</li>\n</ul>\n<blockquote>\n<p>익명 역 매핑(Anonymous Page Reverse Mapping) 매커니즘은 페이지 매핑을 해제한 후 매핑될 PTE(Page Table Entry)<sup id=\"fnref-9\"><a href=\"#fn-9\" class=\"footnote-ref\">9</a></sup> 찾기 위해 전체 연결 목록인 <code class=\"language-text\">vma</code>에 액세스한 후 순회하여 연결 목록에 액세스하는데 <code class=\"language-text\">fork()</code>를 통해 복사된 하위 프로세스에서 쓰기 액세스가 발생하면 <code class=\"language-text\">vma</code>에 새 익명 페이지가 할당되고, <code class=\"language-text\">vma</code>는 이 익명 페이지를 가르키게 되는데 이 페이지가 <code class=\"language-text\">vma</code>에 반영되지 않는 문제점이 존재하였음.</p>\n</blockquote>\n<ul>\n<li>참고 : <a href=\"https://www.sobyte.net/post/2022-08/linux-anonymous-pages-reverse-mapping/\">Reverse mapping of anonymous pages in Linux, SoByte</a></li>\n</ul>\n<p>리눅스 커널에서 프로세스가 할당되어 사용되는 구조를 각 구조체를 통해서 나타내면 아래와 같다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/sRBzgjS.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://cs4118.github.io/www/2023-1/lect/21-linux-mm.html#struct-vm_area_struct-source-code\">그림 5. Virtual address space with kernel data structures, COMS W4118 Operating Systems 1 - Columbia univ, 2023</a></em>\n</p>\n<p><code class=\"language-text\">vm_next, vm_prev</code> 는 메이플 트리 도입<sup id=\"fnref-9\"><a href=\"#fn-9\" class=\"footnote-ref\">9</a></sup> 이후로 삭제가 되었고, <code class=\"language-text\">mm_struct</code>가 가르키는 것이 <code class=\"language-text\">mmap</code> 이 아니라 <code class=\"language-text\">mm_mt</code>로 변경되긴 해야겠지만 전반적인 큰 틀은 흡사하므로 이해할 수 있을 것이다.</p>\n<p>해당 그림을 이해를 못하겠다면 다시 한번 읽어보는 것을 추천드린다.  위에서 강조한 내용처럼 <strong>지금까지 다룬 구조체들은 커널에서 가장 중요한 구조체들</strong>이다.</p>\n<h2 id=\"step-14-프로세스가-가상-주소-공간에-매핑되는-방식\" style=\"position:relative;\"><a href=\"#step-14-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EA%B0%80-%EA%B0%80%EC%83%81-%EC%A3%BC%EC%86%8C-%EA%B3%B5%EA%B0%84%EC%97%90-%EB%A7%A4%ED%95%91%EB%90%98%EB%8A%94-%EB%B0%A9%EC%8B%9D\" aria-label=\"step 14 프로세스가 가상 주소 공간에 매핑되는 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.4 프로세스가 가상 주소 공간에 매핑되는 방식</h2>\n<p>우리는 위에서 커널에서 중요한 구조 중 하나인 <code class=\"language-text\">task_struct</code> 와 <code class=\"language-text\">mm_struct</code>, <code class=\"language-text\">vm_area_struct</code> 에 대해 알아보았다.\n이제 이 개념이 왜 중요한지 알아보도록 한다. 일단, 이를 위해서는 매핑되는 방식에 대해서 이해 해야한다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/C9mJAyt.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://cs4118.github.io/www/2023-1/lect/21-linux-mm.html#process-virtual-address-space-re-revisited\">그림 6. virtual address space diagram, COMS W4118 Operating Systems 1 - Columbia univ, 2023</a></em>\n</p>\n<p>실제 가상 주소 공간에 매핑되는 구조를 나타낸 그림이다. 매핑 방식은 2가지 방식이 있다.</p>\n<ol>\n<li>간접 매핑(Indirect Mapping) : 가상 주소와 물리 주소 사이의 매핑이 페이지 테이블(Page Table)<sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup> 을 통해서 이뤄지는 구조이다. (OS와 하드웨어가 주소 변환을 수행해야함.)</li>\n<li>직접 매핑(Direct Mapping, Linear Mapping) : 직접 매핑은 가상 주소와 물리 주소 사이에서 선형적(Linear)으로 이뤄진다. 리눅스 커널의 일부는 커널 코드와 데이터, 시스템 테이블 등을 저장하는데 이용되며 모든 프로세스에 대해 공유된다. (선형적으로 매핑되어서 보다 단순함.)</li>\n</ol>\n<blockquote>\n<p>💡 직접 매핑에서 나온 선형적으로 매핑이 이뤄진다는 뜻은 가상 주소가 0x1000이고, 물리 주소 0x2000에 매핑되었다면 선형 매핑을 사용하면 가상 주소 0x1004는 물리 주소 0x2004에 매핑이 된다.</p>\n</blockquote>\n<p>또한, 모든 프로세스는 커널 코드 &#x26; 데이터 영역에 대한 공유를 하기 위해 직접 매핑된 값들이 존재한다.\n그렇다면 왜 이런식으로 나누었을까?</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/3JkVM2I.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://linux-kernel-labs.github.io/refs/heads/master/lectures/address-space.html#linux-address-space\">그림 7. Dedicated, Shared Address Space, The Linux Kernel(5.10.14), Linux Address Space</a></em>\n</p>\n<p>우리는 알다시피 유저 공간과 커널 공간이 나눠져있다는 점을 알고 있다.  위 그림은 그 공간을 나누는 방식에 대한 방식을 나타낸다.\n(a)는 전용 주소 공간(Dedicated Address Spaces)를 뜻하며, (b)는 공유 주소 공간을 분할(Split a Shared Address Space)하는 것을 보여준다.</p>\n<p>이는 각각 장, 단점이 존재한다.</p>\n<ul>\n<li>전용 커널 공간의 단점(a) : 모든 시스템 호출에 대한 TLB 완전 무효화</li>\n<li>공유 주소 공간의 단점(b) : 커널 및 사용자 프로세스 모두를 위한 주소 공간 자체가 감소</li>\n</ul>\n<p>과거에는 (a)의 형태가 많았지만 주로 (b)와 같이 공유 주소 공간을 분할하는 식으로 사용한다. (특히, 64bit 환경은 항상 공유 주소 공간으로 처리된다 한다.)</p>\n<p>공유 주소 공간을 사용하는 아키텍처라고 가정했을 때, 각 공간은 아래의 특징을 갖는다.</p>\n<ul>\n<li><strong>유저 공간(User Space) : 권한 있는 작업을 수행하거나 하드웨어에 직접 액세스를 할 수 없다.</strong></li>\n<li><strong>커널 공간(Kernel Space) : 권한 있는 작업을 수행할 수 있으며 하드웨어에 대한 전체 액세스 권한이 있다.</strong></li>\n</ul>\n<p>따라서, CPU에서 <strong>어떤 작업을 유저 공간에서 수행 중에 권한이 필요한 작업이 존재하면 커널 공간에 요청을 해야한다</strong>.</p>\n<p>예를 들어, 유저 공간에 <code class=\"language-text\">read()</code> 혹은 <code class=\"language-text\">write()</code> 와 같이 시스템 콜이 발생한다고 가정하면 아래와 같은 플로우로 흘러간다.</p>\n<ol>\n<li>유저 공간에서 데이터로 복사하려면 커널 버퍼의 가상 주소를 사용한다.</li>\n<li>페이지 테이블을 이동하여 커널 버퍼의 가상 주소를 물리적 주소로 변환한다.</li>\n<li>커널 버퍼의 물리적 주소를 사용하여 DMA 전송을 시작한다.</li>\n</ol>\n<p>근데, 만약 커널 공간이 <strong>직접 매핑이 되어있다면 2번에 대한 작업이 축소가 되어서 아래와 같이 처리가 가능</strong>할 것이다.</p>\n<ol>\n<li>가상 주소 공간에서 물리적 주소 공간으로의 변환이 페이지 테이블을 통해서 처리되는 대신 한번에 처리가 가능하다.</li>\n<li>페이지 테이블을 만드는 데 사용되는 메모리가 적어진다.</li>\n<li>커널 메모리에 사용되는 TLB(Translation Look-aside Buffer)<sup id=\"fnref-5\"><a href=\"#fn-5\" class=\"footnote-ref\">5</a></sup> 항목 수 감소</li>\n</ol>\n<p>그래서 실제로 가상 주소 공간은 아래와 같이 분할되어 사용된다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/fxDD1wV.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://cs4118.github.io/www/2023-1/lect/21-linux-mm.html#struct-page-source-code\">그림 9. Users, Kernel Space Diagram, COMS W4118 Operating Systems 1 - Columbia univ, 2023</a></em>\n</p>\n<p>커널 공간은 대부분 직접매핑이 되어 쓰이고(<code class=\"language-text\">Lowmem</code> 부분), 아주 일부분은 간접매핑되어 쓰인다. (<code class=\"language-text\">Highmem</code>)\n이 부분은 <code class=\"language-text\">Slab</code> 을 다룰 때 다뤄볼 예정이다.</p>\n<p>어찌됐든 간에 중요한 점은 유저 공간과 커널 공간이 공유 주소 공간을 사용하여 일정 부분 별로 나눠져있고, 이에 대해 직, 간접 매핑을 활용하여 각자의 장단점을 누릴 수 있게끔 설계되었다는 점이 중요하다.</p>\n<h2 id=\"step-14-페이지와-페이지-캐시\" style=\"position:relative;\"><a href=\"#step-14-%ED%8E%98%EC%9D%B4%EC%A7%80%EC%99%80-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C\" aria-label=\"step 14 페이지와 페이지 캐시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.4 페이지와 페이지 캐시</h2>\n<h3 id=\"step-141-페이지\" style=\"position:relative;\"><a href=\"#step-141-%ED%8E%98%EC%9D%B4%EC%A7%80\" aria-label=\"step 141 페이지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.4.1 페이지</h3>\n<p>나중에 페이징을 별도로 포스팅할 예정인데 그 전에 리눅스 메모리 관리에 이해하려면 어찌됐든 페이지에 대해서 알긴 해야되서 간단하게 코드만 보고자 한다.</p>\n<p>각 물리적 프레임(Physical Frame)<sup id=\"fnref-11\"><a href=\"#fn-11\" class=\"footnote-ref\">11</a></sup>은 <code class=\"language-text\">struct page</code>라 부르는 페이지 값을 가지게 되는데 이 값은 물리적 프레임에 대한 메타데이터를 담고 있다.</p>\n<p>실제로 글로벌 메모리를 설정하는 부분에 전역 배열로 <code class=\"language-text\">struct page</code> 값을 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// https://github.com/torvalds/linux/blob/master/mm/memory.c#L102</span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">page</span> <span class=\"token operator\">*</span>mem_map<span class=\"token punctuation\">;</span></code></pre></div>\n<p>커널은 모든 물리적 프레임을 <code class=\"language-text\">mem_map</code>에 저장한다. 그러나, 이에 직접 접근하는 것은 좋은 방법은 아니기에 다양한 메서드들을 제공(<code class=\"language-text\">virt_to_page(), kmap(), kunmap()</code> 등…)하는데 이는 <code class=\"language-text\">struct page</code>를 살펴보고 알아볼 예정이다.</p>\n<p>이제 <code class=\"language-text\">struct page</code> 에서 중요한 필드들을 확인해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">https<span class=\"token operator\">:</span><span class=\"token comment\">//github.com/torvalds/linux/blob/master/include/linux/mm_types.h#L74C8-L74C12</span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">page</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">union</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\t<span class=\"token comment\">/* Page cache and anonymous pages */</span>\n\t\t\t<span class=\"token comment\">/**\n\t\t\t * @lru: Pageout list, eg. active_list protected by\n\t\t\t * lruvec->lru_lock.  Sometimes used as a generic list\n\t\t\t * by the page owner.\n\t\t\t */</span>\n\t\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t\t\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">list_head</span> lru<span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t\t\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">address_space</span> <span class=\"token operator\">*</span>mapping<span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t\t\t<span class=\"token class-name\">pgoff_t</span> index<span class=\"token punctuation\">;</span>\t\n\t\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token class-name\">atomic_t</span> _refcount<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>virtual<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">_refcount</code> : 페이지의 레퍼런스 카운트를 뜻하며, <code class=\"language-text\">page_count()</code> 로 접근할 수 있다.</li>\n<li><code class=\"language-text\">lru</code> : LRU 캐시 교체(Cache replacement policies) 정책을 수행하는 Linux 데이터 구조의 항목이다.</li>\n<li><code class=\"language-text\">*mapping, index</code> : 위에서 다루었던 익명(Annoymous), 파일(File-backed) 매핑과 관련된 필드이다.</li>\n<li><code class=\"language-text\">*virtual</code> :물리적 프레임에 대응하는 커널 가상 주소</li>\n</ul>\n<p>이제 페이지 매핑과 관련해서 보도록하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">https<span class=\"token operator\">:</span><span class=\"token comment\">//github.com/torvalds/linux/blob/master/arch/arm/include/asm/memory.h#L318-L328</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">inline</span> <span class=\"token class-name\">phys_addr_t</span> <span class=\"token function\">virt_to_phys</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>x<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">inline</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">phys_to_virt</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">phys_addr_t</span> x<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre></div>\n<p>해당 함수는 물리적 주소를 가상 주소로 변환(<code class=\"language-text\">*phys_to_virt</code>)하거나 가상 주소를 물리적 주소로 변환(<code class=\"language-text\">virt_to_phys</code>)로 하는 작업을 해준다.</p>\n<p>이제 아래의 그림을 다시 봐보자.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/fxDD1wV.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://cs4118.github.io/www/2023-1/lect/21-linux-mm.html#struct-page-source-code\">그림 9. Users, Kernel Space Diagram, COMS W4118 Operating Systems 1 - Columbia univ, 2023</a></em>\n</p>\n<p>위 그림은 32bit 4GB 가상 주소 공간을 가정한 것이다. 전통적으로 3:1의 비율(유저공간:커널공간)로 분할되게 된다. (64bit는 달라질 수 있음)</p>\n<p><code class=\"language-text\">Highmem</code> 영역에서 프레임을 사용하기 위해서는 <code class=\"language-text\">struct page</code>를 <code class=\"language-text\">kmap()</code>을 사용해야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">//https://github.com/torvalds/linux/blob/master/include/linux/highmem.h#L37-L46</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">inline</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">kmap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">page</span> <span class=\"token operator\">*</span>page<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">inline</span> <span class=\"token keyword\">void</span> <span class=\"token function\">kunmap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">page</span> <span class=\"token operator\">*</span>page<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이 메서드는 <code class=\"language-text\">Highmem</code> 프레임을 <code class=\"language-text\">Lowmem</code>에 있는 것처럼 참조할 수 있도록 매핑을 생성하며, 이미 사용하고자하는 프레임이 <code class=\"language-text\">Lowmem</code>에 존재한다면 주소를 반환한다.</p>\n<p>이와 같은 <strong>메서드를 통해 프레임이 메모리에서 어디있는지 걱정하지 않고 사용</strong>할 수 있게 된다.\n그러나, 이 매핑에도 제한적인 부분이 존재하므로 <code class=\"language-text\">kunmap()</code> 을 통해서 매핑을 해제해줘야한다.</p>\n<h3 id=\"step-142-페이지-캐시\" style=\"position:relative;\"><a href=\"#step-142-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C\" aria-label=\"step 142 페이지 캐시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.4.2 페이지 캐시</h3>\n<p>위에서 잠깐 페이지에 대해서 다뤘는데 이제 페이지 캐시(Page Cache)<sup id=\"fnref-12\"><a href=\"#fn-12\" class=\"footnote-ref\">12</a></sup> 에 다뤄보고자 한다. 위에서 <code class=\"language-text\">vm_area_struct</code> 를 볼 때 아래와 같은 필드가 존재하였었다.\n<code class=\"language-text\">struct file * vm_file;</code> 여기서 <code class=\"language-text\">struct file</code>은  <code class=\"language-text\">struct inode</code> 의 참조 값이라 보면 된다. 그리고 <code class=\"language-text\">struct inode</code>는 내부에 <code class=\"language-text\">struct address_space *i_mapping</code> 과 같은 값을 갖고 있다.</p>\n<p>이것은 <code class=\"language-text\">inode</code>와 관련된 파일의 모든 프레임에 대한 참조이다. 이 구조는 <strong>파일 매핑만 사용하는 것이 아니라 캐시된 페이지를 보유</strong>할 수 있다.</p>\n<p>운영체제를 공부하셨던 분이라면 읽고 쓰는 작업이 항상 디스크까지 가서 확인하는 것은 아니라는 점을 알고 있을 것이다.\n그것이 가능한 이유는 캐시를 통해서 이미 한번 읽어드렸으면 잠시 메모리 영역에 들고 있게끔해서 디스크까지 내려가지않고 다시 읽게끔한다는 식으로 동작한다는 것을 말이다.</p>\n<p>그것이 <strong>바로 페이지 캐시의 역할</strong>이다. 이를 읽기와 쓰기를 나눠서 플로우를 살펴보자.</p>\n<ul>\n<li>\n<p><strong>읽기 작업 발생 시</strong></p>\n<ol>\n<li><code class=\"language-text\">read()</code> 시스템 콜 발생</li>\n<li>페이지 캐시가 존재한다면 -> 페이지 캐시를 리턴</li>\n<li>페이지 캐시가 존재하지 않는다면 -> 디스크에서 데이터를 읽고, 해당 데이터에 대한 페이지 할당 후에 <code class=\"language-text\">address_space</code>에 연결하여 캐싱</li>\n</ol>\n</li>\n<li>\n<p><strong>쓰기 작업 발생 시</strong></p>\n<ol>\n<li><code class=\"language-text\">write()</code> 시스템 콜 발생</li>\n<li>페이지 캐시가 존재하든 안하든 -> 페이지 캐시에 기록 및 페이지를 dirty로 표시(이것이 더티 페이지이다.)</li>\n<li><code class=\"language-text\">sync()</code> 를 통해서 디스크에 기록</li>\n</ol>\n</li>\n</ul>\n<p>쓰기 작업 부분은 페이지 캐시가 존재하든 안하든 결국 메모리에 캐시를 생성하는데 이를 write-back 캐시라 한다. 요청 시 캐시와 디스크에 동시 기록하는 것을 write-through 캐시라 부른다.\n리눅스는 기본적으로 write-back 캐시의 방식을 따른다고 알고있다.</p>\n<p>쓰기 작업 부분은 다른 포스팅에서도 다뤘는데 자세한 내용은 아래의 링크를 참고바란다.</p>\n<ul>\n<li>참고 : <a href=\"https://brewagebear.github.io/fundamental-os-page-cache/#step-221-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%99%80-%EB%8D%94%ED%8B%B0-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%8F%99%EA%B8%B0%ED%99%94\">페이지 캐시와 더티 페이지 동기화</a></li>\n</ul>\n<p>이 뿐만 아니라 하나더 봐야하는 작업이 있다 바로, MMIO 관련 작업이다.</p>\n<ul>\n<li><strong>MMIO 작업과 관련된 페이지 캐시</strong>\n<ol>\n<li>파일 매핑(File-backed Mapping)을 사용하는 경우에 페이지 캐시를 사용한다.\n<ul>\n<li>새로운 VMA가 생성 된 후 파일 내용이 메모리로 전달되려할 때 페이지 폴트가 발생 하고, 페이지 캐시의 페이지는 해당 작업의 페이지 테이블에 인입된다.</li>\n</ul>\n</li>\n<li><code class=\"language-text\">MAP_SHARED</code> 로 페이지를 공유하고 있는 경우에는 페이지 캐시의 동일한 페이지를 대상으로 동작한다.</li>\n</ol>\n</li>\n</ul>\n<p>시각화하면 다음과 같을 것이다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/eDm8R8E.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://cs4118.github.io/www/2023-1/lect/21-linux-mm.html#page-cache-visualized\">그림 10. Page Cache Visualized, COMS W4118 Operating Systems 1 - Columbia univ, 2023</a></em>\n</p>\n<h3 id=\"step-143-페이지-교체-정책\" style=\"position:relative;\"><a href=\"#step-143-%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-%EC%A0%95%EC%B1%85\" aria-label=\"step 143 페이지 교체 정책 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.4.3 페이지 교체 정책</h3>\n<p>페이징에서 정책에 대해서 좀 더 다룰 내용이라 여기서는 LRU 정책<sup id=\"fnref-13\"><a href=\"#fn-13\" class=\"footnote-ref\">13</a></sup>에 대해서만 다루고자 한다.\nLRU(Least Recently Used)의 약어로 잘 안쓰였던 페이지부터 교체하는 방식이다.</p>\n<p>리눅스 페이지는 LRU/2로 알려진 2Q 교체 정책을 사용한다.</p>\n<p>기존 LRU 알고리즘은 아래와 같은 패턴으로 사용할 경우 성능이 나쁘다고 볼 수 있다.</p>\n<blockquote>\n<p>한 프로세스가 큰 파일을 매핑 후 한번 읽은 후 다시 절대로 사용하지 않는다고 가정하자\n만약, 이 파일을 매핑하기 위해서 캐시 전체를 교체를 한 후 이 파일 1개만 있다면 어떻게 될까?\n이러한 일회성 액세스에 대해서 캐시를 보호하는 작업이 필요할 것이다.</p>\n</blockquote>\n<p>그림으로 봐보자.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/eMDgcCM.png\">\n</p>\n<p align=\"center\">\n    <em>그림 11. LRU 성능 최악의 케이스</em>\n</p>\n<p>이런식의 상황이다. 근데 이 파일은 절대로 접근하지 않는다고 가정한다. 그러면 다시 해당 캐시가 방출될 것이다.\n그러면, 기존에 자주 접근할 수도 있는 캐시 자체가 날라가버리니 다시 이 웜업하는데 시간이 많이 걸릴 것이다.</p>\n<p>이러한 문제를 해결 하기위해서 LRU/2라는 개념이 도입된 것이다.\n이 개념은 아주 간단하다. 캐시를 관리하는 리스트를 2개를 두는 것이다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/X0aMm4K.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://biriukov.dev/docs/page-cache/4-page-cache-eviction-and-page-reclaim/#theory\">그림 12. LRU/2, Viacheslav Biriukov</a></em>\n</p>\n<ol>\n<li>비활성 LRU 리스트(Inactive LRU List)\n<ul>\n<li>초기 페이지 부재가 발생한 후 페이지 캐시로 등록하고자하면 비활성 리스트에 인입되게 된다.</li>\n<li>이후 어떤 페이지가 자주 참조가 발생하면 활성 LRU 리스트로 승격(promotion)시킨다.</li>\n</ul>\n</li>\n<li>활성 LRU 리스트(Active LRU List)\n<ul>\n<li>자주 사용하지 않는 페이지가 발생하면 비활성 LRU 리스트로 좌천(demotion)된다.</li>\n<li>이때 좌천이 발생할 경우 <code class=\"language-text\">flush()</code> 가 호출되어 실제 디스크에 기록이 된다.</li>\n</ul>\n</li>\n</ol>\n<p>참고로, 이 구조는 MySQL의 버퍼풀이 그대로 따르고 있으니 참고해보기 바란다.</p>\n<ul>\n<li>참고 : <a href=\"https://omty.tistory.com/58\">MySQL Innodb Buffer Pool 구조 및 캐시 전략, 고양이 중독</a></li>\n</ul>\n<h2 id=\"step-2-본론\" style=\"position:relative;\"><a href=\"#step-2-%EB%B3%B8%EB%A1%A0\" aria-label=\"step 2 본론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2. 본론</h2>\n<p>역시나 이전 포스팅과 같이 어떠한 개념을 이해하기 위해서 배경지식이 많이 필요하였다.\n대충 위의 배경지식을 이해하였더라도 이제 본론의 내용에 대해서 충분히 숙지할 수 있는 기본 지식이 갖춰졌다고 생각한다.</p>\n<p>이번에 보려고 하는 내용은 <code class=\"language-text\">free</code> 명령어와 관련된 내용이다. 이 <code class=\"language-text\">free</code> 에 대한 내용을 다루기 위해서 멀리 돌아돌아왔다.\n이제 이 내용에 대해서 다뤄보겠다.</p>\n<h2 id=\"step-21-free-명령어-분석\" style=\"position:relative;\"><a href=\"#step-21-free-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%B6%84%EC%84%9D\" aria-label=\"step 21 free 명령어 분석 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.1 free 명령어 분석</h2>\n<p><code class=\"language-text\">free -m</code> 명령어는 아마도 다들 써본 명령어일 것이다. 명령어를 수행하면 아래와 같은 결과가 나온다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">ubuntu@ubuntu:~$ free -m\n               total        used        free      shared  buff/cache   available\nMem:            3911         129        3571           4         210        3632\nSwap:           3910           0        3910</code></pre></div>\n<p>하나씩 보도록 하자.</p>\n<ul>\n<li><code class=\"language-text\">used</code> : 시스템에서 사용하고 있는 메모리 양을 의미한다.</li>\n<li><code class=\"language-text\">free</code> : 시스템에서 사용하고 있지 않은 메모리 양을 의미한다.</li>\n<li><code class=\"language-text\">shared</code> : 프로세스 사이에 공유하고 있는 메모리 양을 의미한다.</li>\n<li><code class=\"language-text\">buff/cache</code> : 버퍼와 캐시 영역(페이지 캐시)의 총 메모리 양을 의미한다.</li>\n<li><code class=\"language-text\">available</code> : <code class=\"language-text\">buff/cache</code> 영역을 포함하여 사용하지 않는 영역의 메모리 양을 나타낸다. (그러나 단순 더하기는 아닌데 이건 밑에서 다룰 예정이다.)\n<ul>\n<li>원래는 <code class=\"language-text\">-/+ buffers/cache</code> 라는 지표가 Mem 라인 아래에 존재하였는데 <code class=\"language-text\">avaliable</code> 지표로 바뀌었다</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"step-211-buff와-cache-영역\" style=\"position:relative;\"><a href=\"#step-211-buff%EC%99%80-cache-%EC%98%81%EC%97%AD\" aria-label=\"step 211 buff와 cache 영역 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.1.1 buff와 cache 영역</h3>\n<p>페이지 캐시에 대해서 다룬 내용과 같이 매번 디스크 요청을 통해서 디스크를 읽는 행위는 비효율적이므로 페이지 캐시를 사용한다하였다.\n즉, 캐시 영역은 이 페이지 캐시가 할당된 영역이라고 봐도 된다.</p>\n<p>그렇다면 buff는 무엇을 나타낼까? 이 영역은 버퍼 캐시 혹은 버퍼 영역이라고도 부르며, <strong>블록 디바이스가 가지고 있는 블록 자체에 대한 캐시</strong>이다.\n사실 이 개념은 페이지 캐시도 동일하다. 커널 2.2 이전에는 두 영역이 분리되어있었지만 합치게 되면서 대부분 페이지 캐시가 담당하는 역할이 되었다.</p>\n<p>그럼에도 아직까지 버퍼 영역을 사용하는 부분이 있는데 아래의 그림을 잠깐 보자.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/DnIcuIh.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"\nhttps://lwn.net/Articles/736534/\">그림 13.The bio layer, LWN.net, 2017</a></em>\n</p>\n<p>보면 bio layer라는 추상화 계층이 껴있는 점을 볼 수 있다. 잠깐 위에서 보았던 페이지 캐시의 시각화 그림을 보자.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/eDm8R8E.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://cs4118.github.io/www/2023-1/lect/21-linux-mm.html#page-cache-visualized\">그림 10. Page Cache Visualized, COMS W4118 Operating Systems 1 - Columbia univ, 2023</a></em>\n</p>\n<p>보면 결국에는 <code class=\"language-text\">struct inode</code> 라는 값으로 관리가 되어지는 점을 볼 수가 있는데 실제 디스크에 쓰이게 될 경우에는 <code class=\"language-text\">struct bio</code> <sup id=\"fnref-14\"><a href=\"#fn-14\" class=\"footnote-ref\">14</a></sup> 라는 구조체로 변환되서 bio layer를 통해서 쓰여지게 된다.</p>\n<p>그런데, super block<sup id=\"fnref-15\"><a href=\"#fn-15\" class=\"footnote-ref\">15</a></sup>이나 inode block<sup id=\"fnref-15\"><a href=\"#fn-15\" class=\"footnote-ref\">15</a></sup> 과 같이 파일 시스템을 관리하기 위한 메타 데이터를 읽어올 경우에는 <code class=\"language-text\">struct bio</code> 를 사용하지 않고, 다이렉트로 디바이스 드라이버와 통신하여 디스크에 데이터를 읽어와서 페이지 캐시에 파일 내용을 채우게 된다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/s4CWITK.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.yes24.com/Product/Goods/44376723\">그림 14. 커널에서 사용하는 Page Cache와 Buffer Cache의 관계도, DevOps와 SE를 위한 리눅스 커널 이야기(강진우 저), 2017</a></em>\n</p>\n<p>즉, 페이지 캐시에서 데이터를 핸들링 하는 구조체는 <code class=\"language-text\">struct inode</code> 로 캐시 영역이나 버퍼 영역이든 동일한 구조체를 사용하지만 디스크 I/O 발생 시에 접근하는 영역에 따라 다른 구조체를 사용하는 것이다.</p>\n<h3 id=\"step-212-avaliable-지표\" style=\"position:relative;\"><a href=\"#step-212-avaliable-%EC%A7%80%ED%91%9C\" aria-label=\"step 212 avaliable 지표 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.1.2 avaliable 지표</h3>\n<p>위에서 캐시 영역과 버퍼 영역에 대해서 알게되었는데 <code class=\"language-text\">avaliable</code> 은 왜 이 두 영역을 제외한 가용 영역을 보여주게 되는 걸까?</p>\n<p><img src=\"https://i.imgur.com/ddqF2a0.png\" alt=\"\"></p>\n<p>이는 스왑관련하여 포스팅했을 때 사용했던 그림이다. 그때도 말했던 것처럼 리눅스 커널 자체는 메모리가 놀고 있는 것을 싫어하므로 다수를 캐시 영역으로 활용한다.\n위의 흐름을 보면 <strong>메모리가 부족할 경우 점점 캐시 영역을 반환하고 실제 메모리 할당을 늘리는 모습</strong>을 볼 수 있다.</p>\n<p>즉, <code class=\"language-text\">avaliable</code> 에서 <code class=\"language-text\">buff/cache</code> 부분을 포함하고, 계산하는 이유는 <strong>어차피 반환될 영역</strong>이기 때문이다.\n다시 <code class=\"language-text\">free</code> 명령어를 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">ubuntu@ubuntu:~$ free -m\n               total        used        free      shared  buff/cache   available\nMem:            3911         129        3571           4         210        3632\nSwap:           3910           0        3910</code></pre></div>\n<p>여기서 보면 단순히 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo>+</mo><mrow><mi>b</mi><mi>u</mi><mi>f</mi><mi>f</mi></mrow><mi mathvariant=\"normal\">/</mi><mrow><mi>c</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>e</mi></mrow><mo mathvariant=\"normal\">≠</mo><mi>a</mi><mi>v</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">free + {buff}/{cache} \\neq avaliable</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">ree</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">ff</span></span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">e</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">iab</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">e</span></span></span></span></span>  임을 볼 수 있는데 <code class=\"language-text\">avaliable</code>은 <code class=\"language-text\">buff/cache</code> 지표 중에서 즉시 반환될 수 있는 영역의 합이라 보면 된다.</p>\n<h2 id=\"step-22-procmeminfo-명령어-분석\" style=\"position:relative;\"><a href=\"#step-22-procmeminfo-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%B6%84%EC%84%9D\" aria-label=\"step 22 procmeminfo 명령어 분석 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.2 /proc/meminfo 명령어 분석</h2>\n<p>위에서는 <code class=\"language-text\">free</code> 에 대해서 다뤄봤었다.<code class=\"language-text\">free</code> 는 명령어 자체가 가용 메모리의 용량을 볼 수 있는 것에 초점이 맞춰져있어서 각 메모리가 시스템의 어느 부분에 사용되는지는 볼 수가 없다.\n이를 확인하기 위해서는 <code class=\"language-text\">/proc/meminfo</code> 명령을 사용하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">ubuntu@ubuntu:~/example$ cat /proc/meminfo\nMemTotal:        4005008 kB\nMemFree:         3651072 kB\nMemAvailable:    3715564 kB\nBuffers:           11096 kB\nCached:           180804 kB\nSwapCached:            0 kB\nActive:           100212 kB\nInactive:         123088 kB\nActive(anon):        568 kB\nInactive(anon):    43260 kB\nActive(file):      99644 kB\nInactive(file):    79828 kB\n...\nSwapTotal:       4004860 kB\nSwapFree:        4004860 kB\nDirty:                 0 kB\n...\nSlab:              59648 kB\nSReclaimable:      24508 kB\nSUnreclaim:        35140 kB\n...</code></pre></div>\n<p>모든 지표는 다루지 않고 중요한 지표만 몇개 다루고자 한다.</p>\n<ul>\n<li><code class=\"language-text\">SwapCached</code> : 스왑-아웃으로 스왑영역에 있다가 다시 스왑-인으로 캐시 영역으로 돌아온 영역</li>\n<li><code class=\"language-text\">Active(anon)</code> : MMIO에 대해서 파일 매핑된 영역이 아니라 익명 매핑된 영역에 대해서 나타내며, 위에서 LRU/2에서 본 활성 리스트라고도 봐도 무방하다. (따라서, 스와핑의 대상이 아님)</li>\n<li><code class=\"language-text\">Inactive(anon)</code> : 이 경우에는 비활성 리스트라고 보면되고, 스와핑이 발생할 수 있다.</li>\n<li><code class=\"language-text\">Active(file)</code> : MMIO 중에 파일 매핑된 케이스를 나타낸다. 위에서 본 <code class=\"language-text\">buff/cache</code> 영역이 여기에 속하며, 활성 리스트에 속한 데이터다. (따라서, 스와핑의 대상이 아님)</li>\n<li><code class=\"language-text\">Inactive(file)</code> : 위와 동일하며 차이는 비활성 리스트에 속해있고, 스와핑이 발생할 수 있다.</li>\n<li><code class=\"language-text\">Dirty</code> : 위에서 페이지 캐시 쓰기 방식을 다룰 때 더티 페이지를 얘기했는데 <code class=\"language-text\">Dirty</code> 메모리는 그 과정에 사용하는 영역이다.</li>\n</ul>\n<p>이전 포스팅에서 <code class=\"language-text\">malloc()</code> 을 통한 예제를 다뤘었는데 <code class=\"language-text\">malloc()</code> 은 또한 익명 매핑을 활용한다고 얘기하였다.</p>\n<blockquote>\n<p>💡 이제는 왜 malloc()이 익명 매핑을 활용하는 것인지 이해가 될 것이다. (이해가 안간다면 다시 서론부터 보고 오자.)\n서론을 보기 싫다면 설명을 해보겠다. 그 이유는 heap 영역 자체가 익명 매핑으로 되어있기 때문이다.\nmalloc()은 힙 영역의 메모리 할당을 늘리는 것이므로, 프로그램 브레이크를 늘리는 식으로 메모리 할당을 할 것이다. 따라서, malloc()은 익명 매핑 기반이다.</p>\n</blockquote>\n<p>이제 실제 <code class=\"language-text\">/proc/meminfo</code> 값을 모니터링 해보자.</p>\n<ul>\n<li>익명 매핑을 활용한 <code class=\"language-text\">mmap</code> 예제 코드</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;sys/mman.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;unistd.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdlib.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>myblock <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\tmyblock <span class=\"token operator\">=</span> <span class=\"token function\">mmap</span><span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1024</span> <span class=\"token operator\">*</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">,</span> PROT_READ <span class=\"token operator\">|</span> PROT_WRITE<span class=\"token punctuation\">,</span> MAP_PRIVATE <span class=\"token operator\">|</span> MAP_ANONYMOUS<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\n\t\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>myblock <span class=\"token operator\">==</span> MAP_FAILED<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t\n\t\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Currently allocating %dMB \\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">++</span>count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>count <span class=\"token operator\">==</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">600</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>책에서는 이전 포스팅에서 다룬 예제 코드(<code class=\"language-text\">malloc</code>)을 활용하지만,  캐시 웜업이 안되서인지 드라마틱하게 <code class=\"language-text\">Active(anon)</code> 이 증가하는 모습을 재현할 수가 없었다.\n따라서, <code class=\"language-text\">mmap()</code> 을 통해 강제로 익명매핑을 수행하는 식으로 짰고, LRU 정책에서 봤듯이 초기에는 비활성 리스트에 들어간 뒤 활성 리스트로 변경되어서 똑같은 코드를 여러번 돌려서 올리는 식으로 진행하였다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">root@ubuntu:~# cat /proc/meminfo | grep  anon\nActive(anon):         88 kB\nInactive(anon):    59268 kB\nroot@ubuntu:~# cat /proc/meminfo | grep  anon\nActive(anon):        104 kB\nInactive(anon):    62788 kB\nroot@ubuntu:~# cat /proc/meminfo | grep  anon\nActive(anon):        116 kB\nInactive(anon):    67092 kB\nroot@ubuntu:~# cat /proc/meminfo | grep  anon\nActive(anon):        124 kB\nInactive(anon):    71356 kB</code></pre></div>\n<p>조금씩 증가하는 모습을 볼 수 있다. 책에서는 (<code class=\"language-text\">x86_64</code>) 아키텍처에서 테스트를 하는 것 같은데 필자는 <code class=\"language-text\">arm64</code> 아키텍처에 돌려서 그런지 드라마틱하게 재현이 안된거같은데 이 부분은 좀 더 확인해봐야할거 같다. 이렇게 활성 &#x3C;-> 비활성 리스트를 관리하는 작업은 <code class=\"language-text\">kswapd</code> 데몬이 관리해준다</p>\n<h2 id=\"step-23-slab-메모리-영역\" style=\"position:relative;\"><a href=\"#step-23-slab-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD\" aria-label=\"step 23 slab 메모리 영역 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.3 slab 메모리 영역</h2>\n<h3 id=\"step-231-vmalloc과-kmalloc\" style=\"position:relative;\"><a href=\"#step-231-vmalloc%EA%B3%BC-kmalloc\" aria-label=\"step 231 vmalloc과 kmalloc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.3.1 vmalloc()과 kmalloc()</h3>\n<p>위에서 <code class=\"language-text\">buff/cache</code> 영역과 <code class=\"language-text\">anon</code> 에 대해서 알아보았다. 또 중요한 메모리 영역이 존재하는데 바로, <strong>커널이 내부적으로 사용하는 영역</strong>이다.</p>\n<p>커널 또한 프로세스의 일종이기 때문에 메모리가 필요하며, 조금 특별한 방법으로 메모리를 할당 받아서 사용한다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/Bh2GsmL.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.pf.is.s.u-tokyo.ac.jp/wp-content/uploads/2018/10/AdvancedOperatingSystems3.pdf\">그림 15. Low-Level Memory Allocatort, Advanced Operating Systems\n#3(Shinpei Kato, The University of Tokyo), 2018</a></em>\n</p>\n<p>위 그림은 커널 내 메모리 관리시스템을 추상화해놓은 그림이다.\n우리는 현재까지 유저 공간 메모리 관리와 관련되어서 이야기를 해왔었다.</p>\n<p><code class=\"language-text\">Slab</code>을 이해하기 위해서는 커널 공간 메모리 관리(그림에서 <strong>Kernel Dynamic Memory Allocation</strong>)에 대해서 이해할 필요가 있다.</p>\n<p>우리가 위에서 살펴본 내용처럼 커널은 메모리를 페이지 단위로 관리하고, 그림에서 보이듯 버디 시스템(Buddy System)<sup id=\"fnref-16\"><a href=\"#fn-16\" class=\"footnote-ref\">16</a></sup> 을 활용하여 물리 메모리 할당/해제 등을 처리한다.</p>\n<p>위에서 언급한 내용처럼 Kernel Dynamic Memory Allocation만 보면 아래와 같이 나눠진다.</p>\n<ul>\n<li>\n<p>Slab Allocator(<code class=\"language-text\">kmalloc()</code>)</p>\n<ul>\n<li>위에서 살펴봤던 내용 중에 <code class=\"language-text\">Lowmem</code> 에 대한 할당과 관련이 되어있다. MMU에 의해서 가상 주소로 변환된 물리적 주소를 리턴한다.</li>\n<li>바로 리턴할 수 있는 이유는 위에서 보았듯 선형 매핑(Linear Mapping)이 된 영역이라 가상 주소 공간 &#x3C;-> 물리 메모리 주소가 1:1 매핑이 되어있고, 연속적이기 때문이다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">vmalloc()</code></p>\n<ul>\n<li><code class=\"language-text\">Highmem</code> 과 연관되어있으며 간접 매핑(Indirect Mapping)으로 이뤄진 영역이다.</li>\n<li>따라서, 불연속적인 공간이 할당이 이뤄지고 <code class=\"language-text\">vmalloc()</code>은 그것을 대응하기 위한 함수이다.</li>\n</ul>\n</li>\n</ul>\n<p>그림을 보면 <code class=\"language-text\">kmalloc()</code> 은 연속적이고, 선형으로 매핑된 공간에 대한 처리를 위한 함수인데 <strong>이것을 Slab Allocator가 사용</strong>한다.</p>\n<p>위에서 잠깐 <code class=\"language-text\">Highmem</code> 내용을 다룰 때, <code class=\"language-text\">kmap()</code>, <code class=\"language-text\">kunmap()</code> 함수를 다뤘었는데 이 둘의 차이는 링크로 대체해본다.</p>\n<ul>\n<li><a href=\"https://kldp.org/node/137435\">영구커널매핑(kmap) 관련 질문</a> (마지막 댓글을 보면 될 것 같다.)</li>\n</ul>\n<h3 id=\"step-232-slab\" style=\"position:relative;\"><a href=\"#step-232-slab\" aria-label=\"step 232 slab permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.3.2 Slab</h3>\n<p>Slab은 무엇이길래 따로 이런식으로 관리를 해주는 것일까?</p>\n<p>커널도 일종의 프로세스이기 때문에 메모리를 관리를 해주어야하는데 버디 시스템에서는 기본적으로 <code class=\"language-text\">4KB</code> 크기로 페이지를 할당해준다.\n하지만 이 크기는 커널 입장에서는 큰 단위이고, 커널 입장에서는 이 정도의 영역이 필요없다.</p>\n<p>이렇게 큰 영역을 할당 받아서 커널이 사용하게 되면 단편화(Fragmentation)<sup id=\"fnref-16\"><a href=\"#fn-16\" class=\"footnote-ref\">16</a></sup> 현상도 발생할 수 있다. 이에 별도로 관리한다.</p>\n<p><strong>즉, <code class=\"language-text\">Slab</code>은 메모리 영역 중 커널이 직접 사용하는 영역이라고 볼 수 있으며 페이지 단위로 관리되기에는 단편화 문제 등이 발생할 수 있기 때문에 <code class=\"language-text\">Slab</code> 영역으로 따로 관리하는 것이다.</strong></p>\n<p>이 <code class=\"language-text\">Slab</code> 은 <code class=\"language-text\">cat /proc/meminfo</code> 를 통해서 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">Slab:              59648 kB\nSReclaimable:      24508 kB\nSUnreclaim:        35140 kB</code></pre></div>\n<p>위에서 나타나는 <code class=\"language-text\">Slab</code> 영역이 바로 그 영역이다.</p>\n<ul>\n<li><code class=\"language-text\">Slab</code> : 메모리 영역 중 커널이 직접 사용하는 영역 (<code class=\"language-text\">dentry cache, inode cache</code> 등이 존재)</li>\n<li><code class=\"language-text\">SReclaimable</code> : 영역 중 재사용될 수 있는 영역이다. (Slab 영역에도 캐시가 존재하는데 주로 그러한 캐시들이 여기에 속한다.)</li>\n<li><code class=\"language-text\">SUnreclaim</code> : 영역 중 재사용될 수 없는 영역이다. (커널이 현재 사용중인 영역이며, 해제해서 다른 용도로 사용할 수 없다.)</li>\n</ul>\n<p>해당 영역에 할당 정보를 자세히 보고 싶다면 <code class=\"language-text\">slabtop -o</code> 명령어를 통해서 볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\"> Active / Total Objects (% used)    : 607979 / 698801 (87.0%)\n Active / Total Slabs (% used)      : 22439 / 22439 (100.0%)\n Active / Total Caches (% used)     : 98 / 147 (66.7%)\n Active / Total Size (% used)       : 150031.97K / 161972.25K (92.6%)\n Minimum / Average / Maximum Object : 0.02K / 0.23K / 8.00K\n\n  OBJS ACTIVE  USE OBJ SIZE  SLABS OBJ/SLAB CACHE SIZE NAME\n202020 167860  83%    0.10K   5180       39     20720K buffer_head\n120204 113288  94%    0.19K   5724       21     22896K dentry\n 75310  72998  96%    0.02K    443      170      1772K numa_policy\n 62118  24756  39%    0.04K    609      102      2436K ext4_extent_status\n 52542  50402  95%    1.15K   1946       27     62272K ext4_inode_cache\n 35008  34889  99%    0.06K    547       64      2188K vmap_area\n 33120  32432  97%    0.12K   1035       32      4140K kmalloc-128</code></pre></div>\n<p>여기서 <code class=\"language-text\">kmalloc-128</code> 같은 것이 <code class=\"language-text\">Slab</code> 의 크기를 나타낸다. <code class=\"language-text\">kmalloc-128</code> 이면 <code class=\"language-text\">kmalloc(128)</code> 과 같이 호출하면 최소 페이지인 단위인 <code class=\"language-text\">4KB</code>가 아닌 <code class=\"language-text\">kmalloc-128</code> 캐시를 이용하여 128만큼 할당해준다. 그림으로 보면 아래와 같이 되어있다고 보면 될 것이다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/D8yEJRR.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.yes24.com/Product/Goods/44376723\">그림 16. slab 할당자의 메모리 사용 개념도, DevOps와 SE를 위한 리눅스 커널 이야기(강진우 저), 2017</a></em>\n</p>\n<p>이 중에서 <code class=\"language-text\">dentry cache</code> 와 <code class=\"language-text\">inode cache</code> 는 <code class=\"language-text\">slabtop -o</code> 명령어로 나타난 리스트 중에서 아래의 내용을 나타낸다.</p>\n<ul>\n<li><code class=\"language-text\">dentry</code> : 디렉토리의 계층 관계를 저장해둔다.</li>\n<li><code class=\"language-text\">ext4_inode_cache</code> : 파일의 inode에 대한 정보를 저장해둔다.</li>\n</ul>\n<p>그리고 <code class=\"language-text\">Slab</code> 또한 <code class=\"language-text\">free</code> 명령어 사용 시에 <code class=\"language-text\">used</code> 영역으로 계산된다. (<code class=\"language-text\">buff/cache</code> 가 아니다.)</p>\n<p>따라서, <strong>사용하는 메모리 영역을 모두 더하고도 <code class=\"language-text\">used</code>와 맞지 않을 경우 <code class=\"language-text\">Slab</code> 누수를 의심</strong>할 수 있다.</p>\n<h2 id=\"step-3-결론\" style=\"position:relative;\"><a href=\"#step-3-%EA%B2%B0%EB%A1%A0\" aria-label=\"step 3 결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3. 결론</h2>\n<p>리눅스 커널 메모리 관리에 대해서 많은 것을 공부하였다.</p>\n<ol>\n<li>리눅스 프로세스의 기본 단위인 <code class=\"language-text\">task_struct</code> 의 동작원리 이해</li>\n<li>실제 가상 주소 공간을 통해서 메모리 할당과 관련되어있는 <code class=\"language-text\">mm_struct</code> 에 대한 정보\n<ul>\n<li>이를 토대로 프로세스마다 스택, 힙, 데이터 영역이 어떤 식으로 관리되는지도 보았다. (실질적인 관리는 <code class=\"language-text\">vm_area_struct</code> 로 된다는 것도 말이다.)</li>\n</ul>\n</li>\n<li>실제 <code class=\"language-text\">mm_struct</code> 내에서 관리되는 가상 메모리 영역(VMA)에 대한 데이터 구조체 <code class=\"language-text\">vm_area_struct</code> 의 동작원리 이해\n<ul>\n<li>파일 매핑, 익명 매핑 등과 같이 실제 스택, 힙, 데이터 영역에 대한 관리에 대한 이해</li>\n</ul>\n</li>\n</ol>\n<p>위에는 이제 우리가 기본적인 메모리 관리를 이해하기 위한 필수적인 구조체들을 보았던 내용이다.</p>\n<p>그 이후에는 아래와 같은 것들을 보았다.</p>\n<ol>\n<li>물리 메모리 공간 &#x3C;-> 가상 주소 공간 사이의 실질적인 매핑 매커니즘</li>\n<li>페이지와 페이지 캐시의 개념과 실제 코드를 통한 구조체 내용</li>\n<li>페이지 캐시 관리 정책 등</li>\n</ol>\n<p>이 후 실제, 예제 코드를 통해서 <code class=\"language-text\">free</code> 명령어와 <code class=\"language-text\">cat /proc/meminfo</code> 를 통해서 세부 지표를 확인해보았다.</p>\n<h2 id=\"step-4-추신\" style=\"position:relative;\"><a href=\"#step-4-%EC%B6%94%EC%8B%A0\" aria-label=\"step 4 추신 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 4. 추신</h2>\n<p>책 내용을 처음 보았을 때 혼동하였던 부분은 LRU 캐시 정책을 따를 경우, 초기 페이지가 활성 리스트에 넣어진다고 혼동하였다.\n이에 혼동되는 부분에 대해서 저자님께 문의를 드렸었는데 아래와 같이 답변이 왔다.</p>\n<p><img src=\"https://i.imgur.com/cxTVKuo.png\" alt=\"\"></p>\n<p>사실 어떻게보면 필자같은 사람의 이메일을 무시할 수 있었을 수도 있다고 본다.\n더군다나 필자는 문의 이메일을 금요일 오후쯤에 보냈었는데 해당 내용에 대해서 내용을 주고 받고, 정리된 회신(위 사진)을 토요일날 주셨다.</p>\n<p>사회초년생인 필자의 혼동되는 부분에 대해서 평화로운 주말에 확인해주셨고, 정성스러운 피드백을 받았다.\n진우님의 자세에 대해서 많은 생각을 하게되었다. <strong>“앞으로 내가 가져야할 자세가 아닐까?”</strong> 라는 생각도 하게 되었다.</p>\n<p>대한민국에는 필자가 존경하는 개발자들이 많다. 그 중에서는 매우 유명한 개발자분들도 계시지만 필자보다 나이가 어린 개발자 중에서도 존경하는 사람이 있다.\n필자가 존경하는 사람들의 공통점은 <strong>나이, 경력을 막론하고 어떠한 사람이 궁금한 점을 제시하면 이에 대해서 자신의 지식 내에서 끝내는 것이 아니라 같이 탐색한다는 점</strong>이다.</p>\n<p>얼마전까지 전세계의 뜨거운 감자는 초전도체였다.\n어떻게 보면 가능성과 신뢰도가 낮은 작은 논문이 아카이브에 올라온 후 전세계 과학자들이 열광하였다.</p>\n<p>초전도체는 지금 현재는 소강상태에 접어든 것 같다. 물론, 이게 진짜냐 가짜냐가 아니라 잠시 뜨거웠던 가슴을 가라앉히고 냉정한 이성으로 판단하는 시점으로 페이즈가 옮겨갔다고 생각한다.\n초전도체가 뜨거운 감자였을 때 생각해보면, 전세계 지식인들이 회의적인 반응을 가졌음에도 해당 연구를 하는 연구자분들은 검증을 위한 실험을 하였다.</p>\n<p>진짜인지 아닌지에 대한 검증을 떠나서, 해당 논문이 가능성과 신뢰도가 낮은걸 떠나서 만일 실재한다면 인류는 또다시 도약을 할 수 있기때문에 자신들의 리소스를 사용했다고 생각한다.\n이것이 필자가 존경하는 사람들이 가진 자세라고 생각한다. 사실, Computer Science라는 분야 자체가 타 공학에 비하면 나온지 얼마안됐고 빠르게 변화한다.</p>\n<p>그렇기에 이러한 자세를 유지하는 것이 중요하다고 본다. 나이, 경력을 막론하고 어떠한 지식에 대해서 궁금증을 타인이 물어보면, 적극적으로 같이 연구하여 검증하는 자세 말이다.\n필자도 이러한 자세를 갖기 위해서 부단히 노력을 해야겠다 생각한다.</p>\n<h1 id=\"레퍼런스\" style=\"position:relative;\"><a href=\"#%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4\" aria-label=\"레퍼런스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>레퍼런스</h1>\n<ol>\n<li><a href=\"https://cs4118.github.io/www/2023-1/lect/21-linux-mm.html\">Linux Memory Management,  COMS W4118 Operating Systems 1</a></li>\n<li><a href=\"https://cs4118.github.io/www/2023-1/lect/09-syscalls.html\">System Calls,  COMS W4118 Operating Systems 1</a></li>\n<li><a href=\"https://linux-kernel-labs.github.io/refs/heads/master/lectures/processes.html\">Processes, Linux Kernel Labs</a></li>\n<li><a href=\"https://41d3n.xyz/272\">Linux Kernel task_struct structure, Aiden</a></li>\n<li><a href=\"https://velog.io/@jinh2352/Linux-5-%EB%A6%AC%EB%88%85%EC%8A%A4%EC%9D%98-%ED%83%9C%EC%8A%A4%ED%81%AC-%EB%AA%A8%EB%8D%B8\">리눅스의 태스크 모델, ‘task_struct’ 자료구조, jinh2352</a></li>\n<li><a href=\"https://brunch.co.kr/@alden/25\">리눅스 페이지 캐시와 버퍼 캐시, 강진우님</a></li>\n<li><a href=\"https://blogs.oracle.com/linux/post/the-maple-tree-a-modern-data-structure-for-a-complex-problem\">The Maple Tree, A Modern Data Structure for a Complex Problem, Oracle Linux Blog</a></li>\n<li><a href=\"https://showx123.tistory.com/92\">리눅스 커널의 mm_struct / vm_area_struct 구조체, BlackStar</a></li>\n<li><a href=\"https://itecnote.com/tecnote/linux-vm_flags-vs-vm_page_prot/\">Linux – vm_flags vs vm_page_prot, iTecNote</a></li>\n<li><a href=\"https://www.sobyte.net/post/2022-08/linux-anonymous-pages-reverse-mapping\">Reverse mapping of anonymous pages in Linux, Sobyte</a></li>\n<li><a href=\"https://hyeyoo.com/95\">[Linux Kernel] 주소와 메모리 공간, Endless Learning</a></li>\n<li><a href=\"https://docs.kernel.org/admin-guide/device-mapper/cache.html\">Cache, Linux Kernel Admin Guide</a></li>\n<li><a href=\"https://biriukov.dev/docs/page-cache/4-page-cache-eviction-and-page-reclaim\">Page Cache eviction and page reclaim , Viacheslav Biriukov</a></li>\n<li><a href=\"https://pangyoalto.com/reduce-slab-memory/\">[Linux] Slab 메모리 줄이기, Pangyoalto</a></li>\n</ol>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\"><a href=\"https://en.wikipedia.org/wiki/Virtual_address_space\">Virtual address space, Wikipedia</a><a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\"><a href=\"https://en.wikipedia.org/wiki/Process_control_block\">Process Control Block, Wikipedia</a><a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-3\"><a href=\"https://stackoverflow.com/questions/6338162/what-is-program-break-where-does-it-start-from-0x00\">Program Break, Stackoverflow</a><a href=\"#fnref-3\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-6\"><a href=\"https://en.wikipedia.org/wiki/Red%E2%80%93black_tree\">Red-Black Tree, Wikipedia</a><a href=\"#fnref-6\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-7\"><a href=\"https://docs.kernel.org/core-api/maple_tree.html\">Maple Tree, Kernel Core API</a><a href=\"#fnref-7\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-9\"><a href=\"https://www.kernel.org/doc/gorman/html/understand/understand006.html\">Page Table Management</a><a href=\"#fnref-9\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-4\"><a href=\"https://en.wikipedia.org/wiki/Page_table\">Page Table, Wikipedia</a><a href=\"#fnref-4\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-5\"><a href=\"https://en.wikipedia.org/wiki/Translation_lookaside_buffer\">Traslation Lookaside Buffer(TLB), Wikipedia</a><a href=\"#fnref-5\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-11\"><a href=\"https://en.wikipedia.org/wiki/Page_(computer_memory)\">Page, Wikipedia</a><a href=\"#fnref-11\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-12\"><a href=\"https://en.wikipedia.org/wiki/Page_cache\">Page Cache, Wikipedia</a><a href=\"#fnref-12\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-13\"><a href=\"https://en.wikipedia.org/wiki/Cache_replacement_policies\">Cache Replacement Policies</a><a href=\"#fnref-13\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-14\"><a href=\"https://github.com/torvalds/linux/blob/master/include/linux/blk_types.h#L264\">struct bio, Github</a><a href=\"#fnref-14\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-15\"><a href=\"https://en.wikipedia.org/wiki/Unix_File_System#Design\">Unix File System</a><a href=\"#fnref-15\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-16\"><a href=\"https://en.wikipedia.org/wiki/Fragmentation_(computing)\">Fregmentation</a><a href=\"#fnref-16\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>","excerpt":"STEP 1. 서론 STEP 1.1 가상 주소 공간 STEP 1.2 task_struct와 mm_struct에 대한 이해 STEP 1.3 가상 메모리 영역(Virtual Memory Area, VMA) STEP 1.4 프로세스가 가상 주소 공간에 매핑되는 방식 STEP 1.4 페이지와 페이지 캐시 STEP 1.4.1 페이지 STEP 1.4.2 페이지 캐시 STEP 1.4.3 페이지 교체 정책 STEP 2. 본론 STEP 2.1 free 명령어 분석 STEP 2.1.1 buff와 cache 영역 STEP 2.1.2 avaliable 지표 STEP 2.2 /proc/meminfo 명령어 분석 STEP 2.3 slab 메모리 영역 STEP 2.3.1 vmalloc()과 kmalloc() STEP 2.3.2 Slab STEP 3. 결론 STEP 4. 추신 개요 이전 포스팅 [Kernel] 리눅스 스케줄링 매커니즘과 Load Average 이전 내용에서는 커널을 이해하기 위한 배경지식과 더…","frontmatter":{"date":"September 04, 2023","title":"[Kernel] 리눅스 메모리 관리 훑어보기","categories":"개발 인프라 독서요약","author":"개발한입","emoji":"💻"},"fields":{"slug":"/linux-kernel-internal-2/"}},"next":{"id":"addafc2f-d783-5e3c-9397-e7d16b087547","html":"<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#step-1-%EC%84%9C%EB%A1%A0\">STEP 1. 서론</a></p>\n<ul>\n<li>\n<p><a href=\"#step-11-%EB%B3%91%EB%A0%AC%EC%84%B1%EA%B3%BC-%EB%8F%99%EC%8B%9C%EC%84%B1\">STEP 1.1 병렬성과 동시성</a></p>\n</li>\n<li>\n<p><a href=\"#step-12-run-queue%EC%99%80-wait-queue\">STEP 1.2 Run Queue와 Wait Queue</a></p>\n<ul>\n<li><a href=\"#step-121-run-queue\">STEP 1.2.1 Run Queue</a></li>\n<li><a href=\"#step-122-wait-queue\">STEP 1.2.2 Wait Queue</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-13-%EB%A6%AC%EB%88%85%EC%8A%A4-%EB%82%B4%EC%97%90%EC%84%9C-%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9D%B8-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\">STEP 1.3 리눅스 내에서 기본적인 스케줄링</a></p>\n<ul>\n<li><a href=\"#step-131-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%83%81%ED%83%9C-%EB%B3%80%ED%99%94\">STEP 1.3.1 프로세스 상태 변화</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-14-%EA%B0%80%EC%83%81-%EC%A3%BC%EC%86%8C-%EA%B3%B5%EA%B0%84\">STEP 1.4 가상 주소 공간</a></p>\n</li>\n<li>\n<p><a href=\"#step-15-mmiomemory-mapped-io\">STEP 1.5 MMIO(Memory Mapped I/O)</a></p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-2-%EB%B3%B8%EB%A1%A0\">STEP 2. 본론</a></p>\n<ul>\n<li>\n<p><a href=\"#step-21-virt--res--shr\">STEP 2.1 VIRT &#x26; RES &#x26; SHR</a></p>\n</li>\n<li>\n<p><a href=\"#step-22-memory-commit\">STEP 2.2 Memory Commit</a></p>\n</li>\n<li>\n<p><a href=\"#step-23-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%81%ED%83%9C\">STEP 2.3 프로세스의 상태</a></p>\n</li>\n<li>\n<p><a href=\"#24-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84\">2.4 프로세스의 우선순위</a></p>\n</li>\n<li>\n<p><a href=\"#step-3-load-averrage%EC%99%80-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%B6%80%ED%95%98\">STEP 3. Load Averrage와 시스템 부하</a></p>\n<ul>\n<li><a href=\"#step-31-cpu-bound-vs-io-bound\">STEP 3.1 CPU Bound vs I/O Bound</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n<h1 id=\"개요\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EC%9A%94\" aria-label=\"개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개요</h1>\n<p>최근에 커널 책을 같이 읽고 정리하는 스터디를 시작하였다. 이를 다루기 앞서, 난이도가 조금 있다보니 배경지식이 조금 필요한 것으로 보인다.\n이에 따라, 중요한 개념 몇가지만 짚고 이와 연관된 내용으로 같이 얘기를 해보고자 한다.</p>\n<h2 id=\"step-1-서론\" style=\"position:relative;\"><a href=\"#step-1-%EC%84%9C%EB%A1%A0\" aria-label=\"step 1 서론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1. 서론</h2>\n<h3 id=\"step-11-병렬성과-동시성\" style=\"position:relative;\"><a href=\"#step-11-%EB%B3%91%EB%A0%AC%EC%84%B1%EA%B3%BC-%EB%8F%99%EC%8B%9C%EC%84%B1\" aria-label=\"step 11 병렬성과 동시성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.1 병렬성과 동시성</h3>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/KW1ffSd.png\">\n</p>\n<p align=\"center\">\n    <em>그림 1. 병렬성과 동시성</em>\n</p>\n<ol>\n<li>병렬성(Parallelism)\n<ul>\n<li>물리적 쓰레드에 연관이 있으며, 코어 당 만약 1개의 쓰레드를 가지게 되면 4개의 물리적 쓰레드를 갖게 된다.</li>\n<li>이 물리적 쓰레드는 실제로 분리된 코어 상에서 동작하므로 동시에 수행될 수 있다.</li>\n</ul>\n</li>\n</ol>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/vyDaj7R.png\">\n</p>\n<p align=\"center\">\n    <em>그림 2. 병렬성(Parallelism)</em>\n</p>\n<p>위와 같이 태스크들이 4개로 병렬 수행을 한다해도 문제 없이 동작을 할 수 있다. 이것이 병렬성이다.</p>\n<ol start=\"2\">\n<li>동시성(Concurrency)\n<ul>\n<li>프로세스 혹은 프로그램 상에서 생성한 논리적 쓰레드에 연관이 있다.</li>\n<li>실제로 동시 수행은 일어나지 않으나 시분할적으로 매우 빠르게 문맥교환이 일어나서 하나의 흐름처럼 동시에 보이는 것이다.</li>\n</ul>\n</li>\n</ol>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/YuGifc5.png\">\n</p>\n<p align=\"center\">\n    <em>그림 3. 동시성(Concurrency)</em>\n</p>\n<p>위의 그림에서 Process에 2개의 논리적 쓰레드가 있었는데 해당 쓰레드 2개가 어떠한 작업(<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mn>1</mn><mo separator=\"true\">,</mo><mi>T</mi><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">T1, T2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord\">2</span></span></span></span></span>)를 처리하는 상황을 그려본 것이다.</p>\n<p>그렇다면, 이 병렬성과 동시성의 개념이 왜 중요할까?</p>\n<p>밑에서 Run Queue와 Wait Queue를 다루면서 컨텍스트 스위칭에 대한 내용을 다룰 것인데 이 개념을 이해하기 위해서 중요하다고 보면 된다.</p>\n<h3 id=\"step-12-run-queue와-wait-queue\" style=\"position:relative;\"><a href=\"#step-12-run-queue%EC%99%80-wait-queue\" aria-label=\"step 12 run queue와 wait queue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.2 Run Queue와 Wait Queue</h3>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">/* Used in tsk->state: */</span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">TASK_RUNNING</span>\t\t\t<span class=\"token expression\"><span class=\"token number\">0x00000000</span></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">TASK_INTERRUPTIBLE</span>\t\t<span class=\"token expression\"><span class=\"token number\">0x00000001</span></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">TASK_UNINTERRUPTIBLE</span>\t\t<span class=\"token expression\"><span class=\"token number\">0x00000002</span></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">__TASK_STOPPED</span>\t\t\t<span class=\"token expression\"><span class=\"token number\">0x00000004</span></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">__TASK_TRACED</span>\t\t\t<span class=\"token expression\"><span class=\"token number\">0x00000008</span></span></span></code></pre></div>\n<ul>\n<li>참고 : <a href=\"https://github.com/torvalds/linux/blob/master/include/linux/sched.h#L86\">linux/sched.h</a></li>\n</ul>\n<p>위는 리눅스에서 작업(Task)의 상태를 나타내는 식별자이다.</p>\n<table>\n<thead>\n<tr>\n<th>상태</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">TASK_RUNNING</code></td>\n<td>작업 실행 가능 상태를 나타내며, 현재 실행 중이거나 실행 대기열(<code class=\"language-text\">Run Queue</code>)에서 대기중</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">TASK_INTERRUPTIBLE</code></td>\n<td>작업이 어떤 상황이 발생하는 동안 잠을 자는 상황, 신호가 수신되면 일찍 잠에서 깨울 수 있다.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">TASK_UNINTERRUPTIBLE</code></td>\n<td>작업이 어떤 상황이 발생하는 동안 잠을 자는 상황, 조기에 깨울 수 없다.</td>\n</tr>\n</tbody>\n</table>\n<p>이 큰 맥락말고도 실제 동작 유무에 따라서 아래와 같이 상태를 나타낼 수 있다.</p>\n<ol>\n<li><code class=\"language-text\">running</code> : <code class=\"language-text\">TASK_RUNNING</code> 상태이며, 현재 동작중인 작업</li>\n<li><code class=\"language-text\">runnable</code> : <code class=\"language-text\">TASK_RUNNING</code> 상태이며, <code class=\"language-text\">Run Queue</code>에 인입되어 실행되기를 기다리는 작업</li>\n<li><code class=\"language-text\">blocked</code> : <code class=\"language-text\">TASK_INTERRUPTIBLE</code> 혹은 <code class=\"language-text\">TASK_UNINTERRUPTIBLE</code> 인 작업 상태</li>\n</ol>\n<p>이제 실제 <code class=\"language-text\">Run Queue</code>의 구조를 보자.</p>\n<h4 id=\"step-121-run-queue\" style=\"position:relative;\"><a href=\"#step-121-run-queue\" aria-label=\"step 121 run queue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.2.1 Run Queue</h4>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/qW8dVbK.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://cs4118.github.io/www/2023-1/lect/10-run-wait-queues.html\">그림 4. Run Queue, COMS W4118 Operating Systems 1 - Columbia univ, 2023</a></em>\n</p>\n<p>위와 같은 <code class=\"language-text\">task_struct</code>의  <code class=\"language-text\">list_head</code> 포인터를 통해서 자식/형제 계층들이 연결이 된다.\n<code class=\"language-text\">run queue</code>는 상태가 <code class=\"language-text\">TASK_RUNNING</code>인 <code class=\"language-text\">list_head</code> 들과 연결이 된다. 따라서, <code class=\"language-text\">run queue</code> 용으로 <code class=\"language-text\">task_struct</code>에는 별도로 <code class=\"language-text\">list_head</code>가 있어야한다.</p>\n<p><code class=\"language-text\">run queue</code>는 코어당 존재를 하며, 4코어일 경우에는 각 코어마다 1개씩 존재하여 4개의 <code class=\"language-text\">run queue</code>가 존재하게 된다.</p>\n<p>그러나 주의할 점은 아래의 내용이다.</p>\n<ul>\n<li><code class=\"language-text\">run queue</code> 에 위치하는 부모/자식 작업은 동일한 CPU에서 실행되지 않을 수 있다.\n<ul>\n<li>Core1에 위치하던 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">T1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord\">1</span></span></span></span></span>이 Core2에서도 수행가능 (OS 스케줄러에 의한 로드밸런싱에 의거)</li>\n<li>그러나, CPU 선호도(CPU Affinity)나 캐시 워밍업때문에 같은 작업이 같은 코어에서 작업되는 것이 선호된다.</li>\n</ul>\n</li>\n<li><code class=\"language-text\">run queue</code>에 위치하는 부모/자식 작업은 모두 실행 중일 필요는 없다.</li>\n</ul>\n<p>이것이 어떻게 보면 병렬성이 보장되는 이유기도 하다. (각 코어마다 <code class=\"language-text\">run queue</code>가 존재하기에 이상적으로 4개의 작업이 4개의 코어의 <code class=\"language-text\">run queue</code>가 비워져있다면, 동시수행 가능)</p>\n<h4 id=\"step-122-wait-queue\" style=\"position:relative;\"><a href=\"#step-122-wait-queue\" aria-label=\"step 122 wait queue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.2.2 Wait Queue</h4>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/VZzy5ob.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://cs4118.github.io/www/2023-1/lect/10-run-wait-queues.html\">그림 5. Wait Queue, COMS W4118 Operating Systems 1 - Columbia univ, 2023</a></em>\n</p>\n<p><code class=\"language-text\">Wait Queue</code>는 <code class=\"language-text\">Run Queue</code>와 <code class=\"language-text\">TASK_INTERRUPTIBLE</code> 혹은 <code class=\"language-text\">TASK_UNINTERRUPTIBLE</code> 상태를 가진 작업과 연결이 된다.</p>\n<p>이 과정에 대한 이벤트 루프 방식은 아래와 같다.</p>\n<ol>\n<li><code class=\"language-text\">prepare_to_wait()</code> : <code class=\"language-text\">TASK_INTERRUPTIBLE</code>로 변경 후 <code class=\"language-text\">Wait Queue</code>에 작업을 인입시킨다.</li>\n<li><code class=\"language-text\">signal_pending(state)</code> : 작업에 시그널이 전달됐으면 <code class=\"language-text\">true</code> 아니면 <code class=\"language-text\">false</code> 를 리턴시킨다.\n<ul>\n<li>잠들기 전에 시그널을 받았으면 잠드는 대신에 루프를 탈출한다.</li>\n</ul>\n</li>\n<li><code class=\"language-text\">schedule()</code> : 실제로 잠들기를 수행한다.</li>\n<li><code class=\"language-text\">finish_wait()</code> : <code class=\"language-text\">TASK_RUNNING</code> 상태로 변경한 후에 해당 작업을 <code class=\"language-text\">Wait Queue</code>에서 제거한다.</li>\n</ol>\n<p>이러한 이벤트 루프가 존재하며, 1-4를 계속 반복한다고 보면 된다.</p>\n<h3 id=\"step-13-리눅스-내에서-기본적인-스케줄링\" style=\"position:relative;\"><a href=\"#step-13-%EB%A6%AC%EB%88%85%EC%8A%A4-%EB%82%B4%EC%97%90%EC%84%9C-%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9D%B8-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\" aria-label=\"step 13 리눅스 내에서 기본적인 스케줄링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.3 리눅스 내에서 기본적인 스케줄링</h3>\n<p>먼저, <a href=\"https://github.com/torvalds/linux/blob/master/kernel/sched/core.c#L6591-L6718\">linux/kernel/sched/core.c</a> 쪽을 보면 <code class=\"language-text\">schedule()</code> 이라는 함수가 있음을 확인할 수 있다.</p>\n<p>이 함수 내부적으로는 아래의 함수들도 사용된다.</p>\n<ol>\n<li><code class=\"language-text\">pick_next_task()</code> : run queue에서 꺼내서 실행시킬 새 작업을 선택하는 함수</li>\n<li><code class=\"language-text\">context_switch()</code> : 현재 작업을 휴면상태로 변경 후 위 함수에서 가져온 작업을 실행 시키는 함수</li>\n</ol>\n<p>이를 토대로, Wait Queue에 대한 스케줄링은 아래와 같이 나눠진다.</p>\n<ul>\n<li>\n<p>휴면상태 돌입</p>\n<ol>\n<li><a href=\"https://github.com/torvalds/linux/blob/master/include/linux/wait.h#L300-L322\">wait_event()</a>함수 호출</li>\n<li><a href=\"https://github.com/torvalds/linux/blob/master/kernel/sched/wait.c#L305-L339\">Wait Queue에 작업을 적재</a></li>\n<li><a href=\"https://github.com/torvalds/linux/blob/master/kernel/sched/core.c#L6591-L6718\">schedule()</a> 함수 호출</li>\n<li>Run Queue에 해당 작업 제거</li>\n<li><a href=\"https://github.com/torvalds/linux/blob/master/kernel/sched/core.c#L6674C9-L6674C23\">pick_next_task()</a> 함수 호출</li>\n<li><a href=\"https://github.com/torvalds/linux/blob/master/kernel/sched/core.c#L6710C8-L6710C22\">context_switch()</a> 함수 호출</li>\n<li>다른 작업 수행</li>\n</ol>\n</li>\n<li>\n<p>휴면상태를 깨우기</p>\n<ol>\n<li><a href=\"https://github.com/torvalds/linux/blob/master/kernel/sched/wait.c#L80-L121\">wake_up()</a>함수 호출</li>\n<li>각 작업마다 <a href=\"https://github.com/torvalds/linux/blob/master/kernel/sched/core.c#L4197-L4354\">try_to_wake_up()</a> 함수 호출</li>\n<li>각 작업을 Run Queue에 적재</li>\n<li><code class=\"language-text\">schedule()</code> 함수를 호출하고 이전에 잠들었던 태스크가 선택된다.\n<ul>\n<li>조건이 <code class=\"language-text\">false</code>면 : 계속 휴면상태에 있음</li>\n<li>조건이 <code class=\"language-text\">true</code>면 : 휴면상태를 끝내고, <a href=\"https://github.com/torvalds/linux/blob/master/include/linux/wait.h#L320C2-L320C13\">finish_wait()</a> 함수를 호출하여 Wait Queue에 작업을 제거</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"step-131-프로세스-상태-변화\" style=\"position:relative;\"><a href=\"#step-131-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%83%81%ED%83%9C-%EB%B3%80%ED%99%94\" aria-label=\"step 131 프로세스 상태 변화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.3.1 프로세스 상태 변화</h4>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/8492Pvm.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://cs4118.github.io/www/2023-1/lect/10-run-wait-queues.html\">그림 6. Process State Transitions, COMS W4118 Operating Systems 1 - Columbia univ, 2023</a></em>\n</p>\n<p>위 상태에서 <code class=\"language-text\">read()</code>라는 시스템콜이 유저모드에서 발생할 시 아래와 같이 처리가 된다.</p>\n<ol>\n<li>커널에 트랩이 발생\n<ul>\n<li>각 프로세스에 대한 레지스터를 커널 스택에 저장</li>\n</ul>\n</li>\n<li>디바이스 드라이버(DMA와 같은)가 I/O Request(IRQ)를 디바이스에 발행</li>\n<li>호출되는 프로세스를 휴면상태로 변화\n<ul>\n<li><code class=\"language-text\">wait_event()</code> -> <code class=\"language-text\">schedule()</code> -> <code class=\"language-text\">pick_next_task()</code> -> <code class=\"language-text\">context_switch()</code></li>\n</ul>\n</li>\n<li>다른 프로세스를 수행(문맥교환이 발생하였기 때문에)</li>\n<li>디바이스에서 IRQ를 성공적으로 처리하였으면, 하드웨어 인터럽트 발생</li>\n<li>커널에 트랩을 발생시킨 후, 인터럽트 핸들러로 PC를 이동\n<ul>\n<li><code class=\"language-text\">wake_up()</code> : 현재 블록킹 중인 작업을 Run Queue로 적재</li>\n<li>현재 태스크는 결과적으로 <code class=\"language-text\">schedule()</code> -> <code class=\"language-text\">pick_next_task()</code> -> <code class=\"language-text\">context_switch()</code>의 과정을 호출함.</li>\n</ul>\n</li>\n<li>다른 프로세스를 수행\n<ul>\n<li>여기서, 휴면상태에서 다시 동작하게끔 변경이 되었다면 이 프로세스는 <code class=\"language-text\">read()</code> 함수를 호출한 프로세스일 수도 있으며 아닐 경우 다른 프로세스일 수 있다.</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"step-14-가상-주소-공간\" style=\"position:relative;\"><a href=\"#step-14-%EA%B0%80%EC%83%81-%EC%A3%BC%EC%86%8C-%EA%B3%B5%EA%B0%84\" aria-label=\"step 14 가상 주소 공간 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.4 가상 주소 공간</h3>\n<p>C나 CPP같은 언어를 써서 <code class=\"language-text\">malloc()</code> 같은 시스템 메모리(Physical Memory)를 요구하는 함수를 호출한다 가정했을 때, 우리는 뭔가 <code class=\"language-text\">malloc()</code>을 호출하면 당연하게도 어떠한 시스템 메모리에 영역을 할당받는다고 생각했을 것이다.</p>\n<p>하지만, 리눅스에서도 가상 메모리라는 개념을 활용한다. 이는 SWAP 영역과는 별개의 가상 메모리라고 보면 될 것같다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/7uArXuJ.png\">\n</p>\n<p align=\"center\">\n    <em>그림 7. 리눅스의 가상 주소 공간 매핑 예시</em>\n</p>\n<blockquote>\n<p>위에서는 <code class=\"language-text\">malloc()</code> 호출 시 시스템 콜이 발생되는 가정으로 하였는데 실제로는 발생안하는 케이스도 있으니 참고하기 바란다.</p>\n</blockquote>\n<p>실제로는 위와 같이 바인딩이 된다고 보면된다. 실제로 어플리케이션을 사용할 때는 물리적 메모리에 대해서 가상공간으로 변환해서 사용하는데, 이 가상공간으로 변환되어서 사용되는 물리적 메모리 공간을 가상메모리라고 뜻한다고 보면된다. (이 작업은 MMU에서 처리해준다.)</p>\n<p>참고로, MMU나 가상 메모리를 사용하지 않는 시스템의 경우도 있다.</p>\n<h3 id=\"step-15-mmiomemory-mapped-io\" style=\"position:relative;\"><a href=\"#step-15-mmiomemory-mapped-io\" aria-label=\"step 15 mmiomemory mapped io permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.5 MMIO(Memory Mapped I/O)</h3>\n<p>MMIO는 위 가상메모리와 비슷하게, I/O 작업을 좀 더 빠르게 처리하기 위해서 사용하는 방식이다.</p>\n<p><code class=\"language-text\">malloc()</code> 이 아닌 <code class=\"language-text\">read()</code> 와 같은 시스템 콜을 활용하여 File I/O 처리가 필요하다고 가정해보자.\n그렇다면, <code class=\"language-text\">lseek()</code> 과 같은 시스템 콜을 통해서 파일을 접근 한후 실제 <code class=\"language-text\">read()</code>를 통해서 내용을 커널에서 유저 모드의 버퍼로 전달해야될 것이다.</p>\n<p>이런 과정은 어떻게 보면 느리며, 복잡할 수 있다. 이에 대한 대안은 파일의 영역을 가상 주소 공간에 매핑시키는 것이다. 아래와 같이 말이다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/AfVhSnr.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://cs4118.github.io/www/2023-1/lect/09-syscalls.html\">그림 8. File-backed mappings, COMS W4118 Operating Systems 1 - Columbia univ, 2023</a></em>\n</p>\n<p>매핑된 영역은 디스크에 의해 지원이 되는데 메모리 매핑된 영역에 대한 업데이트는 먼저 메모리로 가고, 후에 디스크로 플러시 된다고 보면된다.</p>\n<p>또한 이 매핑 영역은 두 가지 방식이 존재한다.</p>\n<ol>\n<li>Private Mapping : 파일의 스냅샷을 제공 받지만 변경 사항은 디스크로 플러시가 되지 않으며, 동일한 영역을 매핑하는 다른 프로세스에게는 보이지 않는다.</li>\n<li>Shared Mapping : 같은 메모리를 참조하며, 이런식으로 매핑된 데이터를 가진 프로세스는 서로의 업데이트를 확인할 수 있다.</li>\n</ol>\n<p>실제 동작원리는 잘 쓰여진 포스팅이 있어서 이로 대체한다.</p>\n<ul>\n<li>참고 : <a href=\"https://pr0gr4m.tistory.com/entry/Linux-Kernel-5-mmap\">Linux Kernel 5 mmap(매모리매핑) - Art of Pr0gr4m</a></li>\n</ul>\n<p>위에서는 File에 대한 매핑에 대한 예시라면, 때때로 파일에 의해 백업되지 않은 메모리를 매핑할 수도 있으면 좋겠다라는 요구사항이 발생할 수 있다.(<code class=\"language-text\">malloc()</code> 과 같은)</p>\n<p>이럴 때 사용하는 것이 익명 메모리 매핑이라고 보면된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">LEGACY_MAP_MASK</span> <span class=\"token expression\"><span class=\"token punctuation\">(</span>MAP_SHARED </span><span class=\"token punctuation\">\\</span>\n\t\t<span class=\"token expression\"><span class=\"token operator\">|</span> MAP_PRIVATE </span><span class=\"token punctuation\">\\</span>\n\t\t<span class=\"token expression\"><span class=\"token operator\">|</span> MAP_FIXED </span><span class=\"token punctuation\">\\</span>\n\t\t<span class=\"token expression\"><span class=\"token operator\">|</span> MAP_ANONYMOUS </span><span class=\"token punctuation\">\\</span>\n\t\t<span class=\"token expression\"><span class=\"token operator\">|</span> MAP_DENYWRITE </span><span class=\"token punctuation\">\\</span>\n\t\t<span class=\"token expression\"><span class=\"token operator\">|</span> MAP_EXECUTABLE </span><span class=\"token punctuation\">\\</span>\n\t\t<span class=\"token expression\"><span class=\"token operator\">|</span> MAP_UNINITIALIZED </span><span class=\"token punctuation\">\\</span>\n\t\t<span class=\"token expression\"><span class=\"token operator\">|</span> MAP_GROWSDOWN </span><span class=\"token punctuation\">\\</span>\n\t\t<span class=\"token expression\"><span class=\"token operator\">|</span> MAP_LOCKED </span><span class=\"token punctuation\">\\</span>\n\t\t<span class=\"token expression\"><span class=\"token operator\">|</span> MAP_NORESERVE </span><span class=\"token punctuation\">\\</span>\n\t\t<span class=\"token expression\"><span class=\"token operator\">|</span> MAP_POPULATE </span><span class=\"token punctuation\">\\</span>\n\t\t<span class=\"token expression\"><span class=\"token operator\">|</span> MAP_NONBLOCK </span><span class=\"token punctuation\">\\</span>\n\t\t<span class=\"token expression\"><span class=\"token operator\">|</span> MAP_STACK </span><span class=\"token punctuation\">\\</span>\n\t\t<span class=\"token expression\"><span class=\"token operator\">|</span> MAP_HUGETLB </span><span class=\"token punctuation\">\\</span>\n\t\t<span class=\"token expression\"><span class=\"token operator\">|</span> MAP_32BIT </span><span class=\"token punctuation\">\\</span>\n\t\t<span class=\"token expression\"><span class=\"token operator\">|</span> MAP_HUGE_2MB </span><span class=\"token punctuation\">\\</span>\n\t\t<span class=\"token expression\"><span class=\"token operator\">|</span> MAP_HUGE_1GB<span class=\"token punctuation\">)</span></span></span></code></pre></div>\n<p>위는 <a href=\"https://github.com/torvalds/linux/blob/master/include/linux/mman.h\">mman.h</a>에 대한 코드 중에서 매모리 매핑에 관련된 마스크에 대한 내용을 담고 있다.\n이때, 익명 메모리 매핑을 사용하기 위해서는 <code class=\"language-text\">MAP_ANONYMOUS</code> 를 둬서 처리하면 된다.</p>\n<p>이때도 마찬가지로 매핑을 공유할 지 안할 지 처리할 수 있는데 이 구조에 따라서 <code class=\"language-text\">fork()</code> 와 같은 시스템콜에 영향을 끼친다.</p>\n<p><code class=\"language-text\">MAP_PRIVATE</code> : <code class=\"language-text\">fork()</code> 와 같은 시스템콜로 생성된 자식 프로세스는 독립적인 복사본을 얻게된다. (<code class=\"language-text\">malloc()</code>과 같은)</p>\n<p><code class=\"language-text\">MAP_SHARED</code> : 자식 프로세스는 메모리 매핑을 공유하며, 서로의 업데이트를 볼 수 있다. 이렇게 될 경우 IPC 형태라 볼 수 있는데 이 방식으로 생성된 자식 프로세스는 <code class=\"language-text\">pipe()</code>와 같이 사용된다. 비슷한 IPC 형태는 공유 메모리에 의한 IPC라 보면될 것이다.</p>\n<h2 id=\"step-2-본론\" style=\"position:relative;\"><a href=\"#step-2-%EB%B3%B8%EB%A1%A0\" aria-label=\"step 2 본론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2. 본론</h2>\n<p>이제 본론으로 들어와보자.</p>\n<p>사실 위 내용을 다뤘던 이유는 현재 스터디 중인 책과 관련이 있다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/Wr6OE3y.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.yes24.com/Product/Goods/44376723\">그림 9. DevOps와 SE를 위한 리눅스 커널 , 강진우 저, 2017</a></em>\n</p>\n<p>현재, 이 책에 대한 스터디를 진행 중이었고, 1 ~ 3장을 각자 정리를 해오자라고 얘기가 나왔는데 보다 심층적으로 파악할 필요가 있어서 위와 같은 배경지식을 설명해보았다.\n이제 본격적으로 이 책에서 다뤘던 내용을 다뤄보고자한다.</p>\n<p>초점은 2 ~ 3장과 관련된 내용이라고 보면될 것이다.</p>\n<h3 id=\"step-21-virt--res--shr\" style=\"position:relative;\"><a href=\"#step-21-virt--res--shr\" aria-label=\"step 21 virt  res  shr permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.1 VIRT &#x26; RES &#x26; SHR</h3>\n<p>먼저, 리눅스의 top 명령어를 입력하게 되면 아래와 같은 화면을 볼 수 있다.</p>\n<p><img src=\"https://i.imgur.com/WjZnsOx.png\" alt=\"\"></p>\n<p>이 중에서 우리가 중점적으로 볼 지표는 <code class=\"language-text\">VIRT</code>, <code class=\"language-text\">RES</code>, <code class=\"language-text\">SHR</code> 이다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/sI9WtTX.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.yes24.com/Product/Goods/44376723\">그림 10. VIRT, RES, SHR의 관계, DevOps와 SE를 위한 리눅스 커널, p.24</a></em>\n</p>\n<ol>\n<li><code class=\"language-text\">VIRT</code> : <code class=\"language-text\">RES</code>와 <code class=\"language-text\">SHR</code> 그리고 SWAP영역까지 프로세스가 사용되는 메모리의 전체 용량</li>\n<li><code class=\"language-text\">RES</code> :  프로세스가 사용 중인 물리 메모리(Physical Memory)의 용량</li>\n<li><code class=\"language-text\">SHR</code> :  프로세스가 사용 중인 공유 메모리의 용량</li>\n</ol>\n<p>여기서 헷갈렸던 부분은 책에서는 <code class=\"language-text\">VIRT</code>에 대해서 가상메모리(Virtual Memory)의 전체 용량으로 얘기했어서 이것이 위에서 보았던 가상 주소 공간(Virtual Address Area)의 용량을 나타내는 것인지 아니면 실제 HDD나 SDD를 메모리처럼 활용하기 위한 가상메모리인 SWAP 영역을 나타내는지 궁금해졌다.</p>\n<p>찾아보니 <code class=\"language-text\">VIRT</code>가 나타내는 메모리 총 용량은 아래와 같이 계산된다.</p>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>I</mi><mi>R</mi><mi>T</mi><mo>=</mo><mi>R</mi><mi>E</mi><mi>S</mi><mo>+</mo><mi>S</mi><mi>W</mi><mi>A</mi><mi>P</mi><mo>+</mo><mi>S</mi><mi>H</mi><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">VIRT = RES + SWAP + SHR</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">RT</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">RES</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span></span></p>\n<p>즉, 물리메모리, 공유메모리, 가상메모리(SWAP)에 대한 프로세스가 점유하고 있는 메모리 총 용량이라고 볼 수 있다.\n따라서, <code class=\"language-text\">VIRT</code>를 통해서 어떤 프로세스가 스왑메모리를 많이 사용하는지도 파악이 가능할 수 있다.</p>\n<p>왜냐면, 스왑메모리는 가상메모리의 일종이므로 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>I</mi><mi>R</mi><mi>T</mi><mo>></mo><mi>T</mi><mi>O</mi><mi>T</mi><mi>A</mi><mi>L</mi><mtext>  </mtext><mi>M</mi><mi>E</mi><mi>M</mi><mi>O</mi><mi>R</mi><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">VIRT > TOTAL \\; MEMORY</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7224em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">RT</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">TOT</span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">MEMOR</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span></span> 인 상황이면 스왑메모리를 사용하는 것을 추측할 수 있다. (<code class=\"language-text\">SHR</code> 의 크기는 그리 크지 않기 때문이다.)\n이를 토대로 <code class=\"language-text\">SWAP</code> 을 최소화해서 사용해야하는 어플리케이션의 사용량을 추적할 수도 있어보인다.</p>\n<p>어떤 케이스에 SWAP 영역을 최소화 해야되는지 궁금하다면 제 블로그의 아래의 아티클을 읽어보기를 추천한다.</p>\n<ul>\n<li>참고 : <a href=\"https://brewagebear.github.io/fundamental-os-page-cache/\">왜 처리량이 중요한 JVM 어플리케이션은 vm.swappiness = 1로 설정하라고 할까?</a></li>\n</ul>\n<p>그리고 <code class=\"language-text\">VIRT</code>가 Virtual을 나타내는 것과 같이 보이는데 위에서 얘기했던 내용에 대해서 첨언하면, <code class=\"language-text\">VIRT</code>는 <strong>가상 주소 공간에 대한 용량이 맞다</strong>고 보면 된다.</p>\n<blockquote>\n<p>💡즉, 가상 주소 공간에 메모리 할당을 할 때 SWAP에 처리되는 페이지 캐시나 기타 데이터도 이 영역에 할당이 되어지는 것이다.\n이 부분은 서론에서 얘기했듯이 MMU가 관리하고, 스왑-아웃을 통해서 스왑 영역으로 페이지가 이동되더라도 가상 주소 공간에서 할당이 일관되게 유지되는 것이다.</p>\n</blockquote>\n<p>오해의 소지가 있어보이므로 앞으로 물리 메모리와 실제 매핑되서 MMU에 관리되는 부분을 가상 주소 공간, 보조기억장치와 메모리 영역 사이에서 관리되는 부분을 SWAP이라고 명시하도록 하겠다.</p>\n<h3 id=\"step-22-memory-commit\" style=\"position:relative;\"><a href=\"#step-22-memory-commit\" aria-label=\"step 22 memory commit permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.2 Memory Commit</h3>\n<p>자 그러면, 리눅스에서 왜 <code class=\"language-text\">VIRT</code>와 <code class=\"language-text\">SHR</code>를 따로 나눠서 관리를 할까?\n이는 메모리 커밋과 관련이 있다.</p>\n<p>서론에서 얘기한 바와 같이 <code class=\"language-text\">malloc()</code> 등으로 메모리 할당을 요청하면 가상 주소 공간에 대한 주소를 넘겨준다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/wXo9CGA.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.yes24.com/Product/Goods/44376723\">그림 11. VIRT, RES, SHR의 관계, DevOps와 SE를 위한 리눅스 커널, p.25</a></em>\n</p>\n<p>하지만, 이때도 실제 물리 메모리에 해당 영역이 할당된 상태는 아니라는 것이다.\n예약은 해두고 가상 주소 공간에서 주소를 넘겨받는 이러한 동작 방식을 <code class=\"language-text\">Memory Commit</code> 이라 한다.</p>\n<p>그러면 실제 물리 메모리에 언제 바인딩이 될까? 그것은 바로 직접적으로 쓰기 작업이 발생할 때이다.\n쓰기 작업을 수행하면 페이지 부재(Page Fault)가 발생할 것이고 내부적인 매커니즘에 따라서 처리가 된다. (참고로, 페이지 부재(Page Fault)에 대한 처리는 아키텍처마다 다르다.)</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">/*\n*문제의 VMA(가상 메모리 영역)가 거대한 페이지(HugeTLB)에 의해 지원되는 경우 커널은 결함 처리를 `hugetlb_fault` 기능에 위임. \n* 이 기능은 크기 및 관리 방식으로 인해 일반 페이지와 다르게 처리되는 대형 페이지와 특히 관련된 오류를 처리.\n*/</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">unlikely</span><span class=\"token punctuation\">(</span><span class=\"token function\">is_vm_hugetlb_page</span><span class=\"token punctuation\">(</span>vma<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> ret <span class=\"token operator\">=</span> <span class=\"token function\">hugetlb_fault</span><span class=\"token punctuation\">(</span>vma<span class=\"token operator\">-></span>vm_mm<span class=\"token punctuation\">,</span> vma<span class=\"token punctuation\">,</span> address<span class=\"token punctuation\">,</span> flags<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\n<span class=\"token comment\">/*\n* 거대한 페이지 폴트가 아닌 경우 `__handle_mm_fault` 함수로 페이지 부재를 전달. 이 함수에는 표준 페이지 오류를 처리하는 기본 논리가 포함되어 있고, 여기에는 여러 작업이 포함될 수 있다.\n* 1. 페이지가 이미 메모리에 있지만 프로세스의 페이지 테이블에 매핑되지 않았는지 확인(사소한 결함).\n* 2. 이전에 교체된 경우(스와핑) 교체 공간(스왑 영역)에서 페이지를 로드.\n* 3. 파일 기반 매핑인 경우 백업 저장소(예: 디스크의 파일)에서 페이지를 가져옴.\n* 4. 이전에 기록되지 않은 익명 매핑인 경우 새로운 제로 페이지 할당.\n*/</span>\n<span class=\"token keyword\">else</span> ret <span class=\"token operator\">=</span> <span class=\"token function\">__handle_mm_fault</span><span class=\"token punctuation\">(</span>vma<span class=\"token punctuation\">,</span> address<span class=\"token punctuation\">,</span> flags<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>\n<p>참고 코드 1 : <a href=\"https://github.com/torvalds/linux/blob/master/arch/arm64/mm/fault.c#L500C1-L500C1\">linux/arch/arm64/mm/fault.c</a></p>\n</li>\n<li>\n<p>참고 코드 2 : <a href=\"https://github.com/torvalds/linux/blob/master/mm/memory.c#L5201\">linux/mm/memory.c</a></p>\n</li>\n<li>\n<p>참고 코드 3 : <a href=\"https://github.com/torvalds/linux/blob/master/mm/page_alloc.c#L4594C5-L4594C5\">linux/mm/page_alloc.c</a></p>\n</li>\n</ul>\n<p>즉, 새로 할당을 하는 케이스면 4번에 해당될 것이고 새로운 제로 페이지를 할당 받는 것이다.<br>\n이렇게 바인딩된 값을 페이지 테이블(Page Table)이라 부르며, 물리 메모리에 실제 바인딩된 영역이 <code class=\"language-text\">RES</code>로 계산된다.</p>\n<p>책에서도 나오지만 그렇다면 위 방식과 같이 처리할 경우 무제한으로 <code class=\"language-text\">malloc</code> 과 같은 시스템 콜을 사용할 수 있는가에 대해서 나온다.\n이에 대한 짧은 코드도 제시해주는데 실제로 돌려보면 비슷한 결과를 얻을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;unistd.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdlib.h></span></span>\n\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">MEGABYTE</span> <span class=\"token expression\"><span class=\"token number\">1024</span><span class=\"token operator\">*</span><span class=\"token number\">1024</span></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>myblock <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span> \n\t<span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\tmyblock <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span>MEGABYTE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>myblock<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span>“Error<span class=\"token operator\">!</span>”<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span> \n\t\t<span class=\"token punctuation\">}</span>\n\n\t\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span>“Currently allocating <span class=\"token operator\">%</span>d MB\\n”<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">++</span>count<span class=\"token punctuation\">)</span><span class=\"token operator\">*</span>MEGABYTE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\t\t<span class=\"token comment\">// memset(myblock, 1, MEGABYTE);</span>\n\t\t<span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 코드를 <code class=\"language-text\">gcc example1.c</code> 로 <code class=\"language-text\">a.out</code> 실행 파일을 얻어서 돌려본 결과를 아래와 같다.</p>\n<p><img src=\"https://i.imgur.com/2A5yc1J.png\" alt=\"\"></p>\n<p>보면 세번째 (6XXXX) 숫자가 <code class=\"language-text\">VIRT</code>고 1548 값이 <code class=\"language-text\">RES</code> 값이다.  <code class=\"language-text\">//memset(myblock, 1, MEGABYTE);</code> 이 주석처리 되어있어서 우리가 이론 상으로 배웠던 내용처럼 <code class=\"language-text\">RES</code>는 증가하지 않는 모습을 보여준다.\n그렇다면 주석을 해제하고 돌려보면 어떻게 될까?</p>\n<p><img src=\"https://i.imgur.com/7lkKwqL.png\" alt=\"\"></p>\n<p>3152였던 <code class=\"language-text\">RES</code> 값이 실제로 증가함을 확인할 수 있다. 동일한 값이 나오는 이유는 VM에 돌리는 환경이다보니 메모리가 한정적이라 <code class=\"language-text\">sleep(2)</code>로 둬서 2초의 간격이 생겨서 그런거라고 보면 된다.\n자 이제 실제 메모리 쓰기 전까지는 <code class=\"language-text\">VIRT</code>만 증가하고, 실제 메모리가 쓰여질 때 물리 메모리인 <code class=\"language-text\">RES</code>를 할당받는다는 점을 알게되었다.</p>\n<p>그렇다면, <code class=\"language-text\">VIRT</code>는 무한정 늘어날 수 있을까? 그 부분에 관련된 커널 파라미터(<code class=\"language-text\">vm.overcommit_memory</code>)의 값에 따라서 달라진다.\n그러면 왜 리눅스 커널은 이런식으로 메모리 커밋을 수행하면 바로 할당되는 것이 아니라 지연되게끔 개발 되었을까?</p>\n<p>이유는 새로운 프로세스를 만드는 <code class=\"language-text\">fork()</code> 와 같은 시스템 콜을 처리해야되기 때문이다.</p>\n<p>서론에서도 잠깐 언급된 <code class=\"language-text\">fork()</code> 시스템 콜은 현재 커널에 실행 중인 프로세스와 똑같은 프로세스를 하나 만들게 된다. 그 프로세스는 후에 <code class=\"language-text\">exec()</code>와 같은 시스템 콜을 통해서 다른 프로세스로 변화한다.\n이러한 상황이다보니 <strong>확보한 메모리가 대부분 쓸모가 없어질 수도 있는 것</strong>이다.</p>\n<p>그래서 COW(Copy-On-Write)라는 기법을 통해서 복사된 메모리에 실제 쓰기 작업이 발생한 후에야 실질적인 메모리 할당을 시작한다.\n이를 위해서 메모리 커밋이 필요하다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/ODNgVTH.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"http://csl.snu.ac.kr/courses/4190.307/2020-1/9-mmap.pdf\">그림 12. COW(Copy-On-Write), Memory Mapping, SNU</a></em>\n</p>\n<p>위는 <code class=\"language-text\">fork()</code> 시스템 콜 상황에서 COW가 동작하는 원리를 보여준다. 이렇게 처리되기 때문에 메모리 커밋이 없으면 다음과 같은 상황이 발생할 수 있다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/h0lAhWM.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.yes24.com/Product/Goods/44376723\">그림 13. fork()와 Memory Commit, DevOps와 SE를 위한 리눅스 커널, p.28</a></em>\n</p>\n<p>1기가의 가용메모리가 있고, 3GB의 프로세스를 <code class=\"language-text\">fork()</code> 를 통해서 복제한 상황이다. 이 케이스에 만약, 메모리 커밋처럼 지연처리가 없다면 OOM과 같은 문제도 발생할 수 있다.\n어쨋든 메모리 커밋으로 위와 같은 상황에서도 오버커밋이 되긴했지만 쓰이기 전까지는 지연처리 되니 보다 안정성을 제공한다 볼 수 있다.</p>\n<p>이 커밋 비율을 보기 위해서는 <code class=\"language-text\">sar</code> 와 같은 모니터링 도구를 활용할 수 있다. 커밋된 비율도 중요한 점이 순간적으로 시스템에 부하나 장애를 야기할 수 있기 때문에 위에서 잠깐 보았던 커널 파라미터인 <code class=\"language-text\">vm.overcommit_memory</code>를 통해 메모리 커밋에 대한 제어권을 사용자가 선택할 수 있게 하였다.</p>\n<table>\n<thead>\n<tr>\n<th>파라미터 옵션</th>\n<th>동작 방시</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>기본동작 방식이며, overcommit 최댓값은 page cache + swap area + slab reclaimable 이다. (현재 가용 메모리 영역은 보지 않는다.)</td>\n</tr>\n<tr>\n<td>1</td>\n<td>무조건 commit을 진행한다. 아무것도 계산하지 않으면 요청 온 모든 메모리에 대한 commit이 발생한다.</td>\n</tr>\n<tr>\n<td>2</td>\n<td>제한적으로 commit을 진행한다. <code class=\"language-text\">vm.overcommit_ratio</code>에 대한 비율과 swap 영역에 대한 크기를 토대로 계산된다. (/proc/meminfo 에서 확인가능)</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"step-23-프로세스의-상태\" style=\"position:relative;\"><a href=\"#step-23-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%81%ED%83%9C\" aria-label=\"step 23 프로세스의 상태 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.3 프로세스의 상태</h3>\n<p>위에서는 <code class=\"language-text\">VIRT</code>, <code class=\"language-text\">RES</code>, <code class=\"language-text\">SHR</code>를 다루면서 메모리 커밋에 대해서도 다뤘었다. 이제 <code class=\"language-text\">top</code> 명령어를 볼 수 있는 지표 중에 프로세스의 상태를 보는 지표를 확인할 차례이다.</p>\n<p><img src=\"https://i.imgur.com/CN6oaqZ.png\" alt=\"\"></p>\n<p>해당 지표는 <code class=\"language-text\">SHR</code> 옆에 보이는 <code class=\"language-text\">S</code>라는 값이며 각 프로세스의 상태를 나타낸다.\n프로세스의 상태는 아래와 같다.</p>\n<table>\n<thead>\n<tr>\n<th>상태 플래그 값</th>\n<th>상태</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>D</td>\n<td>디스크 혹은 네트워크 I/O를 대기하는 프로세스 (<code class=\"language-text\">TASK_UNINTERRUPTIBLE</code> 상태와 비슷)</td>\n</tr>\n<tr>\n<td>R</td>\n<td>실행 중인 프로세스를 의미하며, 실제로 CPU 자원을 소모하고 있는 프로세스 (<code class=\"language-text\">TASK_RUNNING</code> 상태와 비슷)</td>\n</tr>\n<tr>\n<td>S</td>\n<td>D 상태와 비슷하지만, 조기에 깨울 수 있는 상태의 프로세스 (<code class=\"language-text\">TASK_INTERRUPTIBLE</code> 상태와 비슷)</td>\n</tr>\n<tr>\n<td>T</td>\n<td><code class=\"language-text\">strace</code> 등으로 프로세스의 시스템 콜을 추적하고 있는 상태의 프로세스(<code class=\"language-text\">__TASK_TRACED</code> 혹은 <code class=\"language-text\">__TASK_STOPPED</code> 상태와 비슷)</td>\n</tr>\n<tr>\n<td>Z</td>\n<td>좀비상태의 프로세스로, 부모 프로세스가 죽은 자식 프로세스이다.</td>\n</tr>\n</tbody>\n</table>\n<p>위 값을 잘보면 우리가 서론에서 Run Queue와 Wait Queue를 다루면서 했던 내용과 흡사하다고 볼 수 있다.\n우리는 어느정도 이 개념에 대해서 알고 있으니 바로 프로세스 상태 변화표를 확인해보자.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/zmNE7a6.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.yes24.com/Product/Goods/44376723\">그림 14. 프로세스 상태 변화, DevOps와 SE를 위한 리눅스 커널, p.28</a></em>\n</p>\n<p>아마도 서론을 잘 읽었던 분이라면 이 부분에 대해서 이해하기 수월할 것이라고 생각한다.  위에서 다루지 않았던 내용은 좀비 상태 뿐인데 이건 아래의 표로 설명이 가능하다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/dVDQC44.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.yes24.com/Product/Goods/44376723\">그림 15. 프로세스 생성과 종료, DevOps와 SE를 위한 리눅스 커널, p.33</a></em>\n</p>\n<p>위 그림은 <code class=\"language-text\">fork()</code>를 통해서 자식 프로세스가 생성되는 모습을 보여주고 있다. 이런 케이스에 부모 프로세스가 죽었는데 자식 프로세스가 남아 있거나 자식 프로세스의 비정상 동작으로 부모 프로세스가 죽을 수 있다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/4wG4l9Q.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.yes24.com/Product/Goods/44376723\">그림 16. 좀비 프로세스가 되는 경우, DevOps와 SE를 위한 리눅스 커널, p.33</a></em>\n</p>\n<p>위와 같은 케이스가 좀비 프로세스가 된다고 보면 된다. 좀비 프로세스는 시스템의 리소스를 차지하지 않으므로 큰 문제는 되지 않으나 PID는 대략 65536개로 생성이 가능하기때문에 이 PID를 점유하고 있고, 새로운 프로세스가 할당될 PID가 부족하여 PID 고갈을 야기할 수 있다.</p>\n<h3 id=\"24-프로세스의-우선순위\" style=\"position:relative;\"><a href=\"#24-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84\" aria-label=\"24 프로세스의 우선순위 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.4 프로세스의 우선순위</h3>\n<p>이제는 <code class=\"language-text\">top</code> 명령어에서 볼 수 있는 지표인 <code class=\"language-text\">PR</code>과 <code class=\"language-text\">NI</code>에 대해서 알아보고자 한다.</p>\n<p><img src=\"https://i.imgur.com/n6IROxy.png\" alt=\"\"></p>\n<p>이 두 개의 값은 모두 프로세스 우선순위와 연관되어있다.\nRun Queue와 Wait Queue 과정에서 각 프로세스들이 어떻게 휴면상태로 바뀌고 다시 런상태로 바뀌고, 스케줄러가 해당 태스크들을 처리한다고 하였다.\n이때, 실행될 프로세스의 우선순위를 통해서 스케줄러가 디스패처라는 개념에게 해당 프로세스에 대한 정보를 넘겨준다고 보면된다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/bXW9o3Q.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.yes24.com/Product/Goods/44376723\">그림 17. 스케줄러의 기본 동작, DevOps와 SE를 위한 리눅스 커널, p.35</a></em>\n</p>\n<p>그렇다면, <code class=\"language-text\">PR</code>과 <code class=\"language-text\">NI</code> 지표는 어떤 것을 나타낼까?</p>\n<table>\n<thead>\n<tr>\n<th>지표</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>PR</td>\n<td>커널에서 인식하는 해당 프로세스의 실제 우선순위 값</td>\n</tr>\n<tr>\n<td>NI</td>\n<td>nice값이라 부르며, 명령어를 통해 우선순위를 낮출 때 사용된다. (즉, 이 값을 통해서 PR 값을 낮출 수 있다.)</td>\n</tr>\n</tbody>\n</table>\n<p>실제로 nice 값을 낮추면 우선순위 낮은 프로세스가 먼저 수행될까?</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">#!/usr/bin/python\n\nimport datetime\n\nstart_time = datetime.datetime.now()\nprint(&quot;START : &quot; + str(start_time))\n\nsum = 0\n\nfor i in range(1,1000000000):\n    sum = sum + i\n    #print(i)\nprint(sum)\n\nend_time = datetime.datetime.now()\nprint(&quot;END : &quot; + str(end_time))\n\nelapsed_time = end_time - start_time\nprint(&quot;Elapsed : &quot; + str(elapsed_time))</code></pre></div>\n<p>위와 같은 파이썬 코드를 주고, 아래와 같이 두 개의 프로세스를 구동 시켰다.</p>\n<p><img src=\"https://i.imgur.com/tT3WdYH.png\" alt=\"\"></p>\n<p>책에서는 5000만건으로 처리했는데 M1 Pro 프로세서의 단일 코어 성능이 좋아서 그런지 원하던 결과가 안나와서 10억번 반복을 돌도록 처리하였다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">ubuntu@ubuntu:~/example$ sudo python3 ex.py\nSTART : 2023-08-23 10:53:48.624415\n499999999500000000\nEND : 2023-08-23 10:55:23.304349\nElapsed : 0:01:34.679934\n\nubuntu@ubuntu:~/example$ sudo nice -n -20 python3 ex.py\nSTART : 2023-08-23 10:53:48.879665 # nice를 -20으로 우선순위(PR)을 0으로 할당된 프로세스가 아래의 프로세스보다 늦게 수행\n499999999500000000\nEND : 2023-08-23 10:55:21.738873 # 그러나 더 빨리 처리된 모습을 볼 수 있다.\nElapsed : 0:01:32.859208\n\nubuntu@ubuntu:~/example$ grep -c processor /proc/cpuinfo\n1</code></pre></div>\n<p>VM으로 단일 코어로 처리했을 경우에 나오는 결과이다.\n그러나, 단일 코어가 아닐 경우에는 위와 같이 nice값으로 우선순위를 올린 프로세스가 먼저 끝나는 것을 보장할 수가 없다.</p>\n<p>이유는 바로 병렬성과 관련되어있다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/w1oQ1VG.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.yes24.com/Product/Goods/44376723\">그림 18. nice의 효과를 못 받는 경우, DevOps와 SE를 위한 리눅스 커널, p.37</a></em>\n</p>\n<p>2개 코어라고 가정하였을 경우 각각 코어 마다 Run Queue가 위치한다고 말했었다. 그러다보니 nice 값을 낮춰도 다른 코어에서 프로세스를 충분히 돌릴 수 있다면 nice 값을 낮춘 프로세스보다 빨리 끝날 수 있다.\n실제 시작할 프로세스에 대한 nice 값은 <code class=\"language-text\">nice</code> 명령어로 처리할 수 있으며, 동작 중인 프로세스에 대한 핸들링은 <code class=\"language-text\">renice</code> 명령을 통해서 낮출 수 있다.</p>\n<p>이때 사용되는 스케줄 방식이 바로 CFS(Completely Fair Scheduling)이다.</p>\n<h3 id=\"step-3-load-averrage와-시스템-부하\" style=\"position:relative;\"><a href=\"#step-3-load-averrage%EC%99%80-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%B6%80%ED%95%98\" aria-label=\"step 3 load averrage와 시스템 부하 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3. Load Averrage와 시스템 부하</h3>\n<p>리눅스에서는 Load Average를 아래와 같이 정의한다.</p>\n<blockquote>\n<p>R과 D인 상태의 프로세스의 개수의 1분, 5분, 15분마다의 평균 값</p>\n</blockquote>\n<p>즉, 얼마나 많은 프로세스가 실행 / 실행 대기 중이냐를 의미하는 수치이다.\n이 값이 높다면 많은 수의 프로세스가 실행 중이거나 I/O를 처리하기 위해 대기 상태 있다는 것이고 낮으면 적은 수의 프로세스가 그렇다는 것이다.</p>\n<p>이는 위에서 본 바와 같이 CPU 코어 수에 따라서 상대적이다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/OtiERRi.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.yes24.com/Product/Goods/44376723\">그림 19. CPU 코어와 프로세스의 관계, DevOps와 SE를 위한 리눅스 커널 이야기, p.42</a></em>\n</p>\n<p>두 개 모두 Load Average값은 2의 근사 값이 나올 것이다. (프로세스의 개수를 뜻하기 때문에) 그러나, 단일 코어일 경우에는 Run Queue에 두 개의 프로세스가 있으며, 듀얼 코어일 경우에는 각 Run Queue에 분리되어서 동작한다.\n즉, 병렬성이 보장되므로 듀얼코어인 케이스가 싱글코어인 케이스보다 대기 상태가 적을 수 밖에 없다.</p>\n<p>따라서, 같은 Load Average라고 해도 CPU 코어 수에 따라 의미가 달라질 수 있다.</p>\n<p>실제 커널 코드는 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// linux/kernel/sched/ladavg.c</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">get_avenrun</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> <span class=\"token operator\">*</span>loads<span class=\"token punctuation\">,</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> offset<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> shift<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\tloads<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>avenrun<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> offset<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> shift<span class=\"token punctuation\">;</span>\n\tloads<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>avenrun<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> offset<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> shift<span class=\"token punctuation\">;</span>\n\tloads<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>avenrun<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> offset<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> shift<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">calc_global_load</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">(</span>중략<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t\n\tactive <span class=\"token operator\">=</span> <span class=\"token function\">atomic_long_read</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>calc_load_tasks<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// calc_load_tasks 값을 atomic_long_read() 매크로 함수를 통해서 읽은 후 active에 넣는다.</span>\n\tactive <span class=\"token operator\">=</span> active <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span> active <span class=\"token operator\">*</span> FIXED_1 <span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n\tavenrun<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">calc_load</span><span class=\"token punctuation\">(</span>avenrun<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> EXP_1<span class=\"token punctuation\">,</span> active<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tavenrun<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">calc_load</span><span class=\"token punctuation\">(</span>avenrun<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> EXP_5<span class=\"token punctuation\">,</span> active<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tavenrun<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">calc_load</span><span class=\"token punctuation\">(</span>avenrun<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> EXP_15<span class=\"token punctuation\">,</span> active<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// active 값을 바탕으로 avenrun[] 배열에 있는 값들을 calc_load_n() 함수를 이용해서 계산한다.</span>\n\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">(</span>중략<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">long</span> <span class=\"token function\">calc_load_fold_active</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">rq</span> <span class=\"token operator\">*</span>this_rq<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> adjust<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">long</span> nr_active<span class=\"token punctuation\">,</span> delta <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n\tnr_active <span class=\"token operator\">=</span> this_rq<span class=\"token operator\">-></span>nr_running <span class=\"token operator\">-</span> adjust<span class=\"token punctuation\">;</span> <span class=\"token comment\">// nr_active 변수에 Run Queue기준으로 nr_running 상태의 개수를 adjust값을 뺴서 입력한다. (R 상태 프로세스)</span>\n\tnr_active <span class=\"token operator\">+=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>this_rq<span class=\"token operator\">-></span>nr_uninterruptible<span class=\"token punctuation\">;</span> <span class=\"token comment\">// nr_uniterruptible 프로세스 개수도 nr_active 변수에 더해준다 (D 상태 프로세스)</span>\n\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nr_active <span class=\"token operator\">!=</span> this_rq<span class=\"token operator\">-></span>calc_load_active<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\tdelta <span class=\"token operator\">=</span> nr_active <span class=\"token operator\">-</span> this_rq<span class=\"token operator\">-></span>calc_load_active<span class=\"token punctuation\">;</span> \n\t\tthis_rq<span class=\"token operator\">-></span>calc_load_active <span class=\"token operator\">=</span> nr_active<span class=\"token punctuation\">;</span> <span class=\"token comment\">// nr_active 값이 기존 값과 다르면 clac_load_active 변수에 입력한다.</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">return</span> delta<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<ul>\n<li>참고 코드 1: <a href=\"https://github.com/torvalds/linux/blob/master/kernel/sched/loadavg.c#L71C1-L76\">linux/kernel/sched/loadavg.c - L71 ~ 76</a></li>\n<li>참고 코드 2 : <a href=\"https://github.com/torvalds/linux/blob/master/kernel/sched/loadavg.c#L349C1-L380C1\">linux/kernel/sched/loadavg.c - - L349 ~ 380</a></li>\n<li>참고 코드 3 : <a href=\"https://github.com/torvalds/linux/blob/master/kernel/sched/loadavg.c#L78-L91\">linux/kernel/sched/loadavg.c - L78 ~ 91</a></li>\n</ul>\n<p>책에서 사용하는 커널버전과 다르다보니 좀 더 변경된 부분이 있으나, 매번 Tick 주기에 호출되는 <a href=\"https://github.com/torvalds/linux/blob/master/kernel/sched/core.c#L5640\">schedule_tick(void)</a> 함수를 보면 책에 나온 <code class=\"language-text\">calc_laod_account_active()</code> 함수 대신 <code class=\"language-text\">calc_global_load_tick()</code> 함수로 변경되었고, 이 함수 내부적으로 <code class=\"language-text\">calc_load_fold_active()</code> 함수를 호출하는 방식을 볼 수 있다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/awmZ9Ts.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.yes24.com/Product/Goods/44376723\">그림 20. Load Average의 계산 과정, DevOps와 SE를 위한 리눅스 커널 이야기, p.47</a></em>\n</p>\n<p>위 내용을 정리하면 위와 같이 볼 수 있다. 함수명은 위에서 말한 듯이 커널 버전이 올라감에 따라 달라진 부분이 있으니 참고바란다.\n결국 서두에서도 얘기했듯 R과 D 상태의 프로세스의 개수를 세는 것을 Load Average로 볼 수 있다.</p>\n<h4 id=\"step-31-cpu-bound-vs-io-bound\" style=\"position:relative;\"><a href=\"#step-31-cpu-bound-vs-io-bound\" aria-label=\"step 31 cpu bound vs io bound permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.1 CPU Bound vs I/O Bound</h4>\n<p>따라서, Load Average 값이 높은 부분은 CPU가 많이 사용되는 프로세스(R)가 많을 수도 있고, I/O 대기에 따른 프로세스(D)가 많아서 일수 있다.\n즉, 이 값만으로는 어떤 부하가 시스템이 겪고 있는지 알기가 힘든 것이다.</p>\n<p>이를 단순하게 확인하기 위해서 아래 2가지 파이썬 코드를 돌려보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">#!/usr/bin/python\n### CPU Bound 어플리케이션 예시\n\ntest = 0\n\n\nwhile True:\n\ttest = test + 1\n\n#!/usr/bin/python\n### I/O Bound 어플리케이션 예시\n\nwhile True:\n\tf = open(&quot;./io_test.txt&quot;, &#39;w&#39;)\n\tf.write(&quot;test&quot;)\n\tf.close()</code></pre></div>\n<p>자 이 두가지 스크립트를 돌려보자\n먼저 CPU Bound 어플리케이션일 경우다.</p>\n<p><img src=\"https://i.imgur.com/sctfpuy.png\" alt=\"\"></p>\n<p>실제로 Load Average가 올라감을 확인할 수 있다.\n그렇다면, I/O Bound 어플리케이션은 어떨까?</p>\n<p><img src=\"https://i.imgur.com/BEitHl1.png\" alt=\"\"></p>\n<p>어떻게 보면 둘다 비슷한 Load Average를 보여주지만 실제로 주는 부하의 형태는 매우 다르다.\n부하의 종류에 따라서 해결방법도 달라진다.</p>\n<p>여기서는 단순한 파이썬 스크립트를 통해서 보여줬지만 실제 웹 어플리케이션이나 실무에서 겪는 문제에서도 이 문제를 해결하는 방식은 달라진다.\nCPU Bound 어플리케이션으로 인해 부하가 발생하면 신규 인스턴스를 투입하거나 로드밸런싱으로 부하분산을 할 수 있으나 I/O같은 경우에는 주로 DB같은데서 부하가 발생하므로 이중화해도 결국 똑같은 문제이다.\n이는 별도로 처리를 해줘야한다.</p>\n<p>이에 대해서 아주 자세히 설명한 강의가 있어서 이를 링크로 남겨본다.</p>\n<ul>\n<li><a href=\"https://class101.net/classic/products/T6HT0bUDKIH1V5i3Ji2M\">현직 대기업 개발자 푸와 함께하는 진짜 백엔드 시스템 실무!</a></li>\n</ul>\n<p>그렇다면, Load Average가 부하의 성격은 보여주지 않는데 CPU Bound인지 I/O Bound인지 파악할 수 있는 방법이 있을까?\n바로 <code class=\"language-text\">vmstat</code> 을 통해서 해결할 수 있다.</p>\n<p>CPU Bound 어플리케이션을 수행 후에 확인해보자.</p>\n<p><img src=\"https://i.imgur.com/f1akP5D.png\" alt=\"\"></p>\n<p>이제 I/O Bound 어플리케이션을 수행 후에 확인해보자.</p>\n<p><img src=\"https://i.imgur.com/dAtEzvt.png\" alt=\"\"></p>\n<p>포인트는 바로 <code class=\"language-text\">r</code> 과 <code class=\"language-text\">b</code> 열이다</p>\n<ul>\n<li>r : 실행되기를 기다리거나 현재 실행되고 있는 프로세스의 개수 (nr_running)</li>\n<li>b : I/O를 위해 대기열에 있는 프로세스의 개수 (nr_uniterruptible)</li>\n</ul>\n<p>실제로 이러한 부하는 운영하는 입장에서 시스템에 미치는 영향은 다양하다.\n이 때문에 실무에서 이러한 지표를 수집하는 것이라 볼 수 있다.</p>\n<h1 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h1>\n<p>이 책은 어떠한 명령어를 통해서 어떤 지표를 봐야하는 지와 그와 관련된 커널 내부 매커니즘을 설명한다.\n그렇다보니 OS에 대한 기본 배경지식이 없다면 읽기에 난이도가 높을 수 있다고 볼 수 있다.</p>\n<p>하지만, 책 자체가 친절하게 적혀있어서 더 궁금한 부분은 독자들의 몫으로 남겨줬다고 생각한다.</p>\n<p>우리는 초기에 이 기본 개념들을 이해하기 위한 최소한의 배경지식을 배웠고, 그 뒤로 커널 스케줄링이나 컨텍스트 스위치 개념 그리고 Load Average에 대한 개념을 배우게 되었다.\n책에서는 웹서버를 실제로 열어서 Load Average를 재곤했는데 이 부분은 생략하였다.</p>\n<p>궁금하신 분이 계시다면 책을 사서 읽기를 추천드린다.</p>\n<p>커널 공부를 하면서 느끼는 점은 결국 기본기가 매우 중요하다는 점이다.\n특히, 운영체제는 공부할 내용도 방대하고 엄두가 안날 때가 많다. 하지만 운영체제에서 쓰이는 개념들은 결국 웹 어플리케이션이나 프로그래밍 언어에서도 쓰인다.</p>\n<p>대표적으로 자바의 NIO에서는 기존 I/O의 성능을 올리기 위해서 OS 레벨의 기능들을 제공해주는데 그 중 대표적인 기능이 MMIO다.\n또한, 실제 어플리케이션들을 운영할 때 왜 이런식으로 튜닝하기를 권장하는 지 등도 운영체제를 공부하는데 도움이 된다.</p>\n<p>위 내용과 관련된 필자의 포스팅은 아래와 같다.</p>\n<ol>\n<li><a href=\"https://brewagebear.github.io/fundamental-nio-and-io-models/\">자바 NIO의 동작원리 및 IO 모델</a></li>\n<li><a href=\"https://brewagebear.github.io/fundamental-os-page-cache/\">왜 처리량이 중요한 JVM 어플리케이션은 vm.swappiness = 1로 설정하라고 할까?</a></li>\n</ol>\n<p>필자는 무협소설이나 웹툰을 좋아하는 편인데 무협지에는 이러한 대사가 많이 나온다.</p>\n<blockquote>\n<p>수단과 과정은 달라도 극에 달하면 결국 같은 걸로 귀결 된다. 정파든 사파든 마도든 극에 이르는 것은 같다.</p>\n</blockquote>\n<p>즉, 만류귀종이라고 볼 수 있다. 요즘 추상화된 레벨보다는 로우레벨 배경의 공부를 하다보니 문뜩 든 생각이었다.\n어? 이 개념 이거랑 같은데? 보면 비슷하고 그랬었다. 아직은 무림초출급 내공이지만 언젠가 공부를 계속하다보면 극에 달할 때가 올까?</p>\n<p>그 부분은 모르겠지만 궁금해서 하는 공부가 제일 재밌는 것 같다.</p>\n<h1 id=\"참고자료\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\" aria-label=\"참고자료 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고자료</h1>\n<ol>\n<li><a href=\"https://cs4118.github.io/www/2023-1/\">COMS W4118 Operating Systems 1 - Columbia University</a></li>\n<li><a href=\"https://blog.naver.com/PostView.naver?blogId=crushhh&#x26;logNo=221568455956\">시그널: 유저 공간에서 pause() 함수 호출 시 커널 실행 흐름 파악하기 - Austin Kim</a></li>\n<li><a href=\"http://books.gigatux.nl/mirror/kerneldevelopment/0672327201/ch04lev1sec2.html\">The Liunx Scheduling Algorithm - Team LiB</a></li>\n<li><a href=\"https://blog.naver.com/sysapi/20011482139\">wait Queue - 달려라</a></li>\n<li><a href=\"http://csl.snu.ac.kr/courses/4190.307/2020-1/9-mmap.pdf\">Memory Mapping - Seoul National University</a></li>\n<li><a href=\"https://docs.kernel.org/admin-guide/mm/concepts.html\">Concepts overview - The Linux Kernel Admin Guide</a></li>\n</ol>\n<h1 id=\"읽을거리\" style=\"position:relative;\"><a href=\"#%EC%9D%BD%EC%9D%84%EA%B1%B0%EB%A6%AC\" aria-label=\"읽을거리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>읽을거리</h1>\n<ol>\n<li><a href=\"https://freecontent.manning.com/concurrency-vs-parallelism/\">concurrency-vs-parallelism</a></li>\n<li><a href=\"https://class101.net/classic/products/T6HT0bUDKIH1V5i3Ji2M\">현직 대기업 개발자 푸와 함께하는 진짜 백엔드 시스템 실무!</a></li>\n<li><a href=\"https://brewagebear.github.io/fundamental-nio-and-io-models/\">자바 NIO의 동작원리 및 IO 모델</a></li>\n<li><a href=\"https://brewagebear.github.io/fundamental-os-page-cache/\">왜 처리량이 중요한 JVM 어플리케이션은 vm.swappiness = 1로 설정하라고 할까?</a></li>\n</ol>","frontmatter":{"date":"August 23, 2023","title":"[Kernel] 리눅스 스케줄링 매커니즘과 Load Average","categories":"개발 인프라 독서요약","author":"개발한입","emoji":"💻"},"fields":{"slug":"/linux-kernel-internal-1/"}},"prev":{"id":"5310b836-4bc3-57fa-8fb0-a520045f1c27","html":"<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#step-1-%EC%86%8C%EC%BC%93%EC%9D%B4%EB%9E%80\">STEP 1. 소켓이란?</a></p>\n<ul>\n<li>\n<p><a href=\"#step-11-%EC%86%8C%EC%BC%93%EC%9D%98-%EC%A2%85%EB%A5%98\">STEP 1.1 소켓의 종류</a></p>\n<ul>\n<li><a href=\"#step-111-%EC%8A%A4%ED%8A%B8%EB%A6%BC-%EC%86%8C%EC%BC%93\">STEP 1.1.1 스트림 소켓</a></li>\n<li><a href=\"#step-112-%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B7%B8%EB%9E%A8-%EC%86%8C%EC%BC%93\">STEP 1.1.2 데이터그램 소켓</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-2-%EC%BB%A4%EB%84%90-%EC%BD%94%EB%93%9C%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-tcp%EC%99%80-%EC%86%8C%EC%BC%93\">STEP 2. 커널 코드로 알아보는 TCP와 소켓</a></p>\n<ul>\n<li>\n<p><a href=\"#step-21-%EC%BB%A4%EB%84%90-%EC%BD%94%EB%93%9C%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-tcp-handshake-%EA%B3%BC%EC%A0%95\">STEP 2.1 커널 코드로 알아보는 TCP Handshake 과정</a></p>\n<ul>\n<li><a href=\"#step-211-3-way-handshake\">STEP 2.1.1 3-Way Handshake</a></li>\n<li><a href=\"#step-212-4-way-handshake\">STEP 2.1.2 4-Way HandShake</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-22-%EC%BB%A4%EB%84%90-%EC%BD%94%EB%93%9C%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-tcp-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%86%A1%EC%88%98%EC%8B%A0-%EA%B3%BC%EC%A0%95\">STEP 2.2 커널 코드로 알아보는 TCP 메시지 송/수신 과정</a></p>\n<ul>\n<li><a href=\"#step-221-tcp-%EC%86%A1%EC%8B%A0-%EA%B3%BC%EC%A0%95\">STEP 2.2.1 TCP 송신 과정</a></li>\n<li><a href=\"#step-222-tcp-%EC%88%98%EC%8B%A0-%EA%B3%BC%EC%A0%95\">STEP 2.2.2 TCP 수신 과정</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-3-tcp-%EC%82%AC%EC%9A%A9-%EC%8B%9C-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%97%90%EC%84%9C-%EA%B2%AA%EC%9D%84-%EC%88%98-%EC%9E%88%EB%8A%94-%EB%AC%B8%EC%A0%9C%EB%93%A4\">STEP 3. TCP 사용 시 서비스에서 겪을 수 있는 문제들</a></p>\n<ul>\n<li>\n<p><a href=\"#step-31-time_wait-%EC%86%8C%EC%BC%93\">STEP 3.1 TIME_WAIT 소켓</a></p>\n<ul>\n<li><a href=\"#step-311-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%B8%A1%EB%A9%B4\">STEP 3.1.1 클라이언트 측면</a></li>\n<li><a href=\"#step-312-%EC%84%9C%EB%B2%84-%EC%B8%A1%EB%A9%B4\">STEP 3.1.2 서버 측면</a></li>\n<li><a href=\"#step-313-time_wait-%EC%86%8C%EC%BC%93%EC%9D%98-%EC%A1%B4%EC%9E%AC-%EC%9D%98%EC%9D%98\">STEP 3.1.3 TIME_WAIT 소켓의 존재 의의</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-33-tcp-keep-alive\">STEP 3.3 TCP Keep-Alive</a></p>\n<ul>\n<li><a href=\"#step-331-tcp-keep-alive-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0\">STEP 3.3.1 TCP Keep-Alive 파라미터</a></li>\n<li><a href=\"#step-332-%EC%A2%80%EB%B9%84-%EC%BB%A4%EB%84%A5%EC%85%98\">STEP 3.3.2 좀비 커넥션</a></li>\n<li><a href=\"#step-333-http-%EC%A7%80%EC%86%8D%EC%BB%A4%EB%84%A5%EC%85%98-vs-tcp-keep-alive\">STEP 3.3.3 HTTP 지속커넥션 vs TCP Keep-Alive</a></li>\n<li><a href=\"#step-334-%EB%A1%9C%EB%93%9C-%EB%B0%B8%EB%9F%B0%EC%84%9C%EC%99%80-tcp-keep-alive\">STEP 3.3.4 로드 밸런서와 TCP Keep-Alive</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-34-tcp-%EC%9E%AC%EC%A0%84%EC%86%A1%EA%B3%BC-%ED%83%80%EC%9E%84%EC%95%84%EC%9B%83\">STEP 3.4 TCP 재전송과 타임아웃</a></p>\n<ul>\n<li><a href=\"#step-341-tcp-%EC%9E%AC%EC%A0%84%EC%86%A1-%EC%BB%A4%EB%84%90%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0\">STEP 3.4.1 TCP 재전송 커널파라미터</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-4--%EA%B2%B0%EB%A1%A0\">STEP 4.  결론</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4\">레퍼런스</a></p>\n</li>\n</ul>\n</div>\n<h1 id=\"개요\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EC%9A%94\" aria-label=\"개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개요</h1>\n<p>이번 내용은 커널 저변에 깔린 소켓에 대한 내용과 소켓을 처리하는 TCP에 대해서 살펴볼 예정이다.</p>\n<p>원래는 NUMA를 다룰려 했으나 다른 스터디 팀원분께서 정리하는걸 기대하고 필자는 소켓과 TCP를 중점적으로 설명해보고자 한다.</p>\n<p>간략하게 이번 포스팅의 내용을 소개하면 아래와 같다.</p>\n<p><strong>소켓이 무엇인지와 TCP는 어떻게 실제 연결 수립/해제가 이뤄지고, 메시지를 송/수신 하는지?</strong></p>\n<p><strong>그리고 TCP로 인해 발생할 수 있는 서비스의 문제점</strong>들이라 보면 될 것같다.</p>\n<h2 id=\"step-1-소켓이란\" style=\"position:relative;\"><a href=\"#step-1-%EC%86%8C%EC%BC%93%EC%9D%B4%EB%9E%80\" aria-label=\"step 1 소켓이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1. 소켓이란?</h2>\n<p>우리가 개발을 하면서 소켓(Socket)이라는 단어는 수도 없이 많이 들어보았을 것이다.</p>\n<p>네트워크 저변에는 소켓으로 통신을 하는데 그렇다면 이 소켓의 정의는 무엇일까?</p>\n<blockquote>\n<p>A way to speak to other programs using standard Unix file descriptors</p>\n<ul>\n<li>Beej’s Guide to Network Programming Using Internet Sockets</li>\n</ul>\n</blockquote>\n<p>뜻을 해석하면, <strong>표준 유닉스 파일 디스크럽터(File Descriptors)를 통해서 다른 프로그램과 정보를 교환하는 방법</strong>이라고 해석할 수 있을 것이다.</p>\n<p>왜 뜬금없이 파일 디스크럽터가 나왔을까? 이 부분은 UNIX 진영에서 얘기하는 <strong>“Everything is a file”</strong><sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup> 라는 개념을 이해해야한다.</p>\n<p>간단히 얘기하자면, <strong>다양한 리소스에 발생하는 입/출력을 단순한 파일과 같은 바이트 스트림으로 처리한다는 개념</strong>인데, 소켓도 여기에 해당하므로 위와 같은 정의를 내릴 수 있는 것이다.</p>\n<p>잘 생각해보면 우리가 네트워크에 어떠한 데이터를 보낼 때 바이트 직렬화와 역직렬화 과정을 거치는데 이 이유가 <strong>“Everything is a file”</strong><sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup> 의 개념때문이라고도 볼 수 있다.</p>\n<p>그렇다면 파일 디스크럽터는 어떻게 가져올 수 있을까? 그것은 바로 시스템 콜중에 하나인 <code class=\"language-text\">socket()</code> 을 통해서 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// https://github.com/torvalds/linux/blob/master/net/socket.c#L1625</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">socket</span> <span class=\"token operator\">*</span><span class=\"token function\">__sys_socket_create</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> family<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> type<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> protocol<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">socket</span> <span class=\"token operator\">*</span>sock<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> retval<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\">/* Check the SOCK_* constants for consistency.  */</span>\n\t<span class=\"token function\">BUILD_BUG_ON</span><span class=\"token punctuation\">(</span>SOCK_CLOEXEC <span class=\"token operator\">!=</span> O_CLOEXEC<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">BUILD_BUG_ON</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>SOCK_MAX <span class=\"token operator\">|</span> SOCK_TYPE_MASK<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> SOCK_TYPE_MASK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">BUILD_BUG_ON</span><span class=\"token punctuation\">(</span>SOCK_CLOEXEC <span class=\"token operator\">&amp;</span> SOCK_TYPE_MASK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">BUILD_BUG_ON</span><span class=\"token punctuation\">(</span>SOCK_NONBLOCK <span class=\"token operator\">&amp;</span> SOCK_TYPE_MASK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>type <span class=\"token operator\">&amp;</span> <span class=\"token operator\">~</span>SOCK_TYPE_MASK<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> <span class=\"token operator\">~</span><span class=\"token punctuation\">(</span>SOCK_CLOEXEC <span class=\"token operator\">|</span> SOCK_NONBLOCK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token function\">ERR_PTR</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>EINVAL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\ttype <span class=\"token operator\">&amp;=</span> SOCK_TYPE_MASK<span class=\"token punctuation\">;</span>\n\n\tretval <span class=\"token operator\">=</span> <span class=\"token function\">sock_create</span><span class=\"token punctuation\">(</span>family<span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">,</span> protocol<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>sock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>retval <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token function\">ERR_PTR</span><span class=\"token punctuation\">(</span>retval<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">return</span> sock<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// https://github.com/torvalds/linux/blob/master/net/socket.c#L1686</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">__sys_socket</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> family<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> type<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> protocol<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">socket</span> <span class=\"token operator\">*</span>sock<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> flags<span class=\"token punctuation\">;</span>\n\n\tsock <span class=\"token operator\">=</span> <span class=\"token function\">__sys_socket_create</span><span class=\"token punctuation\">(</span>family<span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">,</span>\n\t\t\t\t   <span class=\"token function\">update_socket_protocol</span><span class=\"token punctuation\">(</span>family<span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">,</span> protocol<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">IS_ERR</span><span class=\"token punctuation\">(</span>sock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token function\">PTR_ERR</span><span class=\"token punctuation\">(</span>sock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\tflags <span class=\"token operator\">=</span> type <span class=\"token operator\">&amp;</span> <span class=\"token operator\">~</span>SOCK_TYPE_MASK<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>SOCK_NONBLOCK <span class=\"token operator\">!=</span> O_NONBLOCK <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>flags <span class=\"token operator\">&amp;</span> SOCK_NONBLOCK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\t\tflags <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>flags <span class=\"token operator\">&amp;</span> <span class=\"token operator\">~</span>SOCK_NONBLOCK<span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span> O_NONBLOCK<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">return</span> <span class=\"token function\">sock_map_fd</span><span class=\"token punctuation\">(</span>sock<span class=\"token punctuation\">,</span> flags <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span>O_CLOEXEC <span class=\"token operator\">|</span> O_NONBLOCK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// https://github.com/torvalds/linux/blob/master/net/socket.c#L1703</span>\n<span class=\"token function\">SYSCALL_DEFINE3</span><span class=\"token punctuation\">(</span>socket<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> family<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> protocol<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token function\">__sys_socket</span><span class=\"token punctuation\">(</span>family<span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">,</span> protocol<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 함수가 실제 시스템 콜의 내부 구현 부분이다. 실제 호출 흐름은 아래와 같다.</p>\n<ol>\n<li>유저 공간에서 <code class=\"language-text\">socket()</code> 함수 호출</li>\n<li>커널에서 시스템콜 인터페이스를 통하여 <code class=\"language-text\">SYSCALL_DEFINE3</code> -> <code class=\"language-text\">__sys_socket()</code> 함수 호출</li>\n<li><code class=\"language-text\">__sys_socket()</code> 함수 호출 시 내부적으로 <code class=\"language-text\">__sys_socket_create()</code> 함수 호출을 통해 소켓 생성</li>\n<li><code class=\"language-text\">__sys_socket()</code>은 전달받은 소켓을 파일 디스크럽터에 매핑하여 파일 디스크립터를 유저공간에 반환</li>\n<li>유저 공간에서 반환 받은 파일 디스크럽터를 통한 다양한 I/O 작업 수행</li>\n</ol>\n<p>이러한 방식으로 FD를 얻게된 후 <code class=\"language-text\">send(), recv()</code> 같은 함수를 통해서 정보교환을 할 수 있는 것이다.</p>\n<p>그림으로 보면 아래와 같다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/ERkokdv.png\">\n</p>\n<p align=\"center\">\n    <em>그림 1. 소켓 생성 과정</em>\n</p>\n<p>그렇다면 글을 읽는 독자분들께서는 이러한 궁금증이 생길 수도 있을 것이다.</p>\n<blockquote>\n<p>어차피, 파일을 사용하는 거면 <code class=\"language-text\">read(), write()</code> 와 같은 시스템 콜을 써서 처리해도 되지 않나요?</p>\n</blockquote>\n<p>물론 위 방식도 가능하다. 하지만 소켓도 통신 규약이 있으며 정보 제어를 하기 위해서는 <code class=\"language-text\">send(), recv()</code> 같은 함수를 쓰는걸 권장하는 것이다.</p>\n<h3 id=\"step-11-소켓의-종류\" style=\"position:relative;\"><a href=\"#step-11-%EC%86%8C%EC%BC%93%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-label=\"step 11 소켓의 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.1 소켓의 종류</h3>\n<p>소켓의 종류는 매우 다양하다. 인터넷 소켓과 유닉스 소켓, X.25 소켓 등이 존재<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup>한다.</p>\n<p>유닉스 소켓은 차후에 다룰 수 있다고 생각하는데 이번 포스팅에서는 인터넷 소켓만 다루고자 한다.</p>\n<p>인터넷 소켓도 여러 종류<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup> 가 있는데 크게 3가지이다.</p>\n<ol>\n<li>스트림 소켓(Stream Socket, <code class=\"language-text\">SOCK_STREAM</code>)</li>\n<li>데이터그램 소켓(Datagram Socket, <code class=\"language-text\">SOCK_DGRAM</code>)</li>\n<li>RAW 소켓(Raw Socket, <code class=\"language-text\">SOCK_ROW</code>)</li>\n</ol>\n<p>이번 포스팅에서는 <strong>스트림 소켓과 데이터그램 소켓</strong>에 대해서 알아보고자 한다.</p>\n<h4 id=\"step-111-스트림-소켓\" style=\"position:relative;\"><a href=\"#step-111-%EC%8A%A4%ED%8A%B8%EB%A6%BC-%EC%86%8C%EC%BC%93\" aria-label=\"step 111 스트림 소켓 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.1.1 스트림 소켓</h4>\n<p>스트림 소켓은 양측을 신뢰성있게 연결해주는 소켓이다. 어떠한 데이터를 이 소켓을 통해서 보내면 그 순서는 보장되며, 에러 검출 혹은 교정 기능까지 있다.</p>\n<blockquote>\n<p>신뢰성이 있고, 순서가 보장되며 에러 검출같은 기능들이 있는 것 이거 어디서 본 개념아닌가?</p>\n</blockquote>\n<p>지금 생각하고 있는 개념이 맞다.</p>\n<p>스트림 소켓은 <strong>TCP를 이용</strong>하기 때문에 위와 같은 기능들을 가질 수 있는 것이다.</p>\n<h4 id=\"step-112-데이터그램-소켓\" style=\"position:relative;\"><a href=\"#step-112-%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B7%B8%EB%9E%A8-%EC%86%8C%EC%BC%93\" aria-label=\"step 112 데이터그램 소켓 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.1.2 데이터그램 소켓</h4>\n<p>반면, 데이터그램 소켓은 신뢰도가 떨어지며, 비연결지향적인 특징을 지닌다.</p>\n<blockquote>\n<p>신뢰성이 없고, 비연결지향적인 특징 이것도 어디서 본 개념아닌가?</p>\n</blockquote>\n<p>아마 다들 알 것이라 생각한다. <strong>데이터그램 소켓은 UDP에서 사용하는 소켓</strong>이다.</p>\n<h2 id=\"step-2-커널-코드로-알아보는-tcp와-소켓\" style=\"position:relative;\"><a href=\"#step-2-%EC%BB%A4%EB%84%90-%EC%BD%94%EB%93%9C%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-tcp%EC%99%80-%EC%86%8C%EC%BC%93\" aria-label=\"step 2 커널 코드로 알아보는 tcp와 소켓 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2. 커널 코드로 알아보는 TCP와 소켓</h2>\n<p>위에서 간단하게 소켓의 정의와 종류에 대해서 알아보았다. 이번 포스팅에서는 <strong>스트림 소켓</strong> 즉, TCP를 집중적으로 분석해 볼 예정이다.</p>\n<p>그림1에서 간단하게 소켓 시스템 콜 시에 어떻게 소켓이 생성되고, 파일 디스크럽터를 반환하는 지를 보았다.</p>\n<p>그렇다면, 스트림 소켓의 구조는 어떻게 생겼을까?</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/tuwGhkk.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://os.korea.ac.kr/wp-content/uploads/2020/11/10_TCP-in-Linux.pdf\">그림 2. System Programming - TCP in Linux, Korea Univ, 2020, p.9</a></em>\n</p>\n<p>소켓은 다양한 구조체가 존재하는데 이 중에서 가장 추상화된 구조체가 <code class=\"language-text\">struct socket</code><sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup> 이다.</p>\n<p>이 구조체(<code class=\"language-text\">stuct socket</code><sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup>)가 종류에 따라서 결국 바깥쪽 껍데기가 다르게 씌어진다고 보면된다.</p>\n<p>그렇다면, <code class=\"language-text\">struct tcp_sock</code><sup id=\"fnref-5\"><a href=\"#fn-5\" class=\"footnote-ref\">5</a></sup> 라는 스트림 소켓은 언제 초기화가 될까? 전반적인 흐름은 위 그림과 같으나, 스트림 소켓은 <code class=\"language-text\">tcp_init_sock()</code><sup id=\"fnref-6\"><a href=\"#fn-6\" class=\"footnote-ref\">6</a></sup> 함수가 호출되면서 초기화가 된다고 보면된다.</p>\n<p><code class=\"language-text\">tcp_init_sock()</code><sup id=\"fnref-6\"><a href=\"#fn-6\" class=\"footnote-ref\">6</a></sup> 함수 호출 이후 생성된 구조체에 대한 데이터를 보면 아래와 같다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/wZcWe16.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://os.korea.ac.kr/wp-content/uploads/2020/11/10_TCP-in-Linux.pdf\">그림 3. System Programming - TCP in Linux, Korea Univ, 2020, p.11</a></em>\n</p>\n<p>여기서는 상태와 종류만 짚고 넘어가자. 중요한 <code class=\"language-text\">write, receive, backlog queue</code> 에 대해서는 통신 과정을 설명하면서 짚어보고자 한다.\n초기화 이후니 당연히 상태는 <code class=\"language-text\">SS_UNCONNECTED</code> (연결이 안된 상태) 일 것이고, TCP 소켓이므로 종류는 <code class=\"language-text\">SOCK_STREAM</code> 으로 생성되었음을 확인할 수 있다.</p>\n<h3 id=\"step-21-커널-코드로-알아보는-tcp-handshake-과정\" style=\"position:relative;\"><a href=\"#step-21-%EC%BB%A4%EB%84%90-%EC%BD%94%EB%93%9C%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-tcp-handshake-%EA%B3%BC%EC%A0%95\" aria-label=\"step 21 커널 코드로 알아보는 tcp handshake 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.1 커널 코드로 알아보는 TCP Handshake 과정</h3>\n<p>위에서는 소켓 생성과정과 스트림 소켓에 대한 초기화 과정, 구조에 대해서 간략히 살펴보았다.</p>\n<p>이제 TCP 연결 수립과 해제 과정인 3-Way Handshake와 4-Way Handshake에 대해서 커널 레벨에서 보고자 한다.</p>\n<p>우선 당연하게도 네트워크 계층에 대한 이해가 필요하다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/cqp4KBo.png\">\n</p>\n<p align=\"center\">\n    <em>그림 4. 네트워크 계층</em>\n</p>\n<p>여기서 중요한 점은 클라이언트 입장이 아닌 서버 입장에서 봐야한다는 점이다.</p>\n<p><strong>클라이언트 입장에서는 당연히 Application Layer -> Network Interface Layer의 과정을 통해서 서버에 패킷을 전송한다.</strong></p>\n<p><strong>서버 입장에서는 요청이 Network Interface Layer -> Application Layer로 처리될 것이다.</strong></p>\n<p>그림으로 보면 아래와 같다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/SYUaRAp.png\">\n</p>\n<p align=\"center\">\n    <em>그림 5. 네트워크 계층으로 보는 요청/응답 과정</em>\n</p>\n<p>우리는 클라이언트의 요청 과정보다는 서버가 응답하는 과정속에서 일어나는 과정을 보고자한다.</p>\n<p>클라이언트가 요청을 받았을 경우 TCP의 3Way-Handshake가 시작되는 지점은 어디일까?</p>\n<p>바로, 정보가 <strong>Internet Layer -> Transport Layer로 전달된 시점</strong>에 일어날 것이다.</p>\n<h4 id=\"step-211-3-way-handshake\" style=\"position:relative;\"><a href=\"#step-211-3-way-handshake\" aria-label=\"step 211 3 way handshake permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.1.1 3-Way Handshake</h4>\n<p><strong>Internet Layer -> Transport Layer로 전달된 시점</strong>에 대한 커널 코드를 보면 Handshake 과정을 추적할 수 있다.</p>\n<p>아래 코드 조각은 해당 과정에서 이뤄지는 함수들과 로직을 일부분 가져왔다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// https://github.com/torvalds/linux/blob/master/net/ipv4/ip_input.c#L560</span>\n<span class=\"token comment\">/*\n * IP receive entry point\n */</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">ip_rcv</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">sk_buff</span> <span class=\"token operator\">*</span>skb<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">net_device</span> <span class=\"token operator\">*</span>dev<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">packet_type</span> <span class=\"token operator\">*</span>pt<span class=\"token punctuation\">,</span>\n\t   <span class=\"token keyword\">struct</span> <span class=\"token class-name\">net_device</span> <span class=\"token operator\">*</span>orig_dev<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">{</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">(</span>중략<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">//https://github.com/torvalds/linux/blob/master/net/ipv4/ip_input.c#L242</span>\n<span class=\"token comment\">/*\n * \tDeliver IP Packets to the higher protocol layers.\n */</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">ip_local_deliver</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">sk_buff</span> <span class=\"token operator\">*</span>skb<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">(</span>중략<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">//https://github.com/torvalds/linux/blob/master/net/ipv4/tcp_ipv4.c#L1982</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">tcp_v4_rcv</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">sk_buff</span> <span class=\"token operator\">*</span>skb<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">(</span>중략<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">//https://github.com/torvalds/linux/blob/master/net/ipv4/tcp_ipv4.c#L1707</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">tcp_v4_do_rcv</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">sock</span> <span class=\"token operator\">*</span>sk<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">sk_buff</span> <span class=\"token operator\">*</span>skb<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">(</span>중략<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">tcp_rcv_state_process</span><span class=\"token punctuation\">(</span>sk<span class=\"token punctuation\">,</span> skb<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\trsk <span class=\"token operator\">=</span> sk<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">goto</span> reset<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t\nreset<span class=\"token operator\">:</span>\n\t<span class=\"token function\">tcp_v4_send_reset</span><span class=\"token punctuation\">(</span>rsk<span class=\"token punctuation\">,</span> skb<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">(</span>중략<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token comment\">//https://github.com/torvalds/linux/blob/master/net/ipv4/tcp_input.c#L6476</span>\n<span class=\"token comment\">/*\n *\tThis function implements the receiving procedure of RFC 793 for\n *\tall states except ESTABLISHED and TIME_WAIT.\n *\tIt's called from both tcp_v4_rcv and tcp_v6_rcv and should be\n *\taddress independent.\n */</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">tcp_rcv_state_process</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">sock</span> <span class=\"token operator\">*</span>sk<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">sk_buff</span> <span class=\"token operator\">*</span>skb<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">(</span>중략<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>sk<span class=\"token operator\">-></span>sk_state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">case</span> TCP_CLOSE<span class=\"token operator\">:</span>\n\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">(</span>중략<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\n\t<span class=\"token keyword\">case</span> TCP_LISTEN<span class=\"token operator\">:</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>th<span class=\"token operator\">-></span>ack<span class=\"token punctuation\">)</span>\n\t\t\t<span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>th<span class=\"token operator\">-></span>rst<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">(</span>중략<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>th<span class=\"token operator\">-></span>syn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">(</span>중략<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token function\">SKB_DR_SET</span><span class=\"token punctuation\">(</span>reason<span class=\"token punctuation\">,</span> TCP_FLAGS<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">goto</span> discard<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">case</span> TCP_SYN_SENT<span class=\"token operator\">:</span>\n\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">(</span>중략<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">(</span>중략<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>sk<span class=\"token operator\">-></span>sk_state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">case</span> TCP_SYN_RECV<span class=\"token operator\">:</span>\n\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">(</span>중략<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">case</span> TCP_FIN_WAIT1<span class=\"token operator\">:</span>\n\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">(</span>중략<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">case</span> TCP_CLOSING<span class=\"token operator\">:</span>\n\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">(</span>중략<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">case</span> TCP_LAST_ACK<span class=\"token operator\">:</span>\n\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">(</span>중략<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">(</span>중략<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>실제 코드는 주석에 달아둔 링크를 확인하면서 팔로우를 하면 될 것 같다.\n플로우만 이해하기 위해서 불필요한 코드는 전부 생략했다. 이 프로세스를 이해하고 싶으면 코드를 정독해보도록 하자.</p>\n<p>플로우는 아래와 같다.</p>\n<ol>\n<li>아이피 계층으로 프레임이 전달되면, <code class=\"language-text\">ip_rcv()</code> 함수가 호출</li>\n<li>내부적인 작업을 거친 후 <code class=\"language-text\">ip_local_deliver()</code> 함수를 통해 TCP 계층으로 전달</li>\n<li><code class=\"language-text\">tcp_v4_rcv()</code> 함수가 호출되며 내부적인 작업을 수행 후 <code class=\"language-text\">tcp_v4_do_rcv()</code> 함수를 호출</li>\n<li><code class=\"language-text\">tcp_v4_do_rcv()</code> 함수는 분기를 가진다.\n<ol>\n<li><code class=\"language-text\">TCP_ESTABLISHED</code> 상태 (이미 연결 수립된 상태)면 <code class=\"language-text\">tcp_rcv_established()</code> 함수 호출</li>\n<li>해당 상태가 아니면 연결 수립 과정을 위한 <code class=\"language-text\">tcp_rcv_state_process()</code> 호출</li>\n</ol>\n</li>\n<li><code class=\"language-text\">tcp_rcv_state_process()</code> 함수 내부 로직을 통한 실제 <strong>3-Way Handshake</strong> 수행</li>\n</ol>\n<h4 id=\"step-212-4-way-handshake\" style=\"position:relative;\"><a href=\"#step-212-4-way-handshake\" aria-label=\"step 212 4 way handshake permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.1.2 4-Way HandShake</h4>\n<p>위에서는 3-Way HandShake을 커널 레벨에서 살펴보았다.</p>\n<p>생각보다 복잡하다고 생각할 수 있겠지만, CS 공부를 어느정도 한 독자분들이라면 쉽게 이해했을 것이라 생각한다.</p>\n<p>3-Way에 비해 4-Way HandShake는 많이 간단하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">//https://github.com/torvalds/linux/blob/master/net/ipv4/tcp_input.c#L4374</span>\n<span class=\"token comment\">/*\n * \tProcess the FIN bit. This now behaves as it is supposed to work\n *\tand the FIN takes effect when it is validly part of sequence\n *\tspace. Not before when we get holes.\n *\n *\tIf we are ESTABLISHED, a received fin moves us to CLOSE-WAIT\n *\t(and thence onto LAST-ACK and finally, CLOSE, we never enter\n *\tTIME-WAIT)\n *\n *\tIf we are in FINWAIT-1, a received FIN indicates simultaneous\n *\tclose and we go into CLOSING (and later onto TIME-WAIT)\n *\n *\tIf we are in FINWAIT-2, a received FIN moves us to TIME-WAIT.\n */</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">tcp_fin</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">sock</span> <span class=\"token operator\">*</span>sk<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">(</span>중략<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>sk<span class=\"token operator\">-></span>sk_state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">case</span> TCP_SYN_RECV<span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">case</span> TCP_ESTABLISHED<span class=\"token operator\">:</span>\n\t\t<span class=\"token comment\">/* Move to CLOSE_WAIT */</span>\n\t\t<span class=\"token function\">tcp_set_state</span><span class=\"token punctuation\">(</span>sk<span class=\"token punctuation\">,</span> TCP_CLOSE_WAIT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token function\">inet_csk_enter_pingpong_mode</span><span class=\"token punctuation\">(</span>sk<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">case</span> TCP_CLOSE_WAIT<span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">case</span> TCP_CLOSING<span class=\"token operator\">:</span>\n\t\t<span class=\"token comment\">/* Received a retransmission of the FIN, do\n\t\t * nothing.\n\t\t */</span>\n\t\t<span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">case</span> TCP_LAST_ACK<span class=\"token operator\">:</span>\n\t\t<span class=\"token comment\">/* RFC793: Remain in the LAST-ACK state. */</span>\n\t\t<span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">case</span> TCP_FIN_WAIT1<span class=\"token operator\">:</span>\n\t\t<span class=\"token comment\">/* This case occurs when a simultaneous close\n\t\t * happens, we must ack the received FIN and\n\t\t * enter the CLOSING state.\n\t\t */</span>\n\t\t<span class=\"token function\">tcp_send_ack</span><span class=\"token punctuation\">(</span>sk<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token function\">tcp_set_state</span><span class=\"token punctuation\">(</span>sk<span class=\"token punctuation\">,</span> TCP_CLOSING<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">case</span> TCP_FIN_WAIT2<span class=\"token operator\">:</span>\n\t\t<span class=\"token comment\">/* Received a FIN -- send ACK and enter TIME_WAIT. */</span>\n\t\t<span class=\"token function\">tcp_send_ack</span><span class=\"token punctuation\">(</span>sk<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token function\">tcp_time_wait</span><span class=\"token punctuation\">(</span>sk<span class=\"token punctuation\">,</span> TCP_TIME_WAIT<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">default</span><span class=\"token operator\">:</span>\n\t\t<span class=\"token comment\">/* Only TCP_LISTEN and TCP_CLOSE are left, in these\n\t\t * cases we should never reach this piece of code.\n\t\t */</span>\n\t\t<span class=\"token function\">pr_err</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%s: Impossible, sk->sk_state=%d\\n\"</span><span class=\"token punctuation\">,</span>\n\t\t       <span class=\"token constant\">__func__</span><span class=\"token punctuation\">,</span> sk<span class=\"token operator\">-></span>sk_state<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">(</span>중략<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 함수가 우리가 알고 있는 연결 종료과정에서 발생하는 <strong>4-Way Handshake</strong> 로직에 해당하는 <code class=\"language-text\">tcp_fin()</code> 함수이다.</p>\n<p>해당 함수는 <code class=\"language-text\">FIN</code> 비트가 인입되면 호출되는 함수라고 보면된다.</p>\n<h3 id=\"step-22-커널-코드로-알아보는-tcp-메시지-송수신-과정\" style=\"position:relative;\"><a href=\"#step-22-%EC%BB%A4%EB%84%90-%EC%BD%94%EB%93%9C%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-tcp-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%86%A1%EC%88%98%EC%8B%A0-%EA%B3%BC%EC%A0%95\" aria-label=\"step 22 커널 코드로 알아보는 tcp 메시지 송수신 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.2 커널 코드로 알아보는 TCP 메시지 송/수신 과정</h3>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/SYUaRAp.png\">\n</p>\n<p align=\"center\">\n    <em>그림 5. 네트워크 계층으로 보는 요청/응답 과정</em>\n</p>\n<p>위에서 보았던 그림을 다시 가져왔다. 이를 가져온 이유는 TCP 송/수신과 연관이 있기 때문이다.</p>\n<p>우리가 어떠한 응용프로그램을 작성했고, 해당 어플리케이션은 HTTP 통신을 한다고 가정해보자.</p>\n<p>그렇다면, 메시지를 <strong>다른 곳에 보내기 위해서는 왼쪽부분과 같이 Application -> Network Interface 레이어를 거치는 작업을 통해서 메시지를 전달</strong>할 것이다.</p>\n<p>반대로 <strong>수신하는 입장에서는 응용프로그램까지 어떠한 정보가 도착하기 위해서는 Network Interface -> Application 레이어를 거치는 작업</strong>을 진행할 것이다.</p>\n<p>즉, 아래와 같이 정리할 수 있다.</p>\n<ol>\n<li><strong>메시지 송신 : Application Layer -> Network Interface Layer로 이뤄지는 프로세스</strong></li>\n<li><strong>메시지 수신 : Network Interface Layer -> Application Layer로 이뤄지는 프로세스</strong></li>\n</ol>\n<p>이러한 개념을 보고 아래의 과정을 보는게 좀 더 이해하는데 도움이 될 것이다.</p>\n<h4 id=\"step-221-tcp-송신-과정\" style=\"position:relative;\"><a href=\"#step-221-tcp-%EC%86%A1%EC%8B%A0-%EA%B3%BC%EC%A0%95\" aria-label=\"step 221 tcp 송신 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.2.1 TCP 송신 과정</h4>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/Ubiupzw.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html\">그림 6. Message Traffic Overview, New Hampshire Univ, 2000</a></em>\n</p>\n<p>위에서 설명한 바와 같이 <strong>Application Layer -> Network Interface(= Link) Layer</strong> 로 이뤄지는 작업들을 볼 수 있다.\n전반적인 플로우는 아래와 같다.</p>\n<ol>\n<li>소켓 쓰기 시스템콜 발생 (<code class=\"language-text\">__sys_sendto()</code><sup id=\"fnref-7\"><a href=\"#fn-7\" class=\"footnote-ref\">7</a></sup>)\n<ol>\n<li>소켓에서 메시지 전송 과정 수립 (<code class=\"language-text\">sock_sendmsg()</code><sup id=\"fnref-8\"><a href=\"#fn-8\" class=\"footnote-ref\">8</a></sup>)</li>\n<li>메시지 헤더를 적용 가능한 전송계층 프로토콜(TCP/UDP)로 전송(<code class=\"language-text\">inet_sendmeg()</code><sup id=\"fnref-9\"><a href=\"#fn-9\" class=\"footnote-ref\">9</a></sup>)</li>\n</ol>\n</li>\n<li>TCP 계층에서 전송 과정 진행\n<ol>\n<li>사용자 공간에서 페이로드를 커널 공간으로 복사한다. (<code class=\"language-text\">tcp_sendmsg()</code><sup id=\"fnref-10\"><a href=\"#fn-10\" class=\"footnote-ref\">10</a></sup>)</li>\n<li>혼잡제어 기능 수행을 위한 작업 수행 (<code class=\"language-text\">tcp_write_xmit()</code><sup id=\"fnref-11\"><a href=\"#fn-11\" class=\"footnote-ref\">11</a></sup>)</li>\n<li>TCP 헤더를 붙이고 전송 (<code class=\"language-text\">tcp_transmit_skb()</code><sup id=\"fnref-12\"><a href=\"#fn-12\" class=\"footnote-ref\">12</a></sup>)</li>\n</ol>\n</li>\n<li>하위 계층에서 전송을 위한 처리 진행</li>\n</ol>\n<p>여기서는 중요한 함수 1가지정도만 보고자한다.</p>\n<p>먼저, <code class=\"language-text\">tcp_sendmsg()</code><sup id=\"fnref-10\"><a href=\"#fn-10\" class=\"footnote-ref\">10</a></sup> 함수이다. 이 함수는 유저 공간에서 커널 공간으로 데이터를 버퍼로 복사해 <code class=\"language-text\">struct tcp_sock</code> 의 <code class=\"language-text\">write queue</code> 쪽에 데이터를 추가하는 작업을 진행한다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/b4O9xVe.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://os.korea.ac.kr/wp-content/uploads/2020/11/10_TCP-in-Linux.pdf\">그림 7. System Programming - TCP in Linux, Korea Univ, 2020, p.19</a></em>\n</p>\n<h4 id=\"step-222-tcp-수신-과정\" style=\"position:relative;\"><a href=\"#step-222-tcp-%EC%88%98%EC%8B%A0-%EA%B3%BC%EC%A0%95\" aria-label=\"step 222 tcp 수신 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.2.2 TCP 수신 과정</h4>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/NdGpFCI.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html\">그림 8. Message Traffic Overview, New Hampshire Univ, 2000</a></em>\n</p>\n<p>위에서 설명한 바와 같이 <strong>Network Interface(= Link) Layer -> Application Layer</strong> 로 이뤄지는 작업들을 볼 수 있다.</p>\n<p>사실, 메시지 수신 과정은 이미 3-Way Handshake를 진행하면서 다뤘다고 보면 된다. 전체 플로우는 위의 3-Way Handshake 내용을 참고하도록 하고, 여기서는 세부사항들에 대해서 짚고 넘어가야할 것들을 짚고 넘어가려고 한다.</p>\n<p>TCP 수신 부분에서는 크게 2가지의 대기열을 사용한다.</p>\n<ol>\n<li><strong>수신 대기열(Receive Queue) : 네트워크에서 수신했지만 어플리케이션에서 읽지 않은 데이터를 위한 대기열</strong>\n<ul>\n<li><code class=\"language-text\">recv()</code> 와 같은 시스템 콜을 통해서 해당 대기열에서 데이터를 검색하며, 이 대기열이 가득차면 전송 속도 조절하도록 발신자에게 호출.</li>\n</ul>\n</li>\n<li><strong>백로그 대기열(Backlog Queue / Accept Queue) :  서버에서 수신했지만 아직 어플리케이션에서 승인하지 않은 연결 요청 처리를 위한 대기열</strong>\n<ul>\n<li><code class=\"language-text\">accept()</code>과 같이 새 연결을 준비할 때, 커널은 이 대기열에서 가장 오래된 연결 요청을 검색 후 새 소켓을 생성.</li>\n</ul>\n</li>\n</ol>\n<p>이 전에는 사전 대기열(PreQueue / Pre-Demux Queue)라는 개념이 존재하였는데 4.14버전 이후 삭제되었다.</p>\n<ul>\n<li><a href=\"https://github.com/torvalds/linux/commit/e7942d0633c47c791ece6afa038be9cf977226de\">tcp: remove prequeue support : Github</a></li>\n</ul>\n<p>이 두가지 큐를 토대로 <code class=\"language-text\">tcp_v4_rcv()</code> 함수를 이해해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">tcp_v4_rcv</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">sk_buff</span> <span class=\"token operator\">*</span>skb<span class=\"token punctuation\">)</span> <span class=\"token comment\">// sk_buff는 소켓 버퍼를 뜻한다.</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">const</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">iphdr</span> <span class=\"token operator\">*</span>iph<span class=\"token punctuation\">;</span> <span class=\"token comment\">// IP 레이어 헤더 </span>\n\t<span class=\"token keyword\">const</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">tcphdr</span> <span class=\"token operator\">*</span>th<span class=\"token punctuation\">;</span> <span class=\"token comment\">// TCP 헤더 </span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\tth <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">tcphdr</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>skb<span class=\"token operator\">-></span>data<span class=\"token punctuation\">;</span> <span class=\"token comment\">// sk_buff에 담겨있는 페이로드를 통해 헤더의 시작위치를 참조</span>\n\tiph <span class=\"token operator\">=</span> <span class=\"token function\">ip_hdr</span><span class=\"token punctuation\">(</span>skb<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// sk_buff를 통해 IP 헤더를 식별한다. </span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\tprocess <span class=\"token operator\">:</span> <span class=\"token comment\">// TCP 처리를 담당하는 부분 </span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">sock_owned_by_user</span><span class=\"token punctuation\">(</span>sk<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 유저 공간에서 해당 소켓을 사용중이지 않으면 </span>\n\t\t\tret <span class=\"token operator\">=</span> <span class=\"token function\">tcp_v4_do_rcv</span><span class=\"token punctuation\">(</span>sk<span class=\"token punctuation\">,</span> skb<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 실제 연결 수립과정을 수행한다.</span>\n\t\t<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 유저 공간에서 해당 소켓을 사용중이면</span>\n\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">tcp_add_backlog</span><span class=\"token punctuation\">(</span>sk<span class=\"token punctuation\">,</span> skb<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>drop_reason<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 백로그 대기열에 넣는다 </span>\n\t\t\t\t<span class=\"token keyword\">goto</span> discard_and_relse<span class=\"token punctuation\">;</span> \n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>얼추 이해가 되었을 것이라 본다.</p>\n<p>백로그 대기열에 대한 이해는 되었다고 볼 수 있는데 그렇다면 수신 대기열은 언제 사용되는걸까?</p>\n<p>이를 알기 위해서는 <code class=\"language-text\">tcp_v4_do_rcv()</code> 함수를 먼저 알아보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">tcp_v4_do_rcv</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">sock</span> <span class=\"token operator\">*</span>sk<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">sk_buff</span> <span class=\"token operator\">*</span>skb<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sk<span class=\"token operator\">-></span>sk_state <span class=\"token operator\">==</span> TCP_ESTABLISHED<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">/* Fast path(이미 상태가 연결 수립된 케이스) */</span>\n\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> \n\t\t<span class=\"token function\">tcp_rcv_established</span><span class=\"token punctuation\">(</span>sk<span class=\"token punctuation\">,</span> skb<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\t\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token comment\">/* Slow path(연결 수립 상태가 아닐 경우) 아래의 작업들을 끝낸 후 핸드셰이킹 수행 */</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">tcp_checksum_complete</span><span class=\"token punctuation\">(</span>skb<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 체크섬 검사 수행 </span>\n\t\t<span class=\"token keyword\">goto</span> csum_err<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sk<span class=\"token operator\">-></span>sk_state <span class=\"token operator\">==</span> TCP_LISTEN<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">sock</span> <span class=\"token operator\">*</span>nsk <span class=\"token operator\">=</span> <span class=\"token function\">tcp_v4_cookie_check</span><span class=\"token punctuation\">(</span>sk<span class=\"token punctuation\">,</span> skb<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// SYN 쿠키 검사 수행 </span>\n\t\t\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>nsk<span class=\"token punctuation\">)</span> \n\t\t\t<span class=\"token keyword\">goto</span> discard<span class=\"token punctuation\">;</span> \n\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nsk <span class=\"token operator\">!=</span> sk<span class=\"token punctuation\">)</span> <span class=\"token comment\">// SYN 쿠키 검사 이후 소켓과 매개변수 소켓이 다르면 (SYN Flood 방어 매커니즘 ) </span>\n\t\t<span class=\"token punctuation\">{</span> \n\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">tcp_child_process</span><span class=\"token punctuation\">(</span>sk<span class=\"token punctuation\">,</span> nsk<span class=\"token punctuation\">,</span> skb<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 자식 소켓 처리</span>\n\t\t\t<span class=\"token punctuation\">{</span>\n\t\t\t\t rsk <span class=\"token operator\">=</span> nsk<span class=\"token punctuation\">;</span> <span class=\"token keyword\">goto</span> reset<span class=\"token punctuation\">;</span> \n\t\t\t<span class=\"token punctuation\">}</span> \n\t\t\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> \n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token comment\">// 위와 같은 예외처리 매커니즘 통과 후 실제 핸드셰이킹을 위한 작업 수행 </span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">tcp_rcv_state_process</span><span class=\"token punctuation\">(</span>sk<span class=\"token punctuation\">,</span> skb<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> \n\t<span class=\"token punctuation\">{</span> \n\t\trsk <span class=\"token operator\">=</span> sk<span class=\"token punctuation\">;</span> \n\t\t<span class=\"token keyword\">goto</span> reset<span class=\"token punctuation\">;</span> \n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>TCP에서 수신을 처리하기 위한 작업은 분기를 통해서 처리가 되는데</p>\n<ol>\n<li>기존 소켓이 <code class=\"language-text\">TCP_ESTABLISHED</code> 상태 : <strong>Fast Path로 처리가 될 확률이 높다.</strong></li>\n<li>기존 소켓이 <code class=\"language-text\">TCP_ESTABLISHED</code> 상태가 아닌 경우 : <strong>Slow Path로 처리가 될 확률이 높다.</strong></li>\n</ol>\n<p>당연히, <code class=\"language-text\">TCP_ESTABLISHED</code> 가 아니라면 핸드셰이크 작업이 이뤄질 것이다. 어쨋든 최종적으로 두 가지 모두 <code class=\"language-text\">tcp_rcv_established()</code> 라는 함수를 호출하는데 이때도 차이를 보인다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// https://github.com/torvalds/linux/blob/master/net/ipv4/tcp_input.c#L5868</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">tcp_rcv_established</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">sock</span> <span class=\"token operator\">*</span>sk<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">sk_buff</span> <span class=\"token operator\">*</span>skb<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tcp_header_len <span class=\"token operator\">==</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">tcphdr</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> TCPOLEN_TSTAMP_ALIGNED<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 밑에 케이스에 걸리는 경우에는 Slow Path이다.</span>\n\t\t<span class=\"token comment\">/* No? Slow path! */</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">tcp_parse_aligned_timestamp</span><span class=\"token punctuation\">(</span>tp<span class=\"token punctuation\">,</span> th<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\t\t\t<span class=\"token keyword\">goto</span> slow_path<span class=\"token punctuation\">;</span>\n\n\t\t<span class=\"token comment\">/* If PAWS failed, check it more carefully in slow path */</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>s32<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>tp<span class=\"token operator\">-></span>rx_opt<span class=\"token punctuation\">.</span>rcv_tsval <span class=\"token operator\">-</span> tp<span class=\"token operator\">-></span>rx_opt<span class=\"token punctuation\">.</span>ts_recent<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\t\t\t<span class=\"token keyword\">goto</span> slow_path<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>skb<span class=\"token operator\">-></span>truesize <span class=\"token operator\">></span> sk<span class=\"token operator\">-></span>sk_forward_alloc<span class=\"token punctuation\">)</span>\n\t\t\t<span class=\"token keyword\">goto</span> step5<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 이 또한 Slow Path로 처리하는 작업이다.</span>\n\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t\n\t\teaten <span class=\"token operator\">=</span> <span class=\"token function\">tcp_queue_rcv</span><span class=\"token punctuation\">(</span>sk<span class=\"token punctuation\">,</span> skb<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>fragstolen<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 실제 수신 큐에 데이터를 넣는다. (Fast Path)</span>\n\t\t\t\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">TCP_SKB_CB</span><span class=\"token punctuation\">(</span>skb<span class=\"token punctuation\">)</span><span class=\"token operator\">-></span>ack_seq <span class=\"token operator\">!=</span> tp<span class=\"token operator\">-></span>snd_una<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">inet_csk_ack_scheduled</span><span class=\"token punctuation\">(</span>sk<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\t\t\t\t<span class=\"token keyword\">goto</span> no_ack<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token function\">tcp_update_wl</span><span class=\"token punctuation\">(</span>tp<span class=\"token punctuation\">,</span> <span class=\"token function\">TCP_SKB_CB</span><span class=\"token punctuation\">(</span>skb<span class=\"token punctuation\">)</span><span class=\"token operator\">-></span>seq<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\nno_ack<span class=\"token operator\">:</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>eaten<span class=\"token punctuation\">)</span>\n\t\t\t\t<span class=\"token function\">kfree_skb_partial</span><span class=\"token punctuation\">(</span>skb<span class=\"token punctuation\">,</span> fragstolen<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token function\">tcp_data_ready</span><span class=\"token punctuation\">(</span>sk<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 데이터가 수신 큐에 추가되었음을 알림</span>\n\t\t\t<span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\nslow_path<span class=\"token operator\">:</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\nstep5<span class=\"token operator\">:</span>\n\treason <span class=\"token operator\">=</span> <span class=\"token function\">tcp_ack</span><span class=\"token punctuation\">(</span>sk<span class=\"token punctuation\">,</span> skb<span class=\"token punctuation\">,</span> FLAG_SLOWPATH <span class=\"token operator\">|</span> FLAG_UPDATE_TS_RECENT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token comment\">/* step 7: process the segment text */</span>\n\t<span class=\"token function\">tcp_data_queue</span><span class=\"token punctuation\">(</span>sk<span class=\"token punctuation\">,</span> skb<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// TCP 세그먼트 옵션 및 플래그 처리, 순서대로 도착하지 않은 경우 올바른 위치에 삽입 등의 작업을 수행 </span>\n\n\t<span class=\"token function\">tcp_data_snd_check</span><span class=\"token punctuation\">(</span>sk<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">tcp_ack_snd_check</span><span class=\"token punctuation\">(</span>sk<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 내용을 이해하기 위해서는 <strong>Fast Path 와 Slow Path</strong> 에 대해서 알 필요가 있다.</p>\n<ol>\n<li><strong>Fast Path : 가장 일반적이고, 예상되는 작업을 처리하는 최적화된 매커니즘이며 가장 일반적인 작업만 처리하기 때문에 Slow Path보다 복잡성이 덜하다.</strong>\n<ul>\n<li>예시 : 패킷이 순차적으로 도착하고 모든 것이 예상대로일 경우</li>\n</ul>\n</li>\n<li><strong>Slow Path : 패킷 검사, 흐름 제어등 다양한 작업을 수행하다보니 Fast Path보다 느리며, 처리 과정이 상대적으로 복잡하다.</strong>\n<ul>\n<li>예시 : 순서가 뒤바뀐 패킷이 도착하거나 추가 처리를 위한 특정 플래그가 설정된 경우</li>\n</ul>\n</li>\n</ol>\n<p>위와 같이 최종적으로 데이터는 수신 큐에 적재가 되며, 실제 유저 공간에서 <code class=\"language-text\">recv()</code> 와 같은 시스템 콜이 호출될 때 <code class=\"language-text\">tpc_recvmsg()</code><sup id=\"fnref-13\"><a href=\"#fn-13\" class=\"footnote-ref\">13</a></sup> 와 같은 함수에서 수신 큐에 데이터를 가져와서 데이터를 처리한다.\n즉, 위에 부분은 연결 수립까지의 과정이고 데이터가 수신 큐에 적재되어 있으면,  시스템 콜에 의해서 수신 큐에 있는 데이터들을 가져가서 수신 처리를 하는 것이다.</p>\n<p>그림으로 정리하면 아래의 플로우라고 볼 수 있다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/kqwfDdp.png\">\n</p>\n<p align=\"center\">\n    <em>그림 9. Fast Path / Slow Path에 따른 TCP 메시지 수신 과정</em>\n</p>\n<h2 id=\"step-3-tcp-사용-시-서비스에서-겪을-수-있는-문제들\" style=\"position:relative;\"><a href=\"#step-3-tcp-%EC%82%AC%EC%9A%A9-%EC%8B%9C-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%97%90%EC%84%9C-%EA%B2%AA%EC%9D%84-%EC%88%98-%EC%9E%88%EB%8A%94-%EB%AC%B8%EC%A0%9C%EB%93%A4\" aria-label=\"step 3 tcp 사용 시 서비스에서 겪을 수 있는 문제들 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3. TCP 사용 시 서비스에서 겪을 수 있는 문제들</h2>\n<p>자 이제 어려운 이야기들은 모두 끝냈다. 이제는 아주 편하게 볼 수 있는 내용들이고, 아마도 알고 있는 이야기들도 많을 것이다.</p>\n<p>중점으로 둘 내용은 <code class=\"language-text\">TIME_WAIT</code> , <code class=\"language-text\">CLOSE_WAIT</code> 소켓과 HTTP 지속 커넥션과 TCP Keep-alive 그리고, Timout에 대한 내용을 다뤄보고자 한다.</p>\n<h3 id=\"step-31-time_wait-소켓\" style=\"position:relative;\"><a href=\"#step-31-time_wait-%EC%86%8C%EC%BC%93\" aria-label=\"step 31 time_wait 소켓 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.1 TIME_WAIT 소켓</h3>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/gfqildB.png\">\n</p>\n<p align=\"center\">\n    <em>그림 10. Fast Path / Slow Path에 따른 TCP 메시지 수신 과정</em>\n</p>\n<p>먼저, <code class=\"language-text\">TIME_WAIT</code> 를 알아보기 앞 서 이와 연관이 있는 4-Way Handshake 그림을 봐보자.</p>\n<p>여기서는 서버-클라이언트라는 명칭 대신에 Active Closer와 Passive Closer라는 명칭을 사용했다. 이 뜻은 아래와 같다.</p>\n<ul>\n<li><strong>Active Closer : 먼저 연결을 끊는 쪽</strong></li>\n<li><strong>Passive Closer : 그 반대 쪽</strong></li>\n</ul>\n<p>잘 보면 Active Closer 쪽에 <code class=\"language-text\">TIME_WAIT</code> 소켓이 생성되는 것을 볼 수 있다. 즉, 클라이언트에서도 <code class=\"language-text\">TIME_WAIT</code>가 생길 수 있으며, 서버쪽에서도 <code class=\"language-text\">TIME_WAIT</code>가 생길 수 있다고 보면된다.</p>\n<p><code class=\"language-text\">TIME_WAIT</code> 를 이해하기 앞서 우리가 봤던 핸드셰이크 과정이 제대로 이뤄지는지 확인해보자. 필자는 가상머신에 Nginx를 설치 한 후에 tcpdump를 통해서 와이어 샤크로 분석을 수행해보았다.</p>\n<p><img src=\"https://i.imgur.com/G1jWW7G.png\" alt=\"\"></p>\n<ol>\n<li>클라이언트(192.168.106.1)가 서버(192.168.106.3) 포트 80에 <code class=\"language-text\">SYN</code> 패킷을 보낸다.</li>\n<li>서버는 클라이언트에게 <code class=\"language-text\">SYN+ACK</code> 패킷을 보낸다.</li>\n<li>다시 클라이언트는 서버에 <code class=\"language-text\">ACK</code> 패킷을 보낸다.</li>\n</ol>\n<p>여기까지가 <strong>3-way Handshake 과정</strong>이다.</p>\n<hr>\n<ol start=\"4\">\n<li>3-way Handshake가 끝난 후 클라이언트는 GET 요청을 보낸다.</li>\n<li>서버(Active Closer)는 연결을 끊기 위해 클라이언트(Passive Closer)에게 <code class=\"language-text\">FIN</code> 패킷을 보낸다.</li>\n<li>클라이언트는 이에 대한 응답으로 <code class=\"language-text\">ACK</code> 패킷을 보낸다</li>\n<li>클라이언트는 소켓 정리 후에 서버에게 연결 종료를 위한 <code class=\"language-text\">FIN</code> 패킷을 보낸다.</li>\n<li>서버는 클라이언트에게 <code class=\"language-text\">ACK</code> 패킷을 보낸 후 연결 종료를 한다.</li>\n</ol>\n<p>여기까지가 <strong>4-way Handshake 과정</strong>이다.</p>\n<p>우리가 위에서 보았던 Handshake 과정을 수행하는 것을 실제로 확인하였다. 그렇다면, <code class=\"language-text\">TIME_WAIT</code> 상태가 서비스에 어떤 영향을 끼칠 수 있을까?</p>\n<p>우선, <strong>소켓 포트 고갈 문제가 발생</strong>할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">sysctl net.ipv4.ip_local_port_range\n# net.ipv4.ip_local_port_range = 32768\t60999 # MIN MAX</code></pre></div>\n<p>해당 커널 파라미터는 소켓의 포트의 개수를 조절하는 파라미터이다.</p>\n<p>현재 필자의 가상머신에서는 32768 ~ 60999까지가 해당 포트를 사용하고 있음을 확인할 수 있다.</p>\n<p>만약, 모든 로컬 포트가 <code class=\"language-text\">TIME_WAIT</code> 상태라면, 할당할 수 있는 포트가 없기 때문에 외부와 통신을 못하게 되고 <strong>어플리케이션에서는 타임아웃 문제가 발생</strong>할 수 있다.</p>\n<p>그리고 <code class=\"language-text\">TIME_WAIT</code> 가 많이 발생한다면 <strong>TCP 자체가 잦은 연결 수립/끊음이 발생</strong>한다고도 추정할 수 있다.</p>\n<p>즉, Handshake가 많이 발생하면서 <strong>전체적인 서비스의 응답 속도 저하를 야기</strong>할 수 있다.\n이러한 현상을 막기 위해서 현대의 어플리케이션에서는 커넥션 풀을 사용하여 한번 맺어 놓은 TCP를 재사용하도록 구현하고 있다.</p>\n<h4 id=\"step-311-클라이언트-측면\" style=\"position:relative;\"><a href=\"#step-311-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%B8%A1%EB%A9%B4\" aria-label=\"step 311 클라이언트 측면 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.1.1 클라이언트 측면</h4>\n<p>위에서 간략하게 <code class=\"language-text\">TIME_WAIT</code> 가 많이 발생할 시 문제점들을 간략히 설명했다. 서버/클라이언트 측면에서 보고자 한다.\n헷갈리면 안되는 것이 <code class=\"language-text\">TIME_WAIT</code> 는 Active Closer 쪽에서 발생하는 것이기 때문에 서버와 클라이언트 모두 발생할 수 있다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/q2rPjqj.png\">\n</p>\n<p align=\"center\">\n    <em>그림 11. 간단한 2tier 시스템</em>\n</p>\n<p>위 그림을 보면 사용자(User)가 POST 메서드를 웹서버에 발행하는 구간은 클라이언트가 사용자고, 서버가 웹 서버일 것이다.</p>\n<p>그러나, DB서버와 통신하는 구간은 웹서버가 클라이언트고, DB 서버가 서버의 역할을 하게된다.</p>\n<p>DB서버와 통신하는 구간에서 웹서버가 연결을 먼저 끊게 되면, 웹서버가 Active Closer가 될 것이고, <code class=\"language-text\">TIME_WAIT</code> 소켓이 발생할 수 있을 것이다.</p>\n<p>소켓은 필수적인 4개의 값이 존재하는데 이를 알아보기 위해 잠깐 <code class=\"language-text\">struct sock_common</code> 구조체를 코드를 가져와보겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">//https://github.com/torvalds/linux/blob/master/include/net/sock.h#L163</span>\n<span class=\"token comment\">/**\n* @skc_addrpair: 8-byte-aligned __u64 union of @skc_daddr &amp; @skc_rcv_saddr\n* @skc_hash: hash value used with various protocol lookup tables\n* @skc_portpair: __u32 union of @skc_dport &amp; @skc_num\n**/</span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">sock_common</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">union</span> <span class=\"token punctuation\">{</span>\n\t\t__addrpair\tskc_addrpair<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n\t\t\t__be32\tskc_daddr<span class=\"token punctuation\">;</span>\n\t\t\t__be32\tskc_rcv_saddr<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">union</span>  <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span>\tskc_hash<span class=\"token punctuation\">;</span>\n\t\t__u16\t\tskc_u16hashes<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">/* skc_dport &amp;&amp; skc_num must be grouped as well */</span>\n\t<span class=\"token keyword\">union</span> <span class=\"token punctuation\">{</span>\n\t\t__portpair\tskc_portpair<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n\t\t\t__be16\tskc_dport<span class=\"token punctuation\">;</span>\n\t\t\t__u16\tskc_num<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">sck_addrpair</code> 는 출발지와 목적지의 IPv4 주소를 담고 있다.</li>\n<li><code class=\"language-text\">sck_portpair</code> 는 포트 번호들을 담고 있다.</li>\n<li><code class=\"language-text\">skc_hash</code> 는 소켓을 빠르기 찾기 위한 해시 값이고, 패킷이 도착했을 때 어떤 소켓에 해당하는지 알아내는데 도움을 준다.</li>\n</ul>\n<p>즉,<code class=\"language-text\">sck_addrpair</code>, <code class=\"language-text\">sck_portpair</code> 의 묶음이 해시로 생성되고 이 소켓은 <strong>커널 내부에 유일하게 존재</strong>하게 되고, 서두에서 본 내용처럼 FD(File Descriptor)를 전달해주는 것이다.</p>\n<p>이러한 소켓을 active close하게 되면, <code class=\"language-text\">TIME_WAIT</code> 상태로 남게 된다. <strong>따라서, 해당 소켓의 <code class=\"language-text\">TIME_WAIT</code> 상태가 풀리기 전까지 해당 소켓은 다시 사용할 수 없다.</strong></p>\n<p>이런식으로 계속 <code class=\"language-text\">TIME_WAIT</code> 소켓이 쌓이면서 로컬 포트가 전부 고갈되어 <code class=\"language-text\">net.ipv4.ip_local_port_range</code> 값을 다 쓰게되면 통신을 할 수 없게 된다.</p>\n<p>이를 테스트 해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">curl https://www.google.co.kr &gt; /dev/null 2&gt;&amp;1 \nnetstat -napo | grep TIME_WAIT \ntcp        0      0 192.168.106.3:51292     142.250.207.99:443      TIME_WAIT   -                    timewait (8.68/0/0)</code></pre></div>\n<p>위의 명령은 <code class=\"language-text\">curl</code> 을 통해서 <code class=\"language-text\">www.google.co.kr</code> 에 요청을 수행한 후에 <code class=\"language-text\">TIME_WAIT</code> 가 발생하는데 이는 <code class=\"language-text\">curl</code> 자체가 요청 후에 응답을 받으면 연결을 끊는 매커니즘이 있기 때문이다.\n자세한 코드는 <a href=\"https://github.com/curl/curl/blob/master/lib/url.c#L3895\">여기</a>를 확인하자.</p>\n<p>어쨋든 간단하게 <code class=\"language-text\">TIME_WAIT</code> 를 만들 수 있게 되었고, 우리의 가설은 <strong>동일한 소켓은 사용이 안된다는 것이었으므로 한번 이 가설을 검증</strong>해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">sysctl net.ipv4.ip_local_port_range\n# net.ipv4.ip_local_port_range = 32768\t60999\n\nsudo sysctl -w &quot;net.ipv4.ip_local_port_range=32768 32768&quot; # 인터넷 소켓의 포트 범위를 32768 한개로 줄임\n# net.ipv4.ip_local_port_range = 32768 32768\n\ncurl https://www.google.co.kr &gt; /dev/null 2&gt;&amp;1\nnetstat -napo | grep TIME_WAIT\n# (Not all processes could be identified, non-owned process info\n# will not be shown, you would have to be root to see it all.)\n# tcp        0      0 192.168.106.3:32768     142.250.207.99:443      TIME_WAIT   -                    timewait (51.57/0/0)\n\ncurl https://www.google.co.kr &gt; /dev/null\n#  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n#                                 Dload  Upload   Total   Spent    Left  Speed\n#  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0 curl: (7) Couldn&#39;t connect to server</code></pre></div>\n<ul>\n<li><code class=\"language-text\">sudo sysctl -w \"net.ipv4.ip_local_port_range=32768 32768\"</code> 로 포트 범위를 제한한다.</li>\n<li>똑같은 요청 시에 <code class=\"language-text\">curl: (7) Couldn't connect to server</code> 에러가 발생하는 것을 볼 수 있다.</li>\n</ul>\n<p>이렇게, 우리의 가설을 검증할 수 있는 것을 확인할 수 있다.</p>\n<p>그렇다면 이러한 포트 고갈에 어떻게 대응할 수 있는 방법이 뭐가 있을까? 바로, <code class=\"language-text\">net.ipv4.tcp_tw_reuse</code> 파라미터를 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">sysctl net.ipv4.tcp_tw_reuse\n# net.ipv4.tcp_tw_reuse = 0\n\nsudo sysctl -w &quot;net.ipv4.tcp_tw_reuse=1&quot;\n# net.ipv4.tcp_tw_reuse = 1\n\ncurl https://www.google.co.kr &gt; /dev/null\n#  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n#                                 Dload  Upload   Total   Spent    Left  Speed\n#100 18649    0 18649    0     0  59007      0 --:--:-- --:--:-- --:--:-- 59203\ncurl https://www.google.co.kr &gt; /dev/null\n#  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n#                                 Dload  Upload   Total   Spent    Left  Speed\n#100 18624    0 18624    0     0  56613      0 --:--:-- --:--:-- --:--:-- 56607\ncurl https://www.google.co.kr &gt; /dev/null\n#  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n#                                 Dload  Upload   Total   Spent    Left  Speed\n# 100 18594    0 18594    0     0  58303      0 --:--:-- --:--:-- --:--:-- 58288</code></pre></div>\n<p>해당 <code class=\"language-text\">net.ipv4.tcp_tw_reuse</code> 를 enable 할 경우에 계속적으로 요청을 할 수 있다. 아래는 해당 파라미터의 동작 원리이다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/90rafkG.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.yes24.com/Product/Goods/44376723\">그림 12. net.ipv4.tcp_tw_reuse 파라미터 동작 원리, DevOps와 SE를 위한 리눅스 커널 이야기(강진우 저), 2017</a></em>\n</p>\n<p>하지만, 위 방식은 궁여지책일 뿐 근본적인 해결책은 아니라고 볼 수 있다. 그렇다면, 어떻게 이 문제를 해결할 수 있을까? 바로 <strong>Connection Pool</strong> 을 사용하는 것이다.</p>\n<blockquote>\n<p>❗❗ 중요\n궁여지책이라해서 상기 파라미터(<code class=\"language-text\">net.ipv4.tcp_tw_reuse</code>)를 꺼도 무방하다라는 뜻은 아니다.\n실제로 필자가 포스팅을 위해 세팅한 가상환경은 ubuntu 22.04 버전으로, 커널은 5.15.0-84 버전을 사용중이다.\n이 커널 버전에서는 해당 <strong>파라미터가 default로 활성화</strong>되어있다.</p>\n<p>따라서, 궁여지책이라는 말의 뜻은 <code class=\"language-text\">TIME_WAIT</code> 소켓이 다수 발생 시 소켓 재사용만으로는 한계가 존재하며, <strong>클라이언트 어플리케이션이 Connection Pool을 사용하는지 확인한 후 사용하지 않는 상황이라면 해당 방법을 적용하라는 뜻</strong>이다.</p>\n</blockquote>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/NaZDtxa.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.yes24.com/Product/Goods/44376723\">그림 13. Connection Less와 Connection Pool, DevOps와 SE를 위한 리눅스 커널 이야기(강진우 저), 2017</a></em>\n</p>\n<p>Connection Less 방식은 우리가 위에서 살펴봤던 방식이고, Connection Pool은 소켓을 미리 열어둬서 불필요한 TCP 연결 수립/종료 과정이 없어서 응답속도를 높힐 수 있다.</p>\n<p>실제로, Connection Pool 사용 시 <code class=\"language-text\">TIME_WAIT</code> 가 줄어드는 지 궁금하지 않는가? 이에 대한 또 가설 검증을 진행해보자. 필자는 가상머신에 Docker를 설치하여 Redis를 구동시킨 후 <code class=\"language-text\">setex</code> 라는 커맨드를 요청하는 식의 스크립트를 작성하였다.</p>\n<ul>\n<li>Connection Less 방식</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">#!/usr/bin/python\nimport redis\nimport time\n\ncount = 0\nwhile True:\n    if count &gt; 10000:\n        break;\n    r = redis.Redis(host=&#39;localhost&#39;, port=6379, db=0)\n    print(&quot;SET&quot;)\n    r.setex(count, 10, count)</code></pre></div>\n<ul>\n<li>Connection Pool 방식</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">#!/usr/bin/python\nimport redis\nimport time\n\ncount = 0\npool = redis.ConnectionPool(host=&#39;localhost&#39;, port=6379, db=0) # Redis Client를 이용하여 Connection Pool을 생성한다.\nwhile True:\n    if count &gt; 10000:\n        break;\n    r = redis.Redis(connection_pool=pool) # 실제 연결 시 Connection Pool을 이용한다.\n    print(&quot;SET&quot;)\n    r.setex(count,10,count)</code></pre></div>\n<ul>\n<li>결과</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\"># Connection Less 방식 사용 시 \nnetstat -napo | grep -i 6379\n(Not all processes could be identified, non-owned process info\n will not be shown, you would have to be root to see it all.)\ntcp        0      0 0.0.0.0:6379            0.0.0.0:*               LISTEN      -                    off (0.00/0/0)\ntcp        0      0 127.0.0.1:51674         127.0.0.1:6379          TIME_WAIT   -                    timewait (54.92/0/0)\ntcp        0      0 172.17.0.1:52260        172.17.0.2:6379         TIME_WAIT   -                    timewait (54.63/0/0)\ntcp        0      0 172.17.0.1:53776        172.17.0.2:6379         TIME_WAIT   -                    timewait (46.52/0/0)\ntcp        0      0 127.0.0.1:55084         127.0.0.1:6379          TIME_WAIT   -                    timewait (51.01/0/0)\ntcp        0      0 127.0.0.1:40166         127.0.0.1:6379          TIME_WAIT   -                    timewait (48.72/0/0)\ntcp        0      0 172.17.0.1:56876        172.17.0.2:6379         TIME_WAIT   -                    timewait (55.27/0/0)\ntcp        0      0 172.17.0.1:47876        172.17.0.2:6379         TIME_WAIT   -                    timewait (58.18/0/0)\ntcp        0      0 127.0.0.1:55660         127.0.0.1:6379          TIME_WAIT   -                    timewait (59.46/0/0)\ntcp        0      0 172.17.0.1:52602        172.17.0.2:6379         TIME_WAIT   -                    timewait (54.67/0/0)\ntcp        0      0 127.0.0.1:55284         127.0.0.1:6379          TIME_WAIT   -                    timewait (51.03/0/0)\ntcp        0      0 172.17.0.1:51382        172.17.0.2:6379         TIME_WAIT   -                    timewait (54.50/0/0)\ntcp        0      0 172.17.0.1:38266        172.17.0.2:6379         TIME_WAIT   -                    timewait (58.60/0/0)\ntcp        0      0 172.17.0.1:43192        172.17.0.2:6379         TIME_WAIT   -                    timewait (59.50/0/0)\ntcp        0      0 127.0.0.1:36864         127.0.0.1:6379          TIME_WAIT   -                    timewait (52.60/0/0)\ntcp        0      0 172.17.0.1:37414        172.17.0.2:6379         TIME_WAIT   -                    timewait (52.27/0/0)\ntcp        0      0 172.17.0.1:33792        172.17.0.2:6379         TIME_WAIT   -                    timewait (51.68/0/0)\ntcp        0      0 127.0.0.1:59636         127.0.0.1:6379          TIME_WAIT   -                    timewait (51.70/0/0)\ntcp        0      0 127.0.0.1:33870         127.0.0.1:6379          TIME_WAIT   -                    timewait (52.10/0/0)\ntcp        0      0 172.17.0.1:51496        172.17.0.2:6379         TIME_WAIT   -                    timewait (50.07/0/0)\n...\n\n# Connection Pool 방식 사용 시\nnetstat -napo | grep -i 6379\n(Not all processes could be identified, non-owned process info\n will not be shown, you would have to be root to see it all.)\ntcp        0      0 0.0.0.0:6379            0.0.0.0:*               LISTEN      -                    off (0.00/0/0)\ntcp        5      0 172.17.0.1:45724        172.17.0.2:6379         ESTABLISHED -                    keepalive (5.72/0/0)\ntcp        0      0 127.0.0.1:6379          127.0.0.1:43862         ESTABLISHED -                    keepalive (5.71/0/0)\ntcp        5      0 127.0.0.1:43862         127.0.0.1:6379          ESTABLISHED 3525/python3         off (0.00/0/0)\ntcp6       0      0 :::6379                 :::*                    LISTEN      -                    off (0.00/0/0)</code></pre></div>\n<p>위와 같이 많은 차이를 가짐을 확인할 수 있다.  하지만, Connection Pool 방식에도 단점이 존재하는데 이는 TCP Keep-alive와 관련있으므로 후에 살펴보도록 한다.</p>\n<h4 id=\"step-312-서버-측면\" style=\"position:relative;\"><a href=\"#step-312-%EC%84%9C%EB%B2%84-%EC%B8%A1%EB%A9%B4\" aria-label=\"step 312 서버 측면 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.1.2 서버 측면</h4>\n<p>이제는 Active Closer가 서버인 상황에 대해서 알아보자. 클라이언트와 다르게, 서버는 소켓을 열어두고 요청을 받는 입장이라 로컬 포트 고갈의 문제는 없다.\n하지만, <code class=\"language-text\">TIME_WAIT</code> 소켓이 자주 발생하면 클라이언트에서 발생하는 문제처럼 불필요한 Handshake가 잦아질 수 있다.</p>\n<p>그렇다면, 서버에서는 어떤 경우에 <code class=\"language-text\">TIME_WAIT</code>가 발생할 수 있을까? 위에서 필자는 Nginx를 설치해두었는데 여기서 <code class=\"language-text\">keepalive_timeout</code> 값을 0으로 둬보겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\">server <span class=\"token punctuation\">{</span>\n        keepalive_timeout <span class=\"token number\">0</span>; <span class=\"token comment\">// 추가</span>\n        listen <span class=\"token number\">80</span> default_server;\n        listen <span class=\"token punctuation\">[</span><span class=\"token operator\">:</span><span class=\"token operator\">:</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span><span class=\"token number\">80</span> default_server;\n        ...\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이후, 클라이언트에서 해당 Nginx로 요청을 보내보겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">curl -s http://192.168.106.3 &gt; /dev/null # 여러번 돌린다. (클라이언트 터미널이여야 함)\n\n\nnetstat -napo | grep -i :80 # 서버 터미널에서 TIME_WAIT를 아래와 같이 확인할 수 있다.\n(Not all processes could be identified, non-owned process info\n will not be shown, you would have to be root to see it all.)\ntcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      -                    off (0.00/0/0)\ntcp        0      0 192.168.106.3:80        192.168.106.1:50610     TIME_WAIT   -                    timewait (9.64/0/0)\ntcp        0      0 192.168.106.3:80        192.168.106.1:50607     TIME_WAIT   -                    timewait (8.27/0/0)\ntcp        0      0 192.168.106.3:80        192.168.106.1:50608     TIME_WAIT   -                    timewait (8.70/0/0)\ntcp        0      0 192.168.106.3:80        192.168.106.1:50605     TIME_WAIT   -                    timewait (7.75/0/0)\ntcp        0      0 192.168.106.3:80        192.168.106.1:50609     TIME_WAIT   -                    timewait (9.16/0/0)\ntcp        0      0 192.168.106.3:80        192.168.106.1:50632     TIME_WAIT   -                    timewait (42.12/0/0)\ntcp        0      0 192.168.106.3:80        192.168.106.1:50611     TIME_WAIT   -                    timewait (10.08/0/0)\ntcp6       0      0 :::80                   :::*                    LISTEN      -                    off (0.00/0/0)</code></pre></div>\n<p>보면, 호스트 컴퓨터(클라이언트, <code class=\"language-text\">192.168.106.1</code>) 에서 가상 머신(서버, <code class=\"language-text\">192.168.106.3</code>)으로 요청이 보내진 뒤에 keep-alive 옵션이 꺼져있으므로 응답을 내려준 후에 연결을 해제하므로 해당 소켓들이 <code class=\"language-text\">TIME_WAIT</code> 상태임을 확인할 수 있다.</p>\n<blockquote>\n<p>💡 참고\n책에서는 이를 해결하는 방법 중에 하나로 <code class=\"language-text\">net.ipv4.tcp_tw_recycle</code> 커널 파라미터를 활성화하는 것에 대해서 나오지만, <strong>4.12 이후 커널</strong>부터는 제거가 되었다.\n제거된 이유에 대해서는 밑에서 설명하겠지만, 해당 커밋 내용에 대해서 궁금하면 <a href=\"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=4396e46187ca5070219b81773c4e65088dac50cc\">여기</a> 를 참고해보기 바란다.</p>\n</blockquote>\n<p>이전에는 <code class=\"language-text\">net.ipv4.tcp_tw_recycle</code> 파라미터를 활성화하여 해결할 수 있었지만 이는 치명적인 단점이 존재한다.</p>\n<p><code class=\"language-text\">net.ipv4.tcp_tw_recycle</code> 파라미터는 서버 입장에서 소켓을 빠르게 회수하고 재활용할 수 있는 기능이다.</p>\n<p>해당 커널 파라미터가 활성화되면 동작 방식은 아래와 같다.</p>\n<ol>\n<li>가장 마지막에 해당 소켓으로부터 들어온 Timestamp 저장</li>\n<li><code class=\"language-text\">TIME_WAIT</code> 소켓의 타이머를 RTO(Retransmission Timeout)<sup id=\"fnref-14\"><a href=\"#fn-14\" class=\"footnote-ref\">14</a></sup> 기반의 값으로 변경</li>\n</ol>\n<p>RTO 는 대부분 ms 단위기에 <code class=\"language-text\">TIME_WAIT</code> 가 줄어들지만, 1번의 동작 방식때문에 아래의 문제가 발생할 수 있다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/IbwwDRm.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.yes24.com/Product/Goods/44376723\">그림 14. tcp_tw_recycle 파라미터 활성화 시 발생하는 문제, DevOps와 SE를 위한 리눅스 커널 이야기(강진우 저), 2017</a></em>\n</p>\n<p>같은 NAT 상에 존재하는 클라이언트 C1, C2가 존재한다고 가정해보자. 그렇다면, 서버인 S 입장에서는 같은 클라이언트로 보게 된다.</p>\n<ol>\n<li>S가 C1의 요청을 종료하기 위해 4-way Handshake 수행</li>\n<li><code class=\"language-text\">TIME_WAIT</code> 소켓 발생 시 RTO 값으로 세팅하여 금방 정리한 후 C1이 보낸 FIN 패킷의 Timestamp 저장</li>\n<li><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><msub><mn>2</mn><mrow><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>m</mi><mi>p</mi></mrow></msub><mo>&#x3C;</mo><mi>C</mi><msub><mn>1</mn><mrow><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>m</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">C2_{timestamp} &#x3C; C1_{timestamp}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">im</span><span class=\"mord mathnormal mtight\">es</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">am</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&#x3C;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">im</span><span class=\"mord mathnormal mtight\">es</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">am</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> 인 경우, <strong>동일한 클라이언트에서 Timestamp가 더 작은 요청이 발생했으므로 패킷을 처리하지않고 버림.</strong></li>\n<li>C2는 S로부터 <code class=\"language-text\">ACK</code> 을 받지 못하므로 계속 재전송한다.</li>\n</ol>\n<p>즉, NAT 환경에서의 다양한 클라이언트가 있을 때 <strong>항상 Timestamp가 단조증가한다는 보장이 없으므로 이는 치명적인 문제를 야기</strong>한다. <strong>(이것이 4.12버전에서 해당 파라미터가 제거된 원인이다.)</strong></p>\n<p>이를 해결해서 사용하는 것이 바로 <strong>keep-alive</strong> 옵션이다.</p>\n<p>서버에서 발생하는 <code class=\"language-text\">TIME_WAIT</code> 에 대한 검증을 위해 필자는 Nginx에 <code class=\"language-text\">keepalive_timeout 0;</code> 와 같이 처리하였는데 이 값을 30초로 바꾸고 동작시켜보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">sudo systemctl reload nginx\nnetstat -napo | grep -i :80\n#(Not all processes could be identified, non-owned process info\n# will not be shown, you would have to be root to see it all.)\n#tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      -                    off (0.00/0/0)\n#tcp6       0      0 :::80                   :::*                    LISTEN      -                    off (0.00/0/0)</code></pre></div>\n<p><code class=\"language-text\">TIME_WAIT</code> 소켓이 깔끔하게 제거된 것을 볼 수 있다. keep-alive는 요청을 끝마쳐도 해당 타임아웃 내까지는 연결이 끊어지지 않으므로 계속 연결이 되어있다고 보면된다.\n따라서, 30초 이후에 <code class=\"language-text\">TIME_WAIT</code> 소켓이 발생할 것이다.</p>\n<blockquote>\n<p>❗❗ 중요\n여기서 Nginx로 설정한 <code class=\"language-text\">keepalive_time 30;</code> 과 같은 keep-alive는 HTTP/1.1의 지속커넥션<sup id=\"fnref-15\"><a href=\"#fn-15\" class=\"footnote-ref\">15</a></sup> 에 해당한다.\nTCP에도 keep-alive가 존재하는데 혼동해서는 안된다. TCP keep-alive는 밑에서 다룰 예정이다.</p>\n</blockquote>\n<h4 id=\"step-313-time_wait-소켓의-존재-의의\" style=\"position:relative;\"><a href=\"#step-313-time_wait-%EC%86%8C%EC%BC%93%EC%9D%98-%EC%A1%B4%EC%9E%AC-%EC%9D%98%EC%9D%98\" aria-label=\"step 313 time_wait 소켓의 존재 의의 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.1.3 TIME_WAIT 소켓의 존재 의의</h4>\n<p>위에서 간략하게 클라이언트의 측면과 서버 측면에서 살펴보았다.</p>\n<p>결국, <code class=\"language-text\">TIME_WAIT</code>가 자주 발생하면 Handshake가 잦아져서 성능 저하가 일어날 수 있다는 것도 알게되었다.</p>\n<p>그러면, 왜 불편하게 이러한 상태를 만들었을까?</p>\n<p>4-way Handshake를 다시 떠올려보자. 결국, Passive Closer는 소켓을 닫기 위해서 <code class=\"language-text\">LAST_ACK</code>을 Active Closer쪽에서 받아야한다.</p>\n<p>만약, <code class=\"language-text\">TIME_WAIT</code> 가 없이 바로 정리를 하게 된다면 <code class=\"language-text\">ACK</code>을 Passive Closer쪽 전달을 못할 것이고, 그렇다면 클라이언트 소켓 정리가 이뤄지지 않을 것이다.</p>\n<p>즉, <code class=\"language-text\">TIME_WAIT</code>가 없다면 Passive Closer쪽에는 <code class=\"language-text\">LAST_ACK</code> 상태인 소켓이 많이 쌓일 수 있을 것이다.</p>\n<p>추가로, 네트워크 문제로 Active Closer가 <code class=\"language-text\">ACK</code> 을 보냈지만 유실되어도 Passive Closer 쪽에서 다시 <code class=\"language-text\">FIN</code> 을 보내면 정상 연결종료 처리가 가능할 것이다.</p>\n<p>결론적으로, <strong>연결 종료에 어느정도 유예를 줘서 바로 연결 종료했을 경우에 발생할 수 있는 문제점들을 해결하는 중요한 소켓</strong>이라 볼 수 있다.</p>\n<h3 id=\"step-33-tcp-keep-alive\" style=\"position:relative;\"><a href=\"#step-33-tcp-keep-alive\" aria-label=\"step 33 tcp keep alive permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.3 TCP Keep-Alive</h3>\n<p>이번에는 TCP keep-alive에 대해서 다뤄보고자 한다.</p>\n<p>위에서 본 Nginx의 keep-alive와 비슷하게, TCP keep-alive도 너무 잦은 3-way Handshake를 줄이기 위해, 두 TCP 소켓끼리 지속적으로 세션을 유지하는 기법이다.</p>\n<p>TCP keep-alive는 3-way Handshake 이후에 수립된 세션끼리 주기적으로 작은 양의 패킷을 보내 세션을 유지한다.</p>\n<p>현재, 우리가 OS 상에 사용 중인 인터넷 소켓이 keep-alive를 지원하는지 보기위해서는 <code class=\"language-text\">netstat</code> 로 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">netstat -napo\n#(Not all processes could be identified, non-owned process info\n# will not be shown, you would have to be root to see it all.)\n# Active Internet connections (servers and established)\n# Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name     Timer\n#tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      -                    off (0.00/0/0)\n#tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      -                    off (0.00/0/0)\n#tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      -                    off (0.00/0/0)\n#tcp        0      0 0.0.0.0:6379            0.0.0.0:*               LISTEN      -                    off (0.00/0/0)\ntcp        0      0 192.168.106.3:22        192.168.106.1:64216     ESTABLISHED -                    keepalive (5652.84/0/0)\ntcp        0      0 192.168.106.3:22        192.168.106.1:49449     ESTABLISHED -                    keepalive (6759.23/0/0)\n#tcp6       0      0 :::80                   :::*                    LISTEN      -                    off (0.00/0/0)\n#tcp6       0      0 :::22                   :::*                    LISTEN      -                    off (0.00/0/0)\n#tcp6       0      0 :::6379                 :::*                    LISTEN      -                    off (0.00/0/0)\n#udp        0      0 127.0.0.53:53           0.0.0.0:*                           -                    off (0.00/0/0)\n#udp        0      0 192.168.106.3:68        0.0.0.0:*                           -                    off (0.00/0/0)\n#raw6       0      0 :::58                   :::*                    7           -                    off (0.00/0/0)</code></pre></div>\n<p>필자 가상환경에서는 SSH 사용하는 부분에 대한 소켓이 keep-alive로 동작하는 것을 볼 수 있다. keepalive 뒤에 숫자는 타이머의 남은 시간이다.</p>\n<p>위에서 설명한 것과 같이 이 타이머의 시간이 다 쓰게되면, 작은 패킷을 보내서 살아있는지를 확인한다.</p>\n<p>그렇다면, keep-alive한 소켓은 어떻게 생성할까? 유저 공간에서 <code class=\"language-text\">setsockopt()</code><sup id=\"fnref-16\"><a href=\"#fn-16\" class=\"footnote-ref\">16</a></sup> 이라는 시스템 콜을 호출 시 인자 중에 <code class=\"language-text\">optname</code> 을 통해서 keep-alive 소켓을 생성할 수 있다.</p>\n<p>인자를 <code class=\"language-text\">SO_KEEPALIVE</code> 에 해당하는 값으로 전달하면 keep-alive 소켓이 생성되며, 커널 공간 내부적으로 <code class=\"language-text\">struct sock_common</code> 쪽에 <code class=\"language-text\">sck_flag</code>라는 값에 <code class=\"language-text\">SO_KEEPALIVE</code> 플래그가 설정되어 세팅된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">//https://github.com/torvalds/linux/blob/master/include/net/sock.h#L211</span>\n<span class=\"token comment\">/**\n *\t@skc_flags: place holder for sk_flags\n *\t\t%SO_LINGER (l_onoff), %SO_BROADCAST, %SO_KEEPALIVE,\n *\t\t%SO_OOBINLINE settings, %SO_TIMESTAMPING settings\n **/</span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">sock_common</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">union</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span>\tskc_flags<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">sock</span>\t<span class=\"token operator\">*</span>skc_listener<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* request_sock */</span>\n\t\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">inet_timewait_death_row</span> <span class=\"token operator\">*</span>skc_tw_dr<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* inet_timewait_sock */</span>\n\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>현대의 어플리케이션에서는 대부분 TCP keep-alive 설정을 할 수 있는 별도 옵션을 제공하는데 필자는 Redis를 활용해보겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">telnet 127.0.0.1 6379 # 별도 터미널에서 수행 (연결하기 위함)\n\nnetstat -napo | grep -i :6379 | grep -i est\n(Not all processes could be identified, non-owned process info\n will not be shown, you would have to be root to see it all.)\ntcp        0      0 127.0.0.1:42396         127.0.0.1:6379          ESTABLISHED 7810/telnet          off (0.00/0/0)\ntcp        0      0 127.0.0.1:6379          127.0.0.1:42396         ESTABLISHED -                    off (0.00/0/0)</code></pre></div>\n<p>레디스는 3.2.1 부터 default로 <code class=\"language-text\">tcp-keepalive</code> 옵션이 300으로 설정되어있다. 따라서, 위 그림은 0으로 세팅한 후 본 결과라 생각하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">127.0.0.1:6379&gt; config get tcp-keepalive\n1) &quot;tcp-keepalive&quot;\n2) &quot;0&quot;\n\n127.0.0.1:6379&gt; config set tcp-keepalive 300\nOK\n\n127.0.0.1:6379&gt; config get tcp-keepalive\n1) &quot;tcp-keepalive&quot;\n2) &quot;300&quot;\n\n\nnetstat -napo | grep -i :6379 | grep -i est\n(Not all processes could be identified, non-owned process info\n will not be shown, you would have to be root to see it all.)\ntcp        0      0 127.0.0.1:51032         127.0.0.1:6379          ESTABLISHED 7843/telnet          off (0.00/0/0)\ntcp        0      0 127.0.0.1:6379          127.0.0.1:51032         ESTABLISHED -                    keepalive (297.74/0/0)</code></pre></div>\n<p>위와 같이 keep-alive 설정을 통해서 타이머가 가고 있는 것을 확인할 수 있다. 이를 실제로 덤프를 떠서 와이어샤크로 확인하면 아래와 같은 내용을 볼 수 있다.</p>\n<p><img src=\"https://i.imgur.com/08Pd1ws.png\" alt=\"\"></p>\n<p>우리가 예상했던 것과 같이 주기적으로 keep-alive 패킷을 보내고 있다. 필자는 이 덤프를 뜨기 위해서 <code class=\"language-text\">tcp-keepalive</code> 값을 10으로 선언하였고, 10초마다 keep-alive 패킷과 keep-alive ACK 패킷이 발생하는 것을 볼 수 있다.</p>\n<h4 id=\"step-331-tcp-keep-alive-파라미터\" style=\"position:relative;\"><a href=\"#step-331-tcp-keep-alive-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0\" aria-label=\"step 331 tcp keep alive 파라미터 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.3.1 TCP Keep-Alive 파라미터</h4>\n<p>위에서는 TCP keep-alive가 무엇이고, 동작 원리는 어떻게 되는가를 확인하였다. 그렇다면 이와 관련된 커널 파라미터는 어떤 것들이 있을까?</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">sudo sysctl -a | grep -i keepalive\nnet.ipv4.tcp_keepalive_intvl = 75\nnet.ipv4.tcp_keepalive_probes = 9\nnet.ipv4.tcp_keepalive_time = 7200</code></pre></div>\n<ol>\n<li><code class=\"language-text\">net.ipv4.tcp_keepalive_intvl</code> : <strong>keep-alive 패킷을 보내는 주기</strong>, <code class=\"language-text\">net.ipv4.tcp_keepalive_time</code>이 지난 후 확인 패킷을 보내게 되는데, 응답이 없으면 몇 초 후에 재전송 패킷을 보낼지 정의</li>\n<li><code class=\"language-text\">net.ipv4.tcp_keepalive_probes</code> : k<strong>eep-alive 패킷을 보낼 최대 전송 횟수</strong>를 정의, 다양한 원인으로 인해서 패킷 유실이 될 수 있으므로 재전송 매커니즘이 필요한데 최대 재전송 횟수를 정의한다.</li>\n<li><code class=\"language-text\">net.ipv4.tcp_keepalive_time</code> : <strong>keep-alive 소켓의 유지시간</strong>이며, 최소한 7200초를 유지한다. 타이머는 이 시간을 기준으로 동작한다. (Redis 예시와 같이 이 값은 지정 가능하다.)</li>\n</ol>\n<p>그림으로 보면 아래와 같다.</p>\n<p align=\"center\">\n    <img src=\"https://i.imgur.com/pOF6AWj.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.yes24.com/Product/Goods/44376723\">그림 15. TCP Keep-Alive 파라미터 동작 원리, DevOps와 SE를 위한 리눅스 커널 이야기(강진우 저), 2017</a></em>\n</p>\n<h4 id=\"step-332-좀비-커넥션\" style=\"position:relative;\"><a href=\"#step-332-%EC%A2%80%EB%B9%84-%EC%BB%A4%EB%84%A5%EC%85%98\" aria-label=\"step 332 좀비 커넥션 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.3.2 좀비 커넥션</h4>\n<p>위에서 TCP keep-alive 동작 매커니즘과 keep-alive 커널 파라미터등을 보았다.</p>\n<p>이를 통해서 불필요한 Handsahke를 줄여 서비스의 품질을 높이는 효과도 있지만, 더 큰 효과는 <strong>좀비 커넥션 방지</strong>이다.</p>\n<p>좀비 커넥션은 <strong>두 개의 세션 중에서 하나가 종료를 했음에도 다른 한쪽이 계속 살아있는 비정상적인 커넥션</strong>을 뜻한다.</p>\n<p>이에 대한 검증을 수행해보자. 이를 위해 Mysql을 사용할 것인데, 아래의 간단한 스크립트를 사용해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">#!/usr/bin/python\n# -*- coding: utf-8 -*-\nimport pymysql\nimport sys\nimport time\nfrom datetime import datetime\n\ncon = pymysql.connect(host=&#39;localhost&#39;, user=&#39;root&#39;, password=&#39;root&#39;, db=&#39;mysql&#39;, charset=&#39;utf8&#39;);\n\nwhile True:\n    cur = con.cursor()\n    cur.execute(&quot;SELECT VERSION()&quot;)\n    ver = cur.fetchone()\n    print(&quot;Database version : %s &quot; % ver)\n    time.sleep(600)</code></pre></div>\n<ul>\n<li>mysqld가 정상적으로 종료되는 케이스</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\"># 파이썬 코드를 수행 후 초기 상황 \nnetstat -napo | grep -i :3306\n(Not all processes could be identified, non-owned process info\n will not be shown, you would have to be root to see it all.)\ntcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN      -                    off (0.00/0/0)\ntcp        0      0 172.17.0.1:50404        172.17.0.2:3306         ESTABLISHED -                    keepalive (6.64/0/0)\ntcp        0      0 127.0.0.1:33354         127.0.0.1:3306          ESTABLISHED 26338/python3        keepalive (7176.40/0/0)\ntcp        0      0 127.0.0.1:3306          127.0.0.1:33354         ESTABLISHED -                    keepalive (6.64/0/0)\ntcp6       0      0 :::3306                 :::*                    LISTEN      -                    off (0.00/0/0)\n\n# Mysql 서버를 정상 종료 시에 상황 \nnetstat -napo | grep -i :3306\n(Not all processes could be identified, non-owned process info\n will not be shown, you would have to be root to see it all.)\ntcp        1      0 127.0.0.1:33354         127.0.0.1:3306          CLOSE_WAIT  26338/python3        keepalive (7042.06/0/0)\ntcp        0      0 127.0.0.1:3306          127.0.0.1:33354         FIN_WAIT2   -                    timewait (54.04/0/0)</code></pre></div>\n<p>Mysql을 가동하고 위 스크립트를 동작시켰을 시에 초기에는 <code class=\"language-text\">ESTABLISHED</code> 상태임을 확인할 수 있다. 이후, <code class=\"language-text\">docker stop mysql</code> 을 통해서 정상 종료를 시켰다.</p>\n<p>그 이후에 클라이언트의 상태가 <code class=\"language-text\">CLOSE_WAIT</code>가 되었음을 확인할 수있다. 즉, <code class=\"language-text\">FIN</code> 패킷이 정상적으로 클라이언트에 수신된 것이다.</p>\n<ul>\n<li>비정상적인 동작으로 연결 패킷이 유실되는 경우</li>\n</ul>\n<p>이번 시나리오는 강제로 <code class=\"language-text\">iptables</code>를 활용하여 모든 패킷을 DROP 시켜보는 상황이다. 다시 Mysql 서버를 가동 후에 스크립트를 돌린 후에 아래의 명령어를 수행해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\"># 정상 연결 수립 상황 \nnetstat -napo | grep -i :3306\n(Not all processes could be identified, non-owned process info\n will not be shown, you would have to be root to see it all.)\ntcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN      -                    off (0.00/0/0)\ntcp        0      0 127.0.0.1:36210         127.0.0.1:3306          ESTABLISHED 26760/python3        keepalive (7196.60/0/0)\ntcp        0      0 127.0.0.1:3306          127.0.0.1:36210         ESTABLISHED -                    keepalive (11.60/0/0)\ntcp        0      0 172.17.0.1:52948        172.17.0.2:3306         ESTABLISHED -                    keepalive (11.61/0/0)\ntcp6       0      0 :::3306                 :::*                    LISTEN      -                    off (0.00/0/0)\n\n# 클라이언트 소켓으로 나가는 패킷을 전부 드랍 후 Mysql 서버 종료 \nsudo iptables -A OUTPUT -p tcp -d 127.0.0.1 -j DROP\ndocker stop mysql\n\n# 이후 상황\nnetstat -napo | grep -i :3306\n(Not all processes could be identified, non-owned process info\n will not be shown, you would have to be root to see it all.)\ntcp        0      0 127.0.0.1:36210         127.0.0.1:3306          ESTABLISHED 26760/python3        keepalive (7119.27/0/0)\ntcp        0      1 127.0.0.1:3306          127.0.0.1:36210         FIN_WAIT1   -                    probe (0.89/0/4)</code></pre></div>\n<p>보면, 여전히 <code class=\"language-text\">ESTABLISHED</code> 상태임을 확인할 수 있다. 필자의 가상머신의 <code class=\"language-text\">net.ipv4.tcp_keepalive_time</code> 값은 7200초라 디폴트로 7200초부터 타이머가 흐르는 것도 확인할 수 있다.</p>\n<p>우리가 위에서 본 내용처럼 실제로 <code class=\"language-text\">net.ipv4.tcp_keepalive_intvl</code> 이후마다 keep-alive 패킷을 보내고 <code class=\"language-text\">net.ipv4.tcp_keepalive_probes</code> 에 명시된 최대 재전송 이후에 이 커넥션이 종료가 될까? 이를 위해 TCP 덤프를 떠보겠다.</p>\n<p>필자는 좀 더 빠르게 상황을 재현하기 위해 아래와 같이 커널 파라미터를 변경하였다.</p>\n<ul>\n<li><code class=\"language-text\">net.ipv4.tcp_keepalive_intvl</code> : 10</li>\n<li><code class=\"language-text\">net.ipv4.tcp_keepalive_probes</code> : 5</li>\n<li><code class=\"language-text\">net.ipv4.tcp_keepalive_time</code> : 10</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\"># 비정상 종료로 인하여 ESTABLISHED 상태로 남아있으나, probe 값이 증가가 되고 있는 것을 확인할 수 있음\nnetstat -napo | grep -i :3306\n(Not all processes could be identified, non-owned process info\n will not be shown, you would have to be root to see it all.)\ntcp        0      1 127.0.0.1:3306          127.0.0.1:49424         FIN_WAIT1   -                    probe (18.34/0/7)\ntcp        0      0 127.0.0.1:49424         127.0.0.1:3306          ESTABLISHED 1357/python3         keepalive (9.65/0/4)\n\n\n# 설정된 probe 값만큼 패킷 재전송 후 클라이언트 소켓이 정리된 상황 (좀비커넥션 정리 완료)\n netstat -napo | grep -i :3306\n(Not all processes could be identified, non-owned process info\n will not be shown, you would have to be root to see it all.)\ntcp        0      1 127.0.0.1:3306          127.0.0.1:49424         FIN_WAIT1   -                    probe (51.70/0/8)</code></pre></div>\n<p>즉, 우리가 알아봤던 내용대로 동작하는 것을 확인할 수 있다.</p>\n<h4 id=\"step-333-http-지속커넥션-vs-tcp-keep-alive\" style=\"position:relative;\"><a href=\"#step-333-http-%EC%A7%80%EC%86%8D%EC%BB%A4%EB%84%A5%EC%85%98-vs-tcp-keep-alive\" aria-label=\"step 333 http 지속커넥션 vs tcp keep alive permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.3.3 HTTP 지속커넥션 vs TCP Keep-Alive</h4>\n<p>위에서 우리가 잠깐 Nginx를 통해서 <code class=\"language-text\">keepalive_timeout</code>옵션을 건드려서 <code class=\"language-text\">TIME_WAIT</code> 소켓을 많이 생성하는 부분들을 보았다.\n그런데 그 부분에서 필자는 이 부분은 TCP keep-alive와는 다르다고 했다. 사실, Nginx에서 사용하는 부분은 HTTP/1.1의 지속커넥션<sup id=\"fnref-15\"><a href=\"#fn-15\" class=\"footnote-ref\">15</a></sup> 에 해당한다.</p>\n<p>두 가지의 차이점은 아래와 같다.</p>\n<ul>\n<li>TCP Keep-Alive : <strong>네트워크 상의 장애나 일시적인 문제로 인해 연결이 끊어졌는지 확인하기 위한 메커니즘이며, 연결이 유효한지 주기적으로 확인하는 방식</strong></li>\n<li>HTTP 지속커넥션 : <strong>응답 이후 TCP 연결을 닫지 않고, 일정 시간동안 기다려서 하나의 TCP로 다양한 요청/응답을 처리하는 매커니즘.</strong></li>\n</ul>\n<p>HTTP 지속커넥션은 위에서 본 Connection Pool과 비슷하다고 볼 수도 있다. 이를 이해하기 위해서는 HTTP/1.0에 대해서 설명이 필요하다.\nHTTP/1.0에서는 매 요청마다 새로운 TCP 소켓을 생성했다. 그러다보니 매 요청마다 Handshake가 발생했다. 그러나, 웹이 처리하는 정보들이 복잡해지면서 많은 요청/응답들이 생겨났면서 오버헤드가 가파르게 증가했다.\n이러한 문제때문에 HTTP/1.1부터는 지속커넥션을 도입해서 연결 수립 이후 해당 소켓을 재활용하여 오버헤드를 줄인 것이다.</p>\n<p>그렇다면 두 값이 다를 경우에는 어떻게 처리가 될까?</p>\n<p>2가지 시나리오가 있을 수 있다.</p>\n<ol>\n<li><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mi>T</mi><mi>T</mi><msub><mi>P</mi><mrow><mi>P</mi><mi>e</mi><mi>r</mi><mi>s</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>e</mi><mtext> </mtext><mi>C</mi><mi>o</mi><mi>n</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></msub><mo>></mo><mi>T</mi><mi>C</mi><msub><mi>P</mi><mrow><mi>K</mi><mi>e</mi><mi>e</mi><mi>p</mi><mo>−</mo><mi>A</mi><mi>l</mi><mi>i</mi><mi>v</mi><mi>e</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">HTTP_{Persistence\\,Conenction} > TCP_{Keep-Alive}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">TT</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal mtight\">ers</span><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">e</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mord mathnormal mtight\">ce</span><span class=\"mspace mtight\" style=\"margin-right:0.1952em;\"></span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mord mathnormal mtight\">e</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mord mathnormal mtight\">c</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">TC</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">Kee</span><span class=\"mord mathnormal mtight\">p</span><span class=\"mbin mtight\">−</span><span class=\"mord mathnormal mtight\">A</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> : HTTP 지속커넥션 Timeout이 TCP Keep-Alive Timeout 값보다 큰 경우</li>\n<li><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mi>T</mi><mi>T</mi><msub><mi>P</mi><mrow><mi>P</mi><mi>e</mi><mi>r</mi><mi>s</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>e</mi><mtext> </mtext><mi>C</mi><mi>o</mi><mi>n</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></msub><mo>&#x3C;</mo><mi>T</mi><mi>C</mi><msub><mi>P</mi><mrow><mi>K</mi><mi>e</mi><mi>e</mi><mi>p</mi><mo>−</mo><mi>A</mi><mi>l</mi><mi>i</mi><mi>v</mi><mi>e</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">HTTP_{Persistence\\,Conenction} &#x3C; TCP_{Keep-Alive}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">TT</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal mtight\">ers</span><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">e</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mord mathnormal mtight\">ce</span><span class=\"mspace mtight\" style=\"margin-right:0.1952em;\"></span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mord mathnormal mtight\">e</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mord mathnormal mtight\">c</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&#x3C;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">TC</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">Kee</span><span class=\"mord mathnormal mtight\">p</span><span class=\"mbin mtight\">−</span><span class=\"mord mathnormal mtight\">A</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> : HTTP 지속커넥션 Timeout이 TCP Keep-Alive Timeout 값보다 작은 경우</li>\n</ol>\n<p>이 두개의 시나리오는 그림으로 보는 것이 좋을 것 같다.</p>\n<ul>\n<li><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mi>T</mi><mi>T</mi><msub><mi>P</mi><mrow><mi>P</mi><mi>e</mi><mi>r</mi><mi>s</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>e</mi><mtext> </mtext><mi>C</mi><mi>o</mi><mi>n</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></msub><mo>></mo><mi>T</mi><mi>C</mi><msub><mi>P</mi><mrow><mi>K</mi><mi>e</mi><mi>e</mi><mi>p</mi><mo>−</mo><mi>A</mi><mi>l</mi><mi>i</mi><mi>v</mi><mi>e</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">HTTP_{Persistence\\,Conenction} > TCP_{Keep-Alive}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">TT</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal mtight\">ers</span><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">e</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mord mathnormal mtight\">ce</span><span class=\"mspace mtight\" style=\"margin-right:0.1952em;\"></span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mord mathnormal mtight\">e</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mord mathnormal mtight\">c</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">TC</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">Kee</span><span class=\"mord mathnormal mtight\">p</span><span class=\"mbin mtight\">−</span><span class=\"mord mathnormal mtight\">A</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> 경우</li>\n</ul>\n<p><img src=\"https://i.imgur.com/I4NkfSr.png\" alt=\"\"></p>\n<ul>\n<li>HTTP Keep-Alive Timeout : 60초</li>\n<li>TCP Keep-Alive Timeout : 30초</li>\n</ul>\n<p>30초 마다 TCP Keep-Alive는 패킷을 보내 살아있는지 여부를 확인하고, 다시 타이머를 초기화한다.\n60초가 되었을 시점에는 HTTP Keep-Alive 타임아웃이 발생하고, 서버가 먼저 클라이언트와의 연결을 종료한다.</p>\n<ul>\n<li><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mi>T</mi><mi>T</mi><msub><mi>P</mi><mrow><mi>K</mi><mi>e</mi><mi>e</mi><mi>p</mi><mo>−</mo><mi>A</mi><mi>l</mi><mi>i</mi><mi>v</mi><mi>e</mi></mrow></msub><mo>&#x3C;</mo><mi>T</mi><mi>C</mi><msub><mi>P</mi><mrow><mi>K</mi><mi>e</mi><mi>e</mi><mi>p</mi><mo>−</mo><mi>A</mi><mi>l</mi><mi>i</mi><mi>v</mi><mi>e</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">HTTP_{Keep-Alive} &#x3C; TCP_{Keep-Alive}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">TT</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">Kee</span><span class=\"mord mathnormal mtight\">p</span><span class=\"mbin mtight\">−</span><span class=\"mord mathnormal mtight\">A</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&#x3C;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">TC</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">Kee</span><span class=\"mord mathnormal mtight\">p</span><span class=\"mbin mtight\">−</span><span class=\"mord mathnormal mtight\">A</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> 경우</li>\n</ul>\n<p><img src=\"https://i.imgur.com/iQWwnVa.png\" alt=\"\"></p>\n<ul>\n<li>HTTP Keep-Alive Timeout : 30초</li>\n<li>TCP Keep-Alive Timeout : 60초</li>\n</ul>\n<p>30초가 되었을 시점에는 HTTP Keep-Alive 타임아웃이 발생하고, 서버가 먼저 클라이언트와의 연결을 종료한다. 이때, TCP Keep-Alive Timeout이 60초지만 종료 요청을 받은 후 정리가 같이 된다.</p>\n<p>결론적으로 <strong>HTTP 지속커넥션이 설정되어있다면 해당 설정값에 맞춰 동작한다고 보면 될 것</strong>이다. 따라서, 이 값이 다르다고 걱정하지 않아도 된다.</p>\n<h4 id=\"step-334-로드-밸런서와-tcp-keep-alive\" style=\"position:relative;\"><a href=\"#step-334-%EB%A1%9C%EB%93%9C-%EB%B0%B8%EB%9F%B0%EC%84%9C%EC%99%80-tcp-keep-alive\" aria-label=\"step 334 로드 밸런서와 tcp keep alive permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.3.4 로드 밸런서와 TCP Keep-Alive</h4>\n<p>저자인 진우님께서는 책에 MQ 서버와 로드 밸런서에서 생긴 사례를 공유해주셨다.</p>\n<p><img src=\"https://i.imgur.com/zgECd9A.png\" alt=\"\"></p>\n<p>위 그림을 간단히 설명하면 아래와 같을 것이다.</p>\n<ol>\n<li>Client가 로드밸런서(LB)에 연결 수립요청을 보냄</li>\n<li>로드밸런서는 MQ(1010.10.11)에 연결 수립을 한 후 세션테이블에 클라이언트 IP와 포트, 서버 IP와 포트를 기록해둔다.</li>\n<li>로드밸런서로 부터 연결 수립요청을 받은 MQ는 클라이언트에게 바로 <code class=\"language-text\">SYN+ACK</code> 패킷으로 응답한다.</li>\n</ol>\n<p>그림을 보면 <code class=\"language-text\">SYN+ACK</code> 은 로드밸런서를 거치지않고, 바로 클라이언트에게 보내지는데 대부분의 로드밸런서가 DSR(Direct Server Return)<sup id=\"fnref-17\"><a href=\"#fn-17\" class=\"footnote-ref\">17</a></sup> 방식을 따르기 때문이다.</p>\n<p>이 부분은 얼핏보면 문제가 없어보인다. 하지만, 세션테이블은 무한정 늘어날 수 없고, 일정 주기로 비워진다. 이 주기가 Idle Timeout이다.\n이 Idle Timeout때문에 문제가 발생할 수 있는데 세션테이블은 지워졌는데 클라이언트가 또 요청을 할 수 있다. 이 경우에 로드밸런서의 라운드로빈 정책에 따라 새로운 서버로 요청이 인입될 수 있다.</p>\n<p>이 상황은 아래 그림과 같다.</p>\n<p><img src=\"https://i.imgur.com/UZfDqIs.png\" alt=\"\"></p>\n<p>기존 MQ가 아닌 다른 MQ에 요청이 전달되었고, 이 MQ는 Handshake 맺지 않은 상태기때문에 비정상적인 패킷이라 생각하여 RST패킷을 보낸다.\n아주 운이 좋게 클라이언트가 기존에 연결되었던 MQ와 연결이 되면 문제가 없을 수 있지만, 그렇지 않은 경우에는 클라이언트 입장에서는 Timeout이 발생하게 된다.</p>\n<p>이런 문제가 발생하면 클라이언트는 새로운 커넥션을 열어서 새로운 서버와 연결한다. 그런데, <strong>기존 클라이언트와 연결되어있던 서버는 이러한 행동을 알 수가 없고 이에 좀비 커넥션이 다량으로 발생</strong>하게 된다.</p>\n<p>그렇다면, 이를 어떻게 해결할 수 있을까? 우리는 이 해결책을 위에서 좀비 커넥션 얘기를 하면서 다뤘었다. 바로 <strong>TCP Keep-Alive 옵션</strong>이다.</p>\n<p>책의 저자인 진우님께서는 로드밸런서의 Idle Timeout은 120초인 상황이었고, 120초 내에 Keep-Alive Timeout을 식별하도록 파라미터를 수정하여 해당 케이스를 해결하였다한다.</p>\n<h3 id=\"step-34-tcp-재전송과-타임아웃\" style=\"position:relative;\"><a href=\"#step-34-tcp-%EC%9E%AC%EC%A0%84%EC%86%A1%EA%B3%BC-%ED%83%80%EC%9E%84%EC%95%84%EC%9B%83\" aria-label=\"step 34 tcp 재전송과 타임아웃 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.4 TCP 재전송과 타임아웃</h3>\n<p>이제 TCP의 마지막 내용인 재전송과 타임아웃을 볼 차례이다.</p>\n<p>TCP 패킷이 유실이 발생할 수 있는 부분은 언제일까? 이 질문에 대한 답은 2가지로 볼 수 있다.</p>\n<ol>\n<li>연결 수립 과정 시</li>\n<li>연결 수립 이후 통신 시</li>\n</ol>\n<p>이 두 가지로 볼 수 있다. TCP는 UDP와 다르게 <strong>신뢰성있는 프로토콜</strong>이라고 많이들 얘기한다.\n아마도, 이 포스팅을 보는 저자들도 이 개념에 대해서는 알고 있을 것이라 생각한다. 이 신뢰성을 보장하기 위해서 요청한 후 이 요청이 올바르게 갔다는 뜻으로 <code class=\"language-text\">ACK</code> 을 보낸다.</p>\n<p>하지만 이 <code class=\"language-text\">ACK</code>이 유실되는 경우에는 어떻게 통신이 이뤄질까? 이때, 바로 요청을 재전송하게 된다. 그렇다면, 기다리는 기준이 있을 것인데 이 기준은 어떻게 될까?</p>\n<p>위 포스팅에서도 잠깐 <code class=\"language-text\">net.ipv4.tcp_tw_recycle</code>을 다룬 개념이 있는데 바로, RTO(Retransmission Timeout)<sup id=\"fnref-14\"><a href=\"#fn-14\" class=\"footnote-ref\">14</a></sup> 이다.</p>\n<p>RTO 또한, 2가지 종류가 있다.</p>\n<ol>\n<li>연결 수립 이전에 <code class=\"language-text\">ACK</code> 수신에 대한 기준 값 : InitRTO (<a href=\"https://datatracker.ietf.org/doc/html/rfc6298\">RFC6298</a>에 따라서 1초로 설정되어있음)</li>\n<li>연결 수립 이후 <code class=\"language-text\">ACK</code> 수신에 대한 기준 값 : 일반적인 RTO</li>\n</ol>\n<p>즉, 연결 수립 이전에 패킷 손실 여부를 파악하기 위해서는 InitRTO가 1초로 설정 되어있기 때문에 최소한 1초는 기다려야 손실 여부를 파악할 수 있다.\n그렇다면, 일반적인 RTO는 어떻게 정해질까? 이는 <a href=\"https://datatracker.ietf.org/doc/html/rfc6298\">RFC6298</a> 2.2에 잘 나와있다.</p>\n<p>한번, RTT가 측정되면 아래와 같이 처리된다.</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mtable rowspacing=\"0.16em\" columnalign=\"center\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>g</mi><mi>i</mi><mi>v</mi><mi>e</mi><mi>n</mi><mspace width=\"1em\"></mspace><mi>F</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mtext> </mtext><mi>R</mi><mi>T</mi><mi>T</mi><mtext> </mtext><mi>m</mi><mi>e</mi><mi>s</mi><mi>a</mi><mi>u</mi><mi>r</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo>=</mo><mi>R</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>g</mi><mi>i</mi><mi>v</mi><mi>e</mi><mi>n</mi><mspace width=\"1em\"></mspace><mi>C</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi><mtext> </mtext><mi>G</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>u</mi><mi>l</mi><mi>a</mi><mi>r</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo>=</mo><mi>G</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>S</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>⇐</mo><mi>R</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>R</mi><mi>T</mi><mi>T</mi><mi>V</mi><mi>A</mi><mi>R</mi><mo>⇐</mo><mfrac><mi>R</mi><mn>2</mn></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>R</mi><mi>T</mi><mi>O</mi><mo>=</mo><mi>S</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy=\"false\">(</mo><mi>G</mi><mo separator=\"true\">,</mo><mi>K</mi><mo>∗</mo><mi>R</mi><mi>T</mi><mi>T</mi><mi>V</mi><mi>A</mi><mi>R</mi><mo stretchy=\"false\">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding=\"application/x-tex\">\\begin{matrix}\ngiven\\quad First\\,RTT\\,mesaurement = R\\\\ \ngiven\\quad Clock\\,Granularity = G\\\\  \nSRTT \\Leftarrow R  \\\\\nRTTVAR \\Leftarrow \\frac{R}{2} \\\\\\\\\nRTO = SRTT + max(G, K * RTTVAR)\n\\end{matrix}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:7.2323em;vertical-align:-3.3662em;\"></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:3.8662em;\"><span style=\"top:-6.0262em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">rs</span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">RTT</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">es</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">re</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span><span style=\"top:-4.8262em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">Cl</span><span class=\"mord mathnormal\">oc</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">an</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">G</span></span></span><span style=\"top:-3.6262em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">SRTT</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⇐</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span><span style=\"top:-2.3938em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">RTT</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⇐</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8723em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span><span style=\"top:-1.1938em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"></span></span><span style=\"top:0.0062em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">RTO</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">SRTT</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\">ma</span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">G</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">RTT</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:3.3662em;\"><span></span></span></span></span></span></span></span></span></span></span></span></div>\n<p>해당 수식에 대해서 좀 더 알고 싶다면, <a href=\"https://cs.colby.edu/courses/F19/cs331/notes/6.TransportLayer(4).pdf\">Colby College - Computer Science, Transport Layer</a> 해당 내용을 참고하도록 하자.</p>\n<p>위와 같은 값들을 토대로 TCP는 재전송을 하게 되는데 초기 재전송 이후에는 TCP는 지수적 백오프(Exponentional BackOff)<sup id=\"fnref-18\"><a href=\"#fn-18\" class=\"footnote-ref\">18</a></sup> 를 통해서 재전송을 하게 된다.\n지수적 백오프는  <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mi>T</mi><mi>O</mi><mo>=</mo><mi>q</mi><mo>∗</mo><mi>R</mi><mi>T</mi><mi>O</mi></mrow><annotation encoding=\"application/x-tex\">RTO = q * RTO</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">RTO</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6597em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">RTO</span></span></span></span></span> 와 같은 식이라 보면되고, q는 여기서 주로 2로 설정해서 사용한다.</p>\n<p>따라서, RTO 값이 200ms였으면 200 -> 400 -> 800 -> 1600으로 점진적으로 증가한다. 그렇다면 재전송 횟수는 제한 없이 무한정 커지게 될까? 이는 커널파라미터를 통해서 확인할 수 있다.</p>\n<h4 id=\"step-341-tcp-재전송-커널파라미터\" style=\"position:relative;\"><a href=\"#step-341-tcp-%EC%9E%AC%EC%A0%84%EC%86%A1-%EC%BB%A4%EB%84%90%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0\" aria-label=\"step 341 tcp 재전송 커널파라미터 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.4.1 TCP 재전송 커널파라미터</h4>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">sudo sysctl -a | grep -i retries\nnet.ipv4.tcp_orphan_retries = 0\nnet.ipv4.tcp_retries1 = 3\nnet.ipv4.tcp_retries2 = 15\nnet.ipv4.tcp_syn_retries = 6\nnet.ipv4.tcp_synack_retries = 5</code></pre></div>\n<p>위 내용들이 바로 재전송 작업과 관련된 커널 파라미터이다.</p>\n<ol>\n<li><code class=\"language-text\">net.ipv4.tcp_orphan_retries</code> : <code class=\"language-text\">FIN_WAIT1</code> 상태의 소켓인 경우에 <code class=\"language-text\">FIN</code> 패킷에 대한 최대 재전송 횟수 정의</li>\n<li><code class=\"language-text\">net.ipv4.tcp_retries1</code> : IP 레이어에 네트워크가 잘못 되었는지 확인토록 사인을 보내는 기준 (soft threshold)</li>\n<li><code class=\"language-text\">net.ipv4.tcp_retries2</code> : 더 이상 통신을 할 수 없다 판단하는 기준 (hard threshold)</li>\n<li><code class=\"language-text\">net.ipv4.tcp_syn_retries</code> : 초기 연결 수립 시 <code class=\"language-text\">SYN</code> 패킷에 대한 최대 재전송 횟수 정의</li>\n<li><code class=\"language-text\">net.ipv4.tcp_synack_retries</code> : 상대편이 보낸 <code class=\"language-text\">SYN</code> 패킷에 대해 응답을 보내는 <code class=\"language-text\">SYN + ACK</code> 의 최대 재전송 횟수 정의</li>\n</ol>\n<p>여기서, <code class=\"language-text\">net.ipv4.tcp_orphan_retries</code> 는 따로 볼 필요가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">//https://github.com/torvalds/linux/blob/master/include/net/tcp.h#L141</span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">TCP_RTO_MAX</span>\t<span class=\"token expression\"><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token number\">120</span><span class=\"token operator\">*</span>HZ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">TCP_RTO_MIN</span>\t<span class=\"token expression\"><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>HZ<span class=\"token operator\">/</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></span></span>\n\n<span class=\"token comment\">//https://github.com/torvalds/linux/blob/master/net/ipv4/tcp_timer.c#L233</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">tcp_write_timeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">sock</span> <span class=\"token operator\">*</span>sk<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">sock_flag</span><span class=\"token punctuation\">(</span>sk<span class=\"token punctuation\">,</span> SOCK_DEAD<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t\t<span class=\"token keyword\">const</span> bool alive <span class=\"token operator\">=</span> icsk<span class=\"token operator\">-></span>icsk_rto <span class=\"token operator\">&lt;</span> TCP_RTO_MAX<span class=\"token punctuation\">;</span>\n\t\tretry_until <span class=\"token operator\">=</span> <span class=\"token function\">tcp_orphan_retries</span><span class=\"token punctuation\">(</span>sk<span class=\"token punctuation\">,</span> alive<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token comment\">//https://github.com/torvalds/linux/blob/master/net/ipv4/tcp_timer.c#L146</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">tcp_orphan_retries</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">sock</span> <span class=\"token operator\">*</span>sk<span class=\"token punctuation\">,</span> bool alive<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">int</span> retries <span class=\"token operator\">=</span> <span class=\"token function\">READ_ONCE</span><span class=\"token punctuation\">(</span><span class=\"token function\">sock_net</span><span class=\"token punctuation\">(</span>sk<span class=\"token punctuation\">)</span><span class=\"token operator\">-></span>ipv4<span class=\"token punctuation\">.</span>sysctl_tcp_orphan_retries<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* May be zero. */</span>\n\n\t<span class=\"token comment\">/* We know from an ICMP that something is wrong. */</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">READ_ONCE</span><span class=\"token punctuation\">(</span>sk<span class=\"token operator\">-></span>sk_err_soft<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>alive<span class=\"token punctuation\">)</span>\n\t\tretries <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\">/* However, if socket sent something recently, select some safe\n\t * number of retries. 8 corresponds to >100 seconds with minimal\n\t * RTO of 200msec. */</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>retries <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> alive<span class=\"token punctuation\">)</span>\n\t\tretries <span class=\"token operator\">=</span> <span class=\"token number\">8</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> retries<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">tcp_orphan_retries()</code> 함수가 실제 <code class=\"language-text\">FIN_WAIT1</code> 재처리 시 호출되는 함수 이다. 이 중에서 <code class=\"language-text\">retries == 0 &amp;&amp; alive</code> 조건이 중요한데, <code class=\"language-text\">alive</code> 는 최근에 데이터 전송 유무인데 이 값이 1이라면 0으로 설정되어있더라도 8번 재시도를 하게된다.\n<code class=\"language-text\">tcp_write_timout()</code> 함수를 보면, <code class=\"language-text\">alive</code> 값을 구하는 부분이 나오는데 <code class=\"language-text\">TCP_RTO_MAX</code> 보다 작을 경우 <code class=\"language-text\">true</code> 로 선언되는 것으로 볼 수 있다.</p>\n<p>참고로 <code class=\"language-text\">TCP_RTO_MAX</code> 는 120초이고, <code class=\"language-text\">TCP_RTO_MIN</code>은 1초(1000ms) / 5이므로 200ms이다.</p>\n<p>이러한 값들을 토대로 어플리케이션의 타임아웃을 설정해야된다.</p>\n<p>만약, 초기 연결 수립 과정 시에 어플리케이션 타임아웃을 1초 이내로 해두면 <code class=\"language-text\">InitRTO</code> 보다 작은 값이 될 것이고, 패킷 유실이 발생하면 타임아웃 문제가 발생할 것이다.\n연결 수립 이후에도 <code class=\"language-text\">TCP_RTO_MIN</code> 보다 타임아웃을 낮게 설정해두면 이 또한, 재전송 매커니즘을 제대로 활용할 수 없을 것이다.</p>\n<p>따라서, 모니터링 도구 등을 확인하여 평균적인 요청/응답 속도와 해당 커널 파라미터들의 값을 고려해서 설정을 해야 TCP 재전송 매커니즘을 제대로 활용할 수 있을 것이다.</p>\n<h2 id=\"step-4--결론\" style=\"position:relative;\"><a href=\"#step-4--%EA%B2%B0%EB%A1%A0\" aria-label=\"step 4  결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 4.  결론</h2>\n<p>원래는 포스팅을 2개로 나눠서 작성을 하고자 했으나 귀차니즘에 의해서 계속 작성하다보니 매우 장문의 포스팅이 되버렸다.\n이 점 너른 양해 부탁드린다.</p>\n<p>이 포스팅에서 다룬 내용은 아래와 같다.</p>\n<ol>\n<li>소켓이 무엇인지와 소켓의 종류</li>\n<li>커널 코드 분석을 통한 실제 소켓 생성 매커니즘</li>\n<li>커널 코드 분석을 통한 TCP 소켓의 연결 수립/해제 과정</li>\n<li>커널 코드 분석을 통한 TCP 소켓의 메시지 송/수신 과정</li>\n<li>TCP를 사용하면서 겪을 수 있는 다양한 문제들과 TCP 관련 커널 파라미터들</li>\n</ol>\n<p>이러한 기저지식을 통해서 실제 서비스에서 겪고 있는 문제점이나 TCP와 소켓에 대한 호기심이 해결되었길 바란다.</p>\n<h2 id=\"레퍼런스\" style=\"position:relative;\"><a href=\"#%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4\" aria-label=\"레퍼런스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>레퍼런스</h2>\n<ol>\n<li><a href=\"https://www.beej.us/guide/bgnet/\">https://www.beej.us/guide/bgnet/</a></li>\n<li><a href=\"https://linux-kernel-labs.github.io/refs/heads/master/labs/networking.html\">https://linux-kernel-labs.github.io/refs/heads/master/labs/networking.html</a></li>\n<li><a href=\"http://www.haifux.org/lectures/217/netLec5.pdf\">http://www.haifux.org/lectures/217/netLec5.pdf</a></li>\n<li><a href=\"https://cs3157.github.io/www/2022-9/lecture-notes/13-tcp-ip.pdf\">https://cs3157.github.io/www/2022-9/lecture-notes/13-tcp-ip.pdf</a></li>\n<li><a href=\"https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp2\">https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html#tth_chAp2</a></li>\n<li><a href=\"https://os.korea.ac.kr/wp-content/uploads/2020/11/10_TCP-in-Linux.pdf\">https://os.korea.ac.kr/wp-content/uploads/2020/11/10_TCP-in-Linux.pdf</a></li>\n<li><a href=\"https://d2.naver.com/helloworld/47667\">https://d2.naver.com/helloworld/47667</a></li>\n<li><a href=\"https://tech.kakao.com/2016/04/21/closewait-timewait/\">https://tech.kakao.com/2016/04/21/closewait-timewait/</a></li>\n<li><a href=\"https://jungseob86.tistory.com/12\">https://jungseob86.tistory.com/12</a></li>\n</ol>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\"><a href=\"https://en.wikipedia.org/wiki/Everything_is_a_file\">https://en.wikipedia.org/wiki/Everything_is_a_file</a><a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-3\"><a href=\"https://github.com/torvalds/linux/blob/master/include/linux/net.h#L64\">https://github.com/torvalds/linux/blob/master/include/linux/net.h#L64</a><a href=\"#fnref-3\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\"><a href=\"https://en.wikipedia.org/wiki/Network_socket#Types\">https://en.wikipedia.org/wiki/Network_socket#Types</a><a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-4\"><a href=\"https://github.com/torvalds/linux/blob/master/include/linux/net.h#L117\">https://github.com/torvalds/linux/blob/master/include/linux/net.h#L117</a><a href=\"#fnref-4\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-5\"><a href=\"https://github.com/torvalds/linux/blob/master/include/linux/tcp.h#L177\">https://github.com/torvalds/linux/blob/master/include/linux/tcp.h#L177</a><a href=\"#fnref-5\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-6\"><a href=\"https://github.com/torvalds/linux/blob/master/net/ipv4/tcp.c#L412\">https://github.com/torvalds/linux/blob/master/net/ipv4/tcp.c#L412</a><a href=\"#fnref-6\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-7\"><a href=\"https://github.com/torvalds/linux/blob/master/net/socket.c#L2144\">https://github.com/torvalds/linux/blob/master/net/socket.c#L2144</a><a href=\"#fnref-7\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-8\"><a href=\"https://github.com/torvalds/linux/blob/master/net/socket.c#L748\">https://github.com/torvalds/linux/blob/master/net/socket.c#L748</a><a href=\"#fnref-8\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-9\"><a href=\"https://github.com/torvalds/linux/blob/master/net/ipv4/af_inet.c#L833\">https://github.com/torvalds/linux/blob/master/net/ipv4/af_inet.c#L833</a><a href=\"#fnref-9\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-10\"><a href=\"https://github.com/torvalds/linux/blob/master/net/ipv4/tcp.c#L1331\">https://github.com/torvalds/linux/blob/master/net/ipv4/tcp.c#L1331</a><a href=\"#fnref-10\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-11\"><a href=\"https://github.com/torvalds/linux/blob/master/net/ipv4/tcp_output.c#L2658\">https://github.com/torvalds/linux/blob/master/net/ipv4/tcp_output.c#L2658</a><a href=\"#fnref-11\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-12\"><a href=\"https://github.com/torvalds/linux/blob/master/net/ipv4/tcp_output.c#L1244\">https://github.com/torvalds/linux/blob/master/net/ipv4/tcp_output.c#L1244</a><a href=\"#fnref-12\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-13\"><a href=\"https://github.com/torvalds/linux/blob/master/net/ipv4/tcp.c#L2551\">https://github.com/torvalds/linux/blob/master/net/ipv4/tcp.c#L2551</a><a href=\"#fnref-13\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-14\"><a href=\"https://brunch.co.kr/@alden/15\">https://brunch.co.kr/@alden/15</a><a href=\"#fnref-14\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-15\"><a href=\"https://en.wikipedia.org/wiki/HTTP_persistent_connection#HTTP_1.1\">https://en.wikipedia.org/wiki/HTTP_persistent_connection#HTTP_1.1</a><a href=\"#fnref-15\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-16\"><a href=\"https://elixir.bootlin.com/linux/latest/source/include/net/sock.h#L1271\">https://elixir.bootlin.com/linux/latest/source/include/net/sock.h#L1271</a><a href=\"#fnref-16\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-17\"><a href=\"https://docs.bluecatnetworks.com/r/DNS-Edge-Deployment-Guide/How-DSR-load-balancing-works\">https://docs.bluecatnetworks.com/r/DNS-Edge-Deployment-Guide/How-DSR-load-balancing-works</a><a href=\"#fnref-17\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-18\"><a href=\"https://en.wikipedia.org/wiki/Exponential_backoff\">https://en.wikipedia.org/wiki/Exponential_backoff</a><a href=\"#fnref-18\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>","frontmatter":{"date":"October 12, 2023","title":"[Kernel] 커널과 함께 알아보는 소켓과 TCP Deep Dive","categories":"개발 인프라 독서요약","author":"개발한입","emoji":"💻"},"fields":{"slug":"/linux-kernel-internal-3/"}},"site":{"siteMetadata":{"siteUrl":"https://brewagebear.github.io","comments":{"utterances":{"repo":"brewagebear/blog-comments"}}}}},"pageContext":{"slug":"/linux-kernel-internal-2/","nextSlug":"/linux-kernel-internal-1/","prevSlug":"/linux-kernel-internal-3/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}