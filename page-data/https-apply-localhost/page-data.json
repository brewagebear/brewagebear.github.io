{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/https-apply-localhost/",
    "result": {"data":{"cur":{"id":"fb3adfe3-bbf4-58e7-8f02-a9ecca8de581","html":"<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#step-1-https%EB%9E%80\">STEP 1. HTTPS란?</a></p>\n<ul>\n<li><a href=\"#step-11-https-handshake\">STEP 1.1 HTTPS Handshake</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-2-%EB%A1%9C%EC%BB%AC%ED%98%B8%EC%8A%A4%ED%8A%B8-%ED%99%98%EA%B2%BD%EC%97%90-https-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0\">STEP 2. 로컬호스트 환경에 HTTPS 적용하기</a></p>\n<ul>\n<li><a href=\"#step-21-minica%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%A1%9C%EC%BB%AC%ED%98%B8%EC%8A%A4%ED%8A%B8-ca-%EC%9D%B8%EC%A6%9D%EC%84%9C-%EB%B0%9C%EA%B8%89\">STEP 2.1 minica를 이용한 로컬호스트 CA 인증서 발급</a></li>\n<li><a href=\"#step-22-openssl-%EB%B0%8F-keytool%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-p12-jks%EC%9D%B8%EC%A6%9D%EC%84%9C-%EB%B0%9C%EA%B8%89\">STEP 2.2 openssl 및 keytool을 이용한 p12, jks인증서 발급</a></li>\n<li><a href=\"#step-23-%EB%A1%9C%EC%BB%AC%ED%98%B8%EC%8A%A4%ED%8A%B8-%ED%99%98%EA%B2%BD-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8%EC%97%90-https-%EC%A0%81%EC%9A%A9-%ED%99%95%EC%9D%B8\">STEP 2.3 로컬호스트 환경 스프링부트에 HTTPS 적용 확인</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-3-reference\">STEP 3. REFERENCE</a></p>\n</li>\n</ul>\n</div>\n<h1 id=\"개요\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EC%9A%94\" aria-label=\"개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개요</h1>\n<p>나중에 포스팅해야지 하고 넘어갔던 부분인데 이번에 다른 분께서 질문을 올려주셨어서 포스팅을 해보고자 한다.</p>\n<p>제목과 같이 <code class=\"language-text\">MacOS</code> 환경에서 HTTPS를 적용하는 것이 주된 목표이고, 확인 절차는 간단하게 스프링 부트를 통해서 작업하였다.</p>\n<h1 id=\"macos에서-로컬-개발환경에-https-적용하기\" style=\"position:relative;\"><a href=\"#macos%EC%97%90%EC%84%9C-%EB%A1%9C%EC%BB%AC-%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD%EC%97%90-https-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"macos에서 로컬 개발환경에 https 적용하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MacOS에서 로컬 개발환경에 HTTPS 적용하기</h1>\n<ul>\n<li>STEP 1. HTTPS란?\n<ul>\n<li>STEP 1.1 HTTPS Handshake</li>\n</ul>\n</li>\n<li>STEP 2. 로컬호스트 환경에 HTTPS 적용하기\n<ul>\n<li>STEP 2.1 minica를 이용한 로컬호스트 CA 인증서 발급</li>\n<li>STEP 2.2 openssl 및 keytool을 이용한 p12, jks인증서 발급</li>\n<li>STEP 2.3 로컬호스트 환경 스프링부트에 HTTPS 적용 확인</li>\n</ul>\n</li>\n<li>STEP 3. REFERENCE</li>\n</ul>\n<h2 id=\"step-1-https란\" style=\"position:relative;\"><a href=\"#step-1-https%EB%9E%80\" aria-label=\"step 1 https란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1. HTTPS란?</h2>\n<p>먼저 적용하기 앞서 HTTPS에 대해서 짚고 넘어가는게 좋다고 생각한다.\n우리가 알고 있는 인터넷 프로토콜 스택(TCP/IP 4 Layer)는 다음과 같을 것이다.</p>\n<ul>\n<li>TCP/IP 4 Layer</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 70%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAADIElEQVQ4y31US2gkRRj+o4OPKLuy4GHZw4p6EPEm+GAVdT0IguxRRNA5OF68eNqTlz2IurDI1Mo+DouSJyEPEfM6JodAUJMMujMTk1mmOzNJ92R6ZtJd1d3VU93/L1WZ3b1ICj7+Kqr4+L6v/irwfd/t9/sh5zyQUvIoirgQwtQgCHgcx1xKeZQkCXmdzpUwVpDOvPc0MhhGBjlk8NhgDhqQJAkSEU1PT9PMzAyNjY3R7Owszc3N0fj4OC0uLlK1WtVHKAiTHwggh7dOvYsM3kQGLyKDl5HB28jgDDJ4FMIw/FMpVXFd926pVCpvb2+XDw4OyrVarWxZVrnZbJZ93/87TVO71zv6OiKC/j93cnTdKBrC6zD0YK4V1mq1fKPR+LLb7RaIyEApVciyrICIhTRNC47jfLG3t/fVv9vV19w/RoG+Obb3f4A4jmNtp91u0+bmJu3v71Oz2STHcajRaJBlWYSoU0EKRPSdIAK8c/Z5ZPAsMngKGZxHBmfpp4eEJh8pJS0vL5sMFxYWaHR0lKampmhlZcUQagQivuZpwtun30IGz2kiZPA+MnhhQD4EnuddFUIwIUQxTdOiUsrA9/1iv98vImKRc/4j5/y26zgfBY0toEsnWO52u79EUTTFOZ9M03Qyy7JJRJwkIgMhhMa4EOFvrZb7Cd/7C+jCyRnS/bG+vk5LS0umrq2tGeuu65q9LEspiNKrBDCMt069M7D8EjLQ9s8Rg0dIE0opgwEf7uzs4NbWFpZKJaxUKri6uoqcc30j6jjD6FvdNvjz+XODS3lGkyGD07oHjcLd3d1PbdvO27b9eZIkeSllPo7jvBAiT0R5x3Hy9Xr9M9u2C9XK3VfdtRtAV06wLIQoZ1lmSynr7XbbCsPQQCllcc6tKIqsLMvuKaU6vaOjy1ph+vulJwcEufsYNLex/KBtRkZGaGJiwtT5+Xnz9DY2No7zwIy4xO9NhjeHP0YGryCD15HBh8jgIjJ4Q79p8H2/nCSJUdjpdOqHh4f1Vqtl4Hlevdfr1ZMkuRfHsed1OpcDIlC/fqA/g8cHuT0xUKnXuf8AW5sP+//e3iAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"TCP/IP 4 Layer\"\n        title=\"TCP/IP 4 Layer\"\n        src=\"/static/46cfe00e3d12e51a43b6448d96851462/37523/164E0923-B724-4FB3-9DDD-AE61B17206B8.png\"\n        srcset=\"/static/46cfe00e3d12e51a43b6448d96851462/e9ff0/164E0923-B724-4FB3-9DDD-AE61B17206B8.png 180w,\n/static/46cfe00e3d12e51a43b6448d96851462/f21e7/164E0923-B724-4FB3-9DDD-AE61B17206B8.png 360w,\n/static/46cfe00e3d12e51a43b6448d96851462/37523/164E0923-B724-4FB3-9DDD-AE61B17206B8.png 720w,\n/static/46cfe00e3d12e51a43b6448d96851462/d9217/164E0923-B724-4FB3-9DDD-AE61B17206B8.png 904w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>위의 구조와 <code class=\"language-text\">HTTPS</code> 와 무슨 상관이길래 갑자기 TCP/IP 4 Layer 얘기를 하였을까?HTTPS의 약어 부터 한번 확인해보자.</p>\n<blockquote>\n<p>HyperText Transfer Protocol over Secure Socket Layer, HTTP over TLS, HTTP over SSL, HTTP Secure</p>\n</blockquote>\n<p>약어는 매우 다양하지만, 내가 TCP/IP 4 Layer를 예시를 든 이유와 적합한 약어는 <strong>HTTP over TLS, HTTP over SSL</strong> 의 약어라고 볼 수 있다.</p>\n<p>즉, HTTP가 TLS 혹은 SSL 위에서 작동한다는 것이다.</p>\n<p>위의 계층표를 보면 응용계층(Application Layer)에 <code class=\"language-text\">HTTP</code> 라고 명시한 것을 볼 수 있다. 따라서 그냥 간단하게 밑에 <strong>TLS</strong> 혹은 <strong>SSL</strong> 계층이 추가된 버전이라고 볼 수 있다.</p>\n<ul>\n<li>HTTPS Layer</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 524px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 152.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAYAAAAsEj5rAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFNklEQVRIx5WV70tbVxjHT1zfdL7cfddCC4XB8np/gOw/GNuLDsZwQpGVskk6ViqzVCsriQmOdpWuiZhoA9KBIWW+cJ047EybqB3mh00UbGJrm5iY3Jsf99f58YxzkptG52A78OE8z3Oe73PPvefcc1ChUNjWdb2uqqqsqqpCKVV0XRcYhqGYpimwYnycx61xTdMUrrNA1Wq1CB1ta2sLDMNos7e3B4VCAQghgDGGXC4HpVIJKKWgqiowxjrlgGRZft0Kkp2dHdrX10fHx8ep0+mko6Oj9ObNm3RgYIDOzc3Ry5cvU4fDIeJut5uOjY3RWCxGAYASQihjjCJFUUpW9VevXokZTs/MQCgUgtnZWUilUrC0tARra2uwsLAAT548gWg0BsvLy7C5uQn5fP7wDPP7xW3NMOt1VZNNQhUKoBAKCmFNGIACACLOe8u3YgYmSkPTFVU3RI8gcuc9eO6T4PmkBGu3JFh2SvDHiARLwxIsXpPgtyEJHg1LsDAowdwlCX6/LsGjaxLMfyfBny4J1m83tSmvBCmfhNAU/Iim4Fc0BXNoCkKC+xBCMxBCQQih6VaM27MQQoFW7H4rfhRbgGVtAQZtpgFsP+2DbaIEtluvwXav1oxz25UBm1cF289VsN0uNHM7tQEGCPnhLxQAQH5mogBgwee3MPrMg9Enoxj1eTEaf4lRnw+jj4cx+n4Fo28XMPr0B4z8tJnvZ7itRYEjBacBo6/nmgUu+DH64g5GFwIYuXcwur6K0TdhjC79gtGX9zCaNJr5nQXfCbBc1zSDtwB0zQB0BQG67rd6K2YRYG/jgU4tf2UPfIjc8BFyQ0+bMdqDXLgHuUiz90DLJj3IzZq+02zanTqOtrvZC9W9r0B+2d+mkuuHgxf9UNrph1KrP+S/6IfiTjNP6dDJL/tRuSJr/N/BlLX5P62peavn//IeH6CUYj6ey+Ww0+nET58+xclkEicSCfzs2TO8tbUl/FQqhdPpNJ6fn8eZTEZoLC3HKsgYYyJQr9dxMBjEd+/exefPn8cejwcPDw9jh8OBBwYG8MjICL5x44Z4aDQaFRpCyKGCOjQrCvixpGmaOLr4YVGv16HRaEA2mxWHQa1Wg0qlIo4zHu/UctDu7q5HluXJcrl8r1wueyuVirdarXoVRfEahuGt1WoCXde9pml66/W6t9FoeGVZFnFLY4Gi0ej7qVTKnkgkPkgkEry3r6+v26PRqP3x48f2SCRij8Viouc+t1dWVuyrq6v2jY0NezKZtFs6DioWixXTNEHX9Tbc56/O4a/BT2r+itznYzzG/U6NBb8C3rR2AN89fM+wg4MDlsvlWD6fZ9lslqmqysrlMtvf32emaYqxYrHIrPxOxBVgbRvCHwtAUqkUuXLlCvF4POTixYvk6tWrxOVyCQYHB0UsEomIXN4YY234DOWjm5Wv3vb2tljleDwOyWRSXFaWz68JvtLHNVQoFFZ0Xd9WVfW5qqppjmEYacZYmhCSBgABty2fj/EcnqtpWtrScdC5c+fePXXqVPfp06e7eX/27NluhNA/OHHiRLfNZmv7J0+e7D5z5ky3pbXgM1zSdT2pquqGqqrxRqMRxxjHTdMUtq7rcR6v1Wpxa9wwDGEfB79Gq0e/Q7lcBkVRhM23yXHf+N9ae5X5CmGMxcr5/X7S29tLJiYmyNDQEPH5fGLFg8EgmZycJA6Hg4TDYZFLKT28yrIs51sFGd+4vGUyGfD7/YJwOCzw+Xzw8OFDePDggbjwFxcXD/3HnTNsF7QS/ms7LvdvNVt1wjZn/fkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"HTTPS Layer\"\n        title=\"HTTPS Layer\"\n        src=\"/static/2270c7bc8a07df8ffba2d911ae78a1cf/664c8/B16D55A5-5910-438F-9720-01866F510928.png\"\n        srcset=\"/static/2270c7bc8a07df8ffba2d911ae78a1cf/e9ff0/B16D55A5-5910-438F-9720-01866F510928.png 180w,\n/static/2270c7bc8a07df8ffba2d911ae78a1cf/f21e7/B16D55A5-5910-438F-9720-01866F510928.png 360w,\n/static/2270c7bc8a07df8ffba2d911ae78a1cf/664c8/B16D55A5-5910-438F-9720-01866F510928.png 524w\"\n        sizes=\"(max-width: 524px) 100vw, 524px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>이런 구조가 HTTPS의 계층 구조라고 볼 수 있을 것이다.</p>\n<p>그렇다면 SSL 혹은 TLS는 무엇일까?</p>\n<p>TLS(Transport Layer Security)는 SSL(Secure Socket Layer)의 문제점을 고쳐서 보다 개선된 버전이라고 볼 수 있다.</p>\n<p>SSL은 <code class=\"language-text\">POODLE</code> <sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup> 혹은 <code class=\"language-text\">DROWN</code> <sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup> 등의 취약점이 발생해서 쓰진않고 <strong>TLS</strong> 가 표준이나 <code class=\"language-text\">openSSL</code> 과 같은 오픈소스 프로젝트를 보면 알 수 있듯이 <strong>SSL</strong> 라는 말이 계속 쓰이고 있는 상황이다.</p>\n<p>즉, 오늘날의 HTTPS는 <strong>모두 TLS로 동작</strong>한다고 생각하면 된다. 그렇다면 이런 부분이 궁금해질 수 있다고 생각한다.</p>\n<blockquote>\n<p><strong>TLS</strong> 는 <strong>HTTP</strong> 랑만 사용하나요??</p>\n</blockquote>\n<p>아니다. 다른 프로토콜이랑도 병합해서 사용된다.</p>\n<p>대표적으로 FTPS(File Transport protocol over SSL)과 같은게 있다.</p>\n<ul>\n<li>참고 : SFTP는 ssh를 사용하므로 엄밀히 따졌을때 TLS를 사용하지는 않는다.</li>\n</ul>\n<p>만약, FTPS와 SFTP의 차이가 궁금하다면 <a href=\"https://nhj12311.tistory.com/76\">ftp, ftps, sftp(ssh) 개념 정리</a>를 참고해보자.</p>\n<p>지금까지 HTTPS 스택에 대해서 알아봤다.</p>\n<p>그렇다면 네트워크에서 3way-handshake 나 4way-handshake가 있듯이 HTTPS에도 서버 &#x3C;-> 클라이언트간의 연결수립 및 해제 방법이 존재할 것이다.</p>\n<p>이것을 HTTPS Handshake라 부른다.</p>\n<h3 id=\"step-11-https-handshake\" style=\"position:relative;\"><a href=\"#step-11-https-handshake\" aria-label=\"step 11 https handshake permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.1 HTTPS Handshake</h3>\n<ul>\n<li>HTTPS Handshake</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC8ElEQVQozyXPf0zUdRzH8efnOKCW8yp/ZFLHkdMWbviLZA2cR9jIGAo0t7L1h2trbqlbG2yYzAADAo7j7vs9yGrHnL8TkWI1/3BOp85ReHy/d/c9JFo/xiq0NpxLDO+O77tBr+2x115/vjCKW1XvB3uUIBzYV+nMG3Se83yeMe45nTHh/iarhu9BDqI4K0sJz13M9P0YJ/woxikpePvbWeSvCHeO3cDc0ka8MgiRDY3Ey/2MFrfww4Z+5LEDGF+oleOfqbzbvWqRaHhEI/dfPds11L7b9fd35N3YeKTZLOuMje3quZ6oCV03ve3mSP6hd0bWNsDI2gaX6W133Vr/sSu29fBT15jMki6WisaLorHc1nHbGm7ReFZ8PCfHWWdubq2Lv9E9bO3ULiWq9UvxisBwZFPTW0ZxK0S3dYpVrUu8MihWlSajW3zm/UPkpnvZmAo4ckRjva2xydbxzOqZK1JaZkFq7z6mzxpMX7nN/Zs/cffMMLHX/YzvCUO0tKM2UROqS7zZUzu2K/RRpMi/O3mEFdLDCylftlN0skRnvrNtnSdsjTVSDyKT6uH4n2rG+l3duzym4hUBNfpyM/x6eJCp8DXunrzJ1IkYf9Q3IEfV07bOIgmAreOwNRxSBNK9sHPu+d1q4t1yaoG9/J/3gNN4IFrWKfO3Y+VdC8zSoDGzn+USIt/ucuTaOkXzRKNA/ORIgKLUV4qZqzDpG+af0Z8RkQUPJ6bAKGltMr2fNpulHY3m1k86rIq6g4/61Jr0SV6aHXI8KftR0w8g1c/jyQFy0n2UzAy5lojgiL7aedzaEfzNqtJjVrWesHYEE5jedqJlPuLbOxgp7OMMQvoEq9J95CeHcCUHyUt+zerkAM+kzrFsLkzhg4HFi0VQt9Y1tkQKmy5Gt/nOGyVtFyKFzRcwXmlxGiVtTtPb4hx77cNMuQPiZ6UE2SzdLLOPsmruS1bbPbilm+clSHHyVAYiYJb6sKo0fqnvZ+L9YyRqQvwHX5h0PL6umLkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"HTTPS Handshake\"\n        title=\"HTTPS Handshake\"\n        src=\"/static/a69e31a318bb0217d5ef77dbf7b89049/37523/017528D9-24B7-496A-A478-91B7C110917D.png\"\n        srcset=\"/static/a69e31a318bb0217d5ef77dbf7b89049/e9ff0/017528D9-24B7-496A-A478-91B7C110917D.png 180w,\n/static/a69e31a318bb0217d5ef77dbf7b89049/f21e7/017528D9-24B7-496A-A478-91B7C110917D.png 360w,\n/static/a69e31a318bb0217d5ef77dbf7b89049/37523/017528D9-24B7-496A-A478-91B7C110917D.png 720w,\n/static/a69e31a318bb0217d5ef77dbf7b89049/302a4/017528D9-24B7-496A-A478-91B7C110917D.png 1080w,\n/static/a69e31a318bb0217d5ef77dbf7b89049/07a9c/017528D9-24B7-496A-A478-91B7C110917D.png 1440w,\n/static/a69e31a318bb0217d5ef77dbf7b89049/30a3b/017528D9-24B7-496A-A478-91B7C110917D.png 3254w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>과정은 위의 그림과 같은데 이를 좀 더 풀어내면 다음과 같다.</p>\n<ol>\n<li>\n<p><strong>Client Hello</strong> :  서버에게 지원되는 TLS버전(Client Version)과 암호 알고리즘(Cipher Suites) 그리고 클라이언트 무작위(Client Random) 값을 보낸다.</p>\n</li>\n<li>\n<p><strong>Server Hello</strong> : 서버는 지원하는 TLS버전(Server Version)과 암호 알고리즘(Cipher Suites) 그리고 서버 공개키(Server Certificate)를 보낸다.</p>\n</li>\n<li>\n<p><strong>Key Exchange</strong> : 클라이언트는 전달 받은 서버 무작위 값과, 공개키를 통해서 <code class=\"language-text\">Premaster Secret</code> 을 생성하여 서버에 전달한다. 이때, 서버가 전달받으면 서버의 개인키를 통해서 복호화 한 뒤에 서버 랜덤값과 클라이언트 랜덤값을 토대로 <code class=\"language-text\">Master Secret</code> 을 만든다.</p>\n</li>\n<li>\n<p><strong>Established</strong> : <strong>Key Exchange</strong> 과정 속에서 Client는 <code class=\"language-text\">Premaster Secret</code> 을 생성할 때 세션 키를 만들어두고, Server는 <code class=\"language-text\">Master Secret</code> 을 만들면서 세션 키를 만들어 둔다. 이렇게 생성된 세션 키가 안전하게 공유되었으므로 이 세션 키를 이용해 서버와 클라이언트는 대칭키 방식으로 암호화 방식으로 데이터를 주고 받게 된다.</p>\n</li>\n</ol>\n<p>사실 위 내용은 아주 간단하게 HTTPS Handshake를 요약해둔 것이다.</p>\n<p><code class=\"language-text\">Server Hello</code> 단계에서도 내부적으로 세분화 된 단계들이 존재하나 이 부분이 궁금하다면 <a href=\"https://www.acunetix.com/blog/articles/establishing-tls-ssl-connection-part-5/\">TLS Security 5: Establishing a TLS Connection | Acunetix</a> 여기를 참고하자.</p>\n<p>위의 아티클은 시리즈 글인데 1~6까지 매우 내용이 좋았다.</p>\n<p>SSL/TLS의 역사 요약은 <a href=\"https://www.acunetix.com/blog/articles/history-of-tls-ssl-part-2/\">A Brief History of SSL/TLS</a>를 참고할 수 있으며, 위에서 언급한 취약점에 대응 방안은 <a href=\"https://www.acunetix.com/blog/articles/tls-vulnerabilities-attacks-final-part/\">Examples of TLS Vulnerabilities and Attacks</a>을 참고해보자.</p>\n<p>HTTPS는 위와 같이 <strong>연결 수립과정에서는 비대칭키를 활용</strong>하여 세션 키를 만든 후에 연결 수립이 완료된 후에는 이 <strong>세션 키를 대칭키 암호화 형식</strong>으로 주고 받는 식으로 보안성을 높였다.</p>\n<p>대략적으로 HTTPS에 알게되었으니 이제 진짜로 우리 로컬 서버에 HTTPS를 적용해보도록 하자.</p>\n<hr>\n<h2 id=\"step-2-로컬호스트-환경에-https-적용하기\" style=\"position:relative;\"><a href=\"#step-2-%EB%A1%9C%EC%BB%AC%ED%98%B8%EC%8A%A4%ED%8A%B8-%ED%99%98%EA%B2%BD%EC%97%90-https-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"step 2 로컬호스트 환경에 https 적용하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2. 로컬호스트 환경에 HTTPS 적용하기</h2>\n<p>일단 개요에서 말한 것과 같이 <code class=\"language-text\">MacOS</code> 환경에서 진행되는 것이기 때문에 <code class=\"language-text\">Windows</code> 나 <code class=\"language-text\">Linux</code> 는 아마 추가적인 작업이 필요할 것으로 보인다.</p>\n<p>먼저, 우리가 사용할 인증서부터 발급해보자.</p>\n<h3 id=\"step-21-minica를-이용한-로컬호스트-ca-인증서-발급\" style=\"position:relative;\"><a href=\"#step-21-minica%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%A1%9C%EC%BB%AC%ED%98%B8%EC%8A%A4%ED%8A%B8-ca-%EC%9D%B8%EC%A6%9D%EC%84%9C-%EB%B0%9C%EA%B8%89\" aria-label=\"step 21 minica를 이용한 로컬호스트 ca 인증서 발급 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.1 minica를 이용한 로컬호스트 CA 인증서 발급</h3>\n<p>사설 인증서를 제작하는 방식은 여러가지가 있었지만 <a href=\"https://letsencrypt.org/\">Let’s Encrypt</a> 가 나오고서는 매우 쉬워졌다. 하지만, Let’s Encrypt 또한 <code class=\"language-text\">localhost</code> 환경의 인증서를 만드는건 좀 까다로운 일이다.</p>\n<p><a href=\"https://letsencrypt.org/docs/certificates-for-localhost/\">Certificates for localhost -  Let’s Encrypt</a> 이 아티클을 통해서 만들 수 있으나 생각보다 귀찮은 작업이다.</p>\n<p>그러던 와중에 <a href=\"https://yongbin.kim/2019/12/02/https-for-localhost-with-minica.html\">Minica로 Localhost를 위한 인증서 만들기</a> 이 블로그를 보고 <code class=\"language-text\">minica</code> 를 통해서 작업을 하는 것이 훨씬 수월하겠구나 느꼈고, 사용해보니까 정말 편했다.</p>\n<p>이제 설치부터 실제 인증서 방법까지 진행해보고자 한다.</p>\n<ol>\n<li>\n<p>minica 설치</p>\n<ul>\n<li><code class=\"language-text\">brew install minica</code> 명령어를 통해서 설치한다.</li>\n<li>윈도우나 리눅스 환경은 <a href=\"https://github.com/jsha/minica\">GitHub - jsha/minica</a> 여기서 문서를 확인해보자.</li>\n</ul>\n</li>\n<li>\n<p>minica로 <code class=\"language-text\">localhost</code> 인증서 발급</p>\n<ul>\n<li>명령어 : <code class=\"language-text\">minica -domains www.localhost,localhost -ip-addresses 127.0.0.1</code></li>\n</ul>\n</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 549px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 20%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA50lEQVQY0zVPW1KDQBDkMhpDIFryhjVClmUTwmMJEEmCVvzw/kdo3VE/prq7qqenx1jzAFaewfYYeN4gYgXiv9mkJdhmhygRxIMox7P7inRbkU5eJMIoR8wk+e8fXBil6sFFC8/PcLdwYFohlqsAKzvCYukRaq3HfkxIa4/Gf25av/71E4Mhig4Jk3D8lBqU1Yh+fMfb+ZOuqu6CMBbgosFpukHuexzqE3nU8Yq6ndANM6pmgh9yGI2aqLrjpfCCLfrxA4064zjMFKSXXT+DkIpC9Dd5oVDVI2Q3I2uv2F++wIcbzJ+G35RijP+oFlQ1AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"result-command\"\n        title=\"result-command\"\n        src=\"/static/5aa2e85de62b019616619d71568fb944/928ea/1.png\"\n        srcset=\"/static/5aa2e85de62b019616619d71568fb944/e9ff0/1.png 180w,\n/static/5aa2e85de62b019616619d71568fb944/f21e7/1.png 360w,\n/static/5aa2e85de62b019616619d71568fb944/928ea/1.png 549w\"\n        sizes=\"(max-width: 549px) 100vw, 549px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>그러면 위와 같이 <code class=\"language-text\">.pem</code> 파일들이 생성된 것을 확인할 수 있다. 매우 간단하게 CA인증서<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup>를 만든 것이다.</p>\n<p>만약, 톰캣에 HTTPS를 적용하는 것이 아니라 웹 서버(Apache, Nginx…)에 적용하는 것이면 사실 여기서 끝내도 된다. 그러나, 이 <code class=\"language-text\">.pem</code> 파일을 스프링 부트 내장톰캣에 끼워서 띄워야하는데 톰캣은 <code class=\"language-text\">.jks(Java KeyStore)</code> 를 지원하기 때문에 변환 작업이 필요한 것이다.</p>\n<ul>\n<li>nginx.conf</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 631px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62.22222222222222%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABvElEQVQoz5WTWY/aMBSF+S8zZF/ITshCwhIIgUwZqFClwhS1L+3/f/+qGISYPqUPx77Xss8918ceGHaKYaUYZoJpp8hqgKQGyFqIooUiV+5xHwymTsUi2mL7Ba+vDpoZYRghiuL/F9GDUFUCktWR8vCBEy+Jk5K23jHPN7zIHq+Sy8vQuUHET/nQER08Y9ANdtrgVyfC3Qfe8oQTLUmyNeW8JU4q8qJhWm5Jspo0r8mmjVjrYt2MPyt0vAKvPBI0V4Gw/cVofiIp3ng//mCz+8b78crh65X2y5m3/YV2f+F8+cP3828W1QEvXDDyShx/xkAzYjpYowzLToUxljMVa7qVoluJME3RIiTFf+DWYoiiR58VCkI9wrIS7FGGeZ8NIxaxoo9R74eeHf/37h532G1W3QI9abDSHeZ4jT3Z4BYH7LgmjBao+rj38xnIqo/vV2Rxiz+u0YM5ip2jhSs0u1Mc31rrDvQgHXQPONAm7JufzKoT5epAOKkwzVgot9wcw4z7K+yqSrLLMJgjBQu0aE2YbwniJXraEqVrRm4mjOhFGGQ1ft7gByVRNMN1M4aSe3OyKyR74iv2/YZ/AZU7gY8ewWaLAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"nginx.conf\"\n        title=\"nginx.conf\"\n        src=\"/static/6840bcc699fdfc3b04973a93331b341e/4597d/2.png\"\n        srcset=\"/static/6840bcc699fdfc3b04973a93331b341e/e9ff0/2.png 180w,\n/static/6840bcc699fdfc3b04973a93331b341e/f21e7/2.png 360w,\n/static/6840bcc699fdfc3b04973a93331b341e/4597d/2.png 631w\"\n        sizes=\"(max-width: 631px) 100vw, 631px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>실제로 생성된 인증서를 통해서 nginx에 등록하면 아래의 화면을 볼 수 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.111111111111114%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABXklEQVQoz5WRSU7DQBBFfQsWSXDPbbunONhxBinZMUgsEByCs3Dqj1x2cCJFEBZP1Wp1//r1K3t5esZmvUHwCS4kaFOicgk+LOH8/8maVYOu7QaaNWJIkMpCKftT9Xi+hWxZN9jtD9juj+h2BzgfkTNJMCaxyCXu7jmd8xvIum6Httsi1Q0qnwjGFThXWDCJIDU+gsMiFxei/ZtrZG23w0PboSg9Kh8JxocPJKgMXmOEGMenKKRBnouJU4PeoZCaZufivNP0gEkD5RJiXNGiYuprDaUL2MLREvv/bBTNzvO6gCu67x3VdUNCIa5QuYgqNLBlhNaDYyHNJHg9i8khF5qclFUgrHXQuoDSFZT10DZAqoIyp5GHz9cYBbkiB4pEChqRsB6mTDBFhJD23OEfgkLDFIHqaQGnJcxnM9SbR7x/fmF9fMN8Nv9NcMqyd8DPoxjJmYAyDlXaQNlADb8BYmU+x/3q0AIAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"nginx-result\"\n        title=\"nginx-result\"\n        src=\"/static/d0a343c9c5a55118ca2c7aeec7e9b607/37523/3.png\"\n        srcset=\"/static/d0a343c9c5a55118ca2c7aeec7e9b607/e9ff0/3.png 180w,\n/static/d0a343c9c5a55118ca2c7aeec7e9b607/f21e7/3.png 360w,\n/static/d0a343c9c5a55118ca2c7aeec7e9b607/37523/3.png 720w,\n/static/d0a343c9c5a55118ca2c7aeec7e9b607/302a4/3.png 1080w,\n/static/d0a343c9c5a55118ca2c7aeec7e9b607/8d68c/3.png 1234w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>당연히 사설 인증서이므로, 발생하는 에러인데 이것도 예외를 추가함으로써 자물쇠를 띄울 수 있는데 이는 스프링에 적용한 후에 해보고자 한다.</p>\n<p>결론은 <code class=\"language-text\">.pem</code> 으로도 충분하지만 우리가 내장 톰캣에 띄우기 위해서는 <code class=\"language-text\">.jks</code> 파일이 필요하므로 변환한다고 알아두면 될 것 같다.</p>\n<h3 id=\"step-22-openssl-및-keytool을-이용한-p12-jks인증서-발급\" style=\"position:relative;\"><a href=\"#step-22-openssl-%EB%B0%8F-keytool%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-p12-jks%EC%9D%B8%EC%A6%9D%EC%84%9C-%EB%B0%9C%EA%B8%89\" aria-label=\"step 22 openssl 및 keytool을 이용한 p12 jks인증서 발급 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.2 openssl 및 keytool을 이용한 p12, jks인증서 발급</h3>\n<p>먼저 <code class=\"language-text\">.pem</code> 파일을 <code class=\"language-text\">.p12</code> 파일로 변환하고자 한다.</p>\n<ol>\n<li><code class=\"language-text\">.pem</code> 파일을  <code class=\"language-text\">.p12</code> 파일로 변환\n<ul>\n<li>아래의 명령어를 <code class=\"language-text\">minica.pem</code> 이 위치한 폴더에서 입력한다.</li>\n</ul>\n</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">openssl pkcs12 -export -in www.localhost/cert.pem -inkey www.localhost/key.pem -out [저장할 .p12 파일명] -name localhost -CAfile minica.pem -caname minica</code></pre></div>\n<p>위의 명령어를 입력했으면 해당 키의 패스워드를 입력해줘야한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 7.777777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAcElEQVQI1z2LSQqAMBAE8xg3EC/qQY1LjEbEJUFEBP3/O1oyooeimp4eNi0Htv1G263oB4OmnclCLqjFhIIPZOqVgew1bXOukBUKQs50s7msRjCzXVj1SU92GEY5HC+GF6SE6yfEm9PfX2+3ljcneAAtp0N8rnvbOAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"result-command\"\n        title=\"result-command\"\n        src=\"/static/f3c990b095de9ec1e42fb3f7f1b2ec12/37523/4.png\"\n        srcset=\"/static/f3c990b095de9ec1e42fb3f7f1b2ec12/e9ff0/4.png 180w,\n/static/f3c990b095de9ec1e42fb3f7f1b2ec12/f21e7/4.png 360w,\n/static/f3c990b095de9ec1e42fb3f7f1b2ec12/37523/4.png 720w,\n/static/f3c990b095de9ec1e42fb3f7f1b2ec12/5bf79/4.png 966w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>이를 마치면 <code class=\"language-text\">.p12</code> 파일이 생성됨을 확인할 수 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 557px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 20.555555555555554%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA1UlEQVQY002O2U6DQBSGeRltTdRYlkqrMEApYMo2bVpAWpELff83+MxMKunFn7P8yzmGIwSuSFiYPrMHh/u5fYUzzf/1bmZP/G1/OxubbUWc1LyuYp6e13jigyDKCTc5piV0bzkBSzciyaTmFaK45N3PEOFO+5VOZRiKVEt7GbKwfOS+5/z1o6G4phtx17EOuAy/1PKTvGyQhzNN+82pGWi7EXnoefNSjDippi9eTI+ybqlkR1G1+uKuOOljSnNsBrapRHnSTJLtLwRFR3oc8cue+eOKP2TRjQLXJPA7AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"result-command\"\n        title=\"result-command\"\n        src=\"/static/3979587ae5cf605e7c8231b0ca8dce51/30d00/5.png\"\n        srcset=\"/static/3979587ae5cf605e7c8231b0ca8dce51/e9ff0/5.png 180w,\n/static/3979587ae5cf605e7c8231b0ca8dce51/f21e7/5.png 360w,\n/static/3979587ae5cf605e7c8231b0ca8dce51/30d00/5.png 557w\"\n        sizes=\"(max-width: 557px) 100vw, 557px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>다음은 이제 <code class=\"language-text\">.p12</code> 파일을 <code class=\"language-text\">.jks</code> 로 변환하는 것이다.</p>\n<ol start=\"2\">\n<li><code class=\"language-text\">.p12</code> 파일을 <code class=\"language-text\">.jks</code> 파일로 변환</li>\n</ol>\n<ul>\n<li>아래의 명령어를 <code class=\"language-text\">minica.pem</code> 이 위치한 폴더에서 입력한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">keytool -importkeystore -deststorepass [.jks 파일에 적용할 키 스토어 비밀번호] -destkeypass [.jks 파일에 적용할 키 비밀번호] -destkeystore minica.jks -srckeystore certandkey.p12 -srcstoretype PKCS12 -srcstorepass \"[위의 .p12 파일을 만들때 입력했던 비밀번호]\" -alias localhost</code></pre></div>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 26.111111111111107%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA6UlEQVQY04WOyXKCUBBF+RmDySJRHkiwkMHHPDwBFRPNtMn/f8JJ8ZIqd3Fxq/t29z3VRlQqnLVk158ZX77Iih6Z7jiePlG7E+1wob98U+3fWVgBlghZioCFteFp6es6ecsOsVcxxrbtSMueujmSlwNp3lE1I1mhiGWJ6yVswlKHHhe+Dv4LlKlC2BHCiVg9Sz2cjrx1ivvnJ027+cOKmSmYmTZ386sm/zsXGLFscdwtdTtyGD9Iso4wrnWvule64cz+8EZeDBp4S4YfFPrdqjlq2NrPcT1JmvcEUUUgFZv6hJt0mPfOTeAPMOaquzym5ZkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"result-command\"\n        title=\"result-command\"\n        src=\"/static/12e435211739075287b2ec79e5440b92/37523/6.png\"\n        srcset=\"/static/12e435211739075287b2ec79e5440b92/e9ff0/6.png 180w,\n/static/12e435211739075287b2ec79e5440b92/f21e7/6.png 360w,\n/static/12e435211739075287b2ec79e5440b92/37523/6.png 720w,\n/static/12e435211739075287b2ec79e5440b92/d9199/6.png 960w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>위의 처럼 <code class=\"language-text\">.jks</code> 파일이 생성됐으면 성공적으로 생성된 것이다.</p>\n<p>변환 명령어 혹은 해당 명령어의 옵션들이 궁금하다면 아래를 참고해보자.</p>\n<ol>\n<li><a href=\"https://www.psjco.com/32\">SSL인증서, 재발급 없이 형식 바꾸기 PEM to JKS</a></li>\n<li><a href=\"https://www.lesstif.com/java/java-keytool-keystore-20775436.html\">java keytool 사용법 - Keystore 생성, 키쌍 생성, 인증서 등록 및 관리</a></li>\n</ol>\n<hr>\n<h3 id=\"step-23-로컬호스트-환경-스프링부트에-https-적용-확인\" style=\"position:relative;\"><a href=\"#step-23-%EB%A1%9C%EC%BB%AC%ED%98%B8%EC%8A%A4%ED%8A%B8-%ED%99%98%EA%B2%BD-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8%EC%97%90-https-%EC%A0%81%EC%9A%A9-%ED%99%95%EC%9D%B8\" aria-label=\"step 23 로컬호스트 환경 스프링부트에 https 적용 확인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.3 로컬호스트 환경 스프링부트에 HTTPS 적용 확인</h3>\n<p>스프링 부트 초기 설치는 생략하고, 의존성은 <code class=\"language-text\">boot-starter-web</code> 만 있어도 된다. 설정을 확인하자.</p>\n<ul>\n<li>application.yml</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">server</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">port</span><span class=\"token punctuation\">:</span> <span class=\"token number\">8080</span> <span class=\"token comment\">#Https port</span>\n  <span class=\"token key atrule\">ssl</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">enabled</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n    <span class=\"token key atrule\">key-store</span><span class=\"token punctuation\">:</span> /Users/liquid.bear/certs/minica.jks <span class=\"token comment\"># 생성한 .jks 파일 위치</span>\n    <span class=\"token key atrule\">key-store-password</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"123456\"</span>  <span class=\"token comment\"># .jks를 생성할 때 입력했던 keystore 비밀번호</span>\n    <span class=\"token key atrule\">key-password</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"123456\"</span> <span class=\"token comment\"># .jks를 생성할 때 입력했던 key 비밀번호</span>\n    <span class=\"token key atrule\">key-alias</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"localhost\"</span> <span class=\"token comment\"># .jks 별칭</span></code></pre></div>\n<p>이제 스프링 부트를 동작시켜보자.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 49.44444444444444%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABZElEQVQoz1WS2XKCQBBF+RJAEQSjhn0TkEiV//9HnTo3YJGHrl5muH2maSfNMmv73oqytKbrZOR101hRVapXdW15Udh3mlpZVZbmueKsKCznvGksy3N954RhaHGS2DmOLY5j+eRyURxGkUVRZEmSyHMXO2Gnk0Xns3LOiNFxIEQdDxHx9XYTAXRbjSaQlnUtsrpt7et6tW4YdO55nswBd5xnPWWaZ3uMo9C7x0M5Hw7TpDpiGylEwY7S9307HA7mQIAg3ftx1Dz6YZAozzoejxYEgWK857rmrzSIyHuexMglCMlGJeLn8yMM1VZv2lbE3k5gI/tHiCAfIcDz8Mv7rfhnWez5eqkhjbh7u98lAD22F3XoyHzmZfnMUDZN+jE0QmijRZwaM4f6nqZ/Y9gI90/Es4d8ABE1xIf1nBo553jWirkG63xFyApwAdLtIjQYy8zqIJSvnhGx9NwnZ93IeY3ruvYLFwU6SR/hwVkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"run-spring\"\n        title=\"run-spring\"\n        src=\"/static/0e0f33ecce5606d9a2d57cf5e4b7b7fd/fcda8/7.png\"\n        srcset=\"/static/0e0f33ecce5606d9a2d57cf5e4b7b7fd/e9ff0/7.png 180w,\n/static/0e0f33ecce5606d9a2d57cf5e4b7b7fd/f21e7/7.png 360w,\n/static/0e0f33ecce5606d9a2d57cf5e4b7b7fd/fcda8/7.png 590w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p><code class=\"language-text\">http://localhost:8080</code> 로 접근하면 아래와 같은 메시지가 나올 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 424px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 17.77777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAb0lEQVQY062PiQkFIRBD7b8uCxCswgsPUEHELJnFbeD/QEhwnIeqOSfotRb23vhF5xwoay2MMdBagz3nLK61SqaUpDPpOw8hIMaIUgq89/IoSrXW0Hv/Fu4Szy/oJiHshDjnBMh7nI0xXiD+KH75AWfRNdlskODxAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"result-localhost\"\n        title=\"result-localhost\"\n        src=\"/static/514ccd3daec60765bf39a61797b0eae6/1cfa9/8.png\"\n        srcset=\"/static/514ccd3daec60765bf39a61797b0eae6/e9ff0/8.png 180w,\n/static/514ccd3daec60765bf39a61797b0eae6/f21e7/8.png 360w,\n/static/514ccd3daec60765bf39a61797b0eae6/1cfa9/8.png 424w\"\n        sizes=\"(max-width: 424px) 100vw, 424px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>다시 <code class=\"language-text\">https://localhost:8080</code> 로 접근을 하면 아래와 같이 나올 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABWklEQVQoz5WSSW6DMBSGuUaUEAaPYBtMQsIgqqyqqu2iUnuJnqWX/isbQkI6SFl8C2S/f3gmeHl6xtAPKIyFKSrITEMZC11U0OZ+gsP+gL7t0R07tHUDrQyimCBJ6Eya0sX3fwT7ukHbP6DpT6ibAVmuEUUp4ph4wphgFY0G8QyZz28Jum5AfWhhygq5KjznhOsoRSMk3lWO1TbxA87MnccLg8nEJWz7Abv9EUIqL5ZdVQ4jAsslHo0B4RnYBKUC2ygZxa8NXMKlG7nUmS6kTCIr97C2RlHuUNoapqzBhfIhOM9BqJhngvPggsnAmTEmvZDSFtpY/xfIvPKChHJPStiN4B/7cJeSlPmaLo2UeqzMBJjQ4LL0ECrHR3OV55o/uAhSKsHYZYceL1h47hJMCQfPynEF0wNE02o26zXq4RUfn184nt4QbsL/BJf7/JWYgLAcQu1AWOYTfgMiCD6f9mNGmwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"result-chrome\"\n        title=\"result-chrome\"\n        src=\"/static/f0a6ffa38b6ec5aec8b77635d716bac1/37523/9.png\"\n        srcset=\"/static/f0a6ffa38b6ec5aec8b77635d716bac1/e9ff0/9.png 180w,\n/static/f0a6ffa38b6ec5aec8b77635d716bac1/f21e7/9.png 360w,\n/static/f0a6ffa38b6ec5aec8b77635d716bac1/37523/9.png 720w,\n/static/f0a6ffa38b6ec5aec8b77635d716bac1/302a4/9.png 1080w,\n/static/f0a6ffa38b6ec5aec8b77635d716bac1/85053/9.png 1225w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 482px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 57.77777777777777%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACCUlEQVQoz52Sy2oTURyHZ6m+gNJ2Zs5tMpPJZdImM5PJpEkmaCWm2LTgBUFQqeDGJ/ABRHAvuHBRXIggVVB8CbfiwmUf5JOZRKsLqXjg4zvXH3/OOZZqpziNBDuMcUoaCe5/IMMOjiuweg/fsvXgDebwM61Hn5D3P3Ju/5gLB+//geOK8wcfkNNDhOdhGb9J4NXwg5BaLcB4AUL5SL30PyE96psJrt/EshtdLqqANRPiNjax6x2csINdjyrrKMZECard+zutLrW0wPUCrO5oyuzWXSbXbxBGmyRpnzjtk+VDtnoxUhuE0hVlX2kPZf6knM/yHK011rOXR5Tt28kJw6u77O1eYzabsVjsMZ/PiXs9BlnGtChoNhtopaqDSkqklJWFEEwmE4xnsB4/ecqXr995/e4Fve0p+/sLLu/sMJvP2R6NyIfDiklRkA0G9LOsGqdpugxUqvJ4PMYYgyW9AFWP2DAhabvFIs8YdyKudCISz9BVkr5WbClJRytSoyuLVVhJWWFRFMsKPaPJB32SuIcnJYGSeMLFlwJfKXytqa+oafXLchWmlK6c9rPlHZYLZfmDPK82VejyAdTp+DfEykprtHSR7jrC2aCmXVzXxRqNR9i2jeM6SCWXyDMoA5011gd30PeOiA5fcWnxHFdqrFa7dXq5PwPPRCGFg9PMEPlt9PAmdrxXfa0f5BZ8zhxnehoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"result-ca\"\n        title=\"result-ca\"\n        src=\"/static/c978cb584340deba4d583071841b1949/37e0d/10.png\"\n        srcset=\"/static/c978cb584340deba4d583071841b1949/e9ff0/10.png 180w,\n/static/c978cb584340deba4d583071841b1949/f21e7/10.png 360w,\n/static/c978cb584340deba4d583071841b1949/37e0d/10.png 482w\"\n        sizes=\"(max-width: 482px) 100vw, 482px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>위의 경고들은 우리가 만든 인증서를 신뢰할 수 없어서 발생하는 경고로써 2가지 방법이 존재한다.</p>\n<ol>\n<li>\n<p>파이어폭스에 인증서 예외 추가하기</p>\n<ul>\n<li>장점 : 시스템적으로 신뢰하는 CA로 등록하는게 아니기 때문에 찜찜함이 덜할 수 있다.</li>\n<li>단점 : 파이어폭스로만 Https를 확인해야한다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">MacOS</code> KeyChain에 생성한 CA 인증서 등록</p>\n<ul>\n<li>장점 : 어떤 브라우저든 신뢰하는 인증서로 판단해준다.</li>\n<li>단점 : 시스템 전역으로 이 CA를 신뢰한다고 판단해서 찜찜할 수 있다.</li>\n</ul>\n</li>\n</ol>\n<p>1번은 <a href=\"http://bahndal.egloos.com/629897\">반달가면 : 파이어폭스 브라우저에서 신뢰할 수 있는 웹서버 인증서 추가</a> 로 대체하고 2번을 해보고자 한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60.55555555555555%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACFUlEQVQoz5WS227TQBCG/RiI1s7Bp13HjhOfEjuOm0ObtIkCtKKtRKW2IkSARMUL8AZcIV6CK17xQ161tNzRi0/zz8zur9mDNoy6hFkXR/pMj5asX52yOFkzLCuSYUFWlIo6Hx1MKaoJo2rCYDT+h7ofZUO0Xj+mnySITkA8yMjLkmp2RD4+UAb14jQv1eJqdshyvSEe5IRxSi/JHkkH+GEfrRMVDPKSF3sNfnz/xu9fP8mGAyZHK2aLE/woxZIBthfgdEJsr4thujQsoaj1Q663bLRkWFJND/G6fS7Pz9i9P6dXTxvGREFEP+gThjFuECGCCFN2MSyJbgp0ZSbutUBvO2hxuWC1ecOgGGO0WliOg2mZWFabZlOn0dhX6PoenidwHBvD2KfXD5GepNVuIqRLFPUwGgaa5XrY0qdlC/Lpms3VV4rXX6jO7jCLd+jJOY3skr3oLdFyR7b+pHR8vKM6vSNe7vAOrklWn3npTdAcGSA6IZYrCYoV+eYj0WJLvNziz7e41Q1GeoGeXOBPrwnnt+jpBcHshvT4g6o55RXBfMt+Z1Yb+rj1hUuftu3Qtkx15BrbfoJjYtn39Se6jg+0zTaa4wVIP0T4IZbwsb0QS3b/D+9R1/tatkTzgh5ZPmJYjNXXMIWvjJ+NDNQ7aEEvpprMmc4XuJ3wb/O52LL7OGGc5iRZocxMt6OmVPE5CJ+mJfgDg6p42xIz7DYAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"keychain\"\n        title=\"keychain\"\n        src=\"/static/24d037bed8ac79b8d12842fe471cc570/37523/11.png\"\n        srcset=\"/static/24d037bed8ac79b8d12842fe471cc570/e9ff0/11.png 180w,\n/static/24d037bed8ac79b8d12842fe471cc570/f21e7/11.png 360w,\n/static/24d037bed8ac79b8d12842fe471cc570/37523/11.png 720w,\n/static/24d037bed8ac79b8d12842fe471cc570/4b446/11.png 877w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>스포트 라이트에 <code class=\"language-text\">keychain</code> 이라 검색하여 위와 같은 인증서를 볼 수 있는 설정으로 들어간 후에</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 274px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 130.55555555555557%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAYAAAC3g3x9AAAACXBIWXMAAAsTAAALEwEAmpwYAAAESUlEQVRIx31VyXLbRhBFKpWDK7GdihPbsjYSO0AC3EFwk0SCBElwX8SoKMnSJZvlKlcc6aRT7Pz3S3UDoKnEyaFrgMHMm9f9Xg+End0EZvMV5osV9vZF2HYezVYHgvAVnr/YRbPZQVJUIQhfoFSqwnUbqNVOIMkGBOFLpFI5eF4Pj58843fhMCHBMG1Ydg67e4f44fkO9vYTePToMZ48/Q6HCRkvXu7h62++5fmkqEBWdOwfiAyy8+oAqmbi2fcvQ1BRUtDxu2h3fHgdH8FwiLbvo9sL0PF76HR7aHodmGkLoqwiKSlISDI/y6oOI23BsrNIpW3IqhYCHp+04LV91BvHaLU7aHltnLQ81OpHODpuonF8At1MM5ikaJugdyNlwc7koBspJEUZgqSo6PYDDEcTZjoYjXkkwMXyFP1gwN8WpyvkCqUNKDFUdZPnMrkCzJSFpCRDEGUFzZYXsmp6nJ7X6XL6pbLLqdJiM20zSzliR4CKZsDO5mFlcjCiDISEKDFIPxii2WojGIzgd/sIhiM45QoOkxIODpPYj+IgISIhfqohgRGoETNMihJ6wYCBQsAh5oslpz4Yjjjd5epHnusPhhiOJ5vUNyLRAVFNOeVsvgDHrfBYKDm8wXGrcKt15ApFlJwyym4VhVIZpXKFGRE7CkqfRkqfARVNR9Epc73yRYdB3Fod2UIxVJNZyKxgIgpiRt8IhFKm+m4AyTtNr43ZYslCtP0uJrM52t0e0naGRaA18pZdtkVhhdmDegioGibbZjyZMiDVaRQ9k8JkKw5ZZZA4aDMBxrYhBxD7TQ3LlRobNJPLo+S4yOYKrJyqG1C1MJTPBAFRkCc3ohQdF261hnKlyvUsFB0WRTdTkBUVSiRALEIcBJiyMtHB5icfUr+SLfxuj7uj1w8wmc4ZWJJDO8SxnTYBZvNFFkaj1os7JW1nuRb0gYSgZk9bGZ4jBvlSmZ8paO22KARIQesYkD5SDVKWDdOyeQP5LB2BUtPTYgpSk5j8bw1pslJtoNY4YjHiDWG91NAu/1B42zoEFB/EgMRsPJnh4vKK7UJKU8qGGRY6FOOhB7evL2JOHWRSymSbXL7IbeVWqqjW6hxOmWxT5EuTlCbg/7JNrLwSG3s2H6PfH2I8nmA2W2A6neGk2UKeBLAyEUuN0xflf0eSRjK5qvMoXFwssDw9w+Xla1xdXWO9XsNrtVGpVJHJ5KEbacha5D9Ze1BHGql2fE/GDC9fL/Hrb29xd3eH9+//wM2bG3T9HhqNY1A5YgUVTf9sDWNXbC6H6+tzBMEIi8UCq9MVJpMp+v0A9foRikWHRZJULUyLWpDAo+vqQQ1jwJ9+/gU3b97i48e/cH9/jw9/fsDt7S3evfsd09kcZ2drrM8vcbY+55tIVo3NHUgA1AxkeDqIa0htRi1HogT0QxqO0PF9Zpih/wWnFHZQzIK6i4N/WOrmakskJfwNsoQyMrwTl3YAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"keychain-option\"\n        title=\"keychain-option\"\n        src=\"/static/9a3c7705842fa1f739a0c50fad546106/d3fa7/12.png\"\n        srcset=\"/static/9a3c7705842fa1f739a0c50fad546106/e9ff0/12.png 180w,\n/static/9a3c7705842fa1f739a0c50fad546106/d3fa7/12.png 274w\"\n        sizes=\"(max-width: 274px) 100vw, 274px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>여기서 <code class=\"language-text\">import Items</code> 를 통해서 인증서를 추가하면 끝난다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 341px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62.77777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAACFklEQVQ4y41T2W7aUBD1V1RVC9hgg/EGDhAMGLPGhIbQRlHVkJakDZQd0k9q/oavSF/5CnSqGZagKF0sHd2513PPnFmu0PncRalURblSx4l/Cs+rIJ1xkHUK0HQLsqJCicb/D4oK4arzBeVKjckajXdsW5YN+ygNWYkhEJQQEsMIhf6MYCgMSZI5uECXpLACKaIgJEYgR1XEdRMxVYeqGayS9n+FZrJfKu1AOG9f4Oq6i5vbO1x+/ITOdRf9wQjNszYT6kYCmmHxheeg//ZRBplsnvcFtwxBNyw+NKwkDDPJBLRSZCUWZ0RVba9U26rarXRPDMv4+q2Hx8dfEIjdSqaQdz0UvQq8chUFtwQn56JQLMH1ymzv0td0c6+QCM2EjbAcw3zxA/QJx04BdiqDat1H3W/itNliu1iqoFZv4MRvsq3GnwgPa0eEESWGyXSG9XoNYReZmkA4TPPllK19aai2RBgUI5gv7jcKzz9cIpsroNW+AM3kWes9O+6bscVOFdnZnIu8S+XYzKxmJNC9ucVyuYRA0Uk6rTuFNE9kH47MJtVtytoTSK0oyfg+GGK1WkEoV31WSMqqNZ9XAjWJU7LszQQ8A53rZgLpYweqZmJxv20KRaVnQ9KTdpodnHyRnd8ERH4FgRfA50GJH8Kr129x1+tvCIejMaazOYajCUbjKWhPGE9mmM0X/wQ1o9cf4OfDAxP+Bs7vulVLoIg8AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"clear\"\n        title=\"clear\"\n        src=\"/static/3b5f2ea163da5b233870acdd3ad34979/4c0ad/13.png\"\n        srcset=\"/static/3b5f2ea163da5b233870acdd3ad34979/e9ff0/13.png 180w,\n/static/3b5f2ea163da5b233870acdd3ad34979/4c0ad/13.png 341w\"\n        sizes=\"(max-width: 341px) 100vw, 341px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>이런식으로 빨간 자물쇠가 없어진 것을 확인 할 수 있다.</p>\n<p>이번 포스팅은 간단하게 HTTPS와 HTTPS 핸드셰이크에 대해서 다룬 후에 실제 CA인증서를 발급 후에 이것을 톰캣에 띄우기 위해서 <code class=\"language-text\">.jks</code> 파일로 변환하여 띄운 후에 인증서 예외처리를 통해서 빨간 자물쇠가 안뜨게끔 해보았다.</p>\n<h2 id=\"step-3-reference\" style=\"position:relative;\"><a href=\"#step-3-reference\" aria-label=\"step 3 reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3. REFERENCE</h2>\n<ol>\n<li><a href=\"https://www.cloudflare.com/ko-kr/learning/ssl/what-happens-in-a-tls-handshake/\">What happens in a TLS handshake? | SSL handshake | Cloudflare</a></li>\n<li><a href=\"https://www.cloudflare.com/ko-kr/learning/ssl/what-is-ssl/\">SSL(Secure Sockets Layer)이란 무엇입니까? | Cloudflare</a></li>\n<li><a href=\"https://feel5ny.github.io/2019/12/08/HTTP_014_02/\">HTTPS의 세부사항 | 필오의 개발일지</a></li>\n<li><a href=\"https://www.acunetix.com/blog/articles/tls-security-what-is-tls-ssl-part-1/\">TLS Security 1: What Is SSL/TLS | Acunetix</a></li>\n<li><a href=\"https://www.acunetix.com/blog/articles/history-of-tls-ssl-part-2/\">TLS Security 2: A Brief History of SSL/TLS | Acunetix</a></li>\n<li><a href=\"https://www.acunetix.com/blog/articles/tls-ssl-terminology-basics-part-3/\">TLS Security 3: SSL/TLS Terminology and Basics | Acunetix</a></li>\n<li><a href=\"https://www.acunetix.com/blog/articles/tls-ssl-certificates-part-4/\">TLS Security 4: SSL/TLS Certificates | Acunetix</a></li>\n<li><a href=\"https://www.acunetix.com/blog/articles/establishing-tls-ssl-connection-part-5/\">TLS Security 5: Establishing a TLS Connection | Acunetix</a></li>\n<li><a href=\"https://www.acunetix.com/blog/articles/tls-vulnerabilities-attacks-final-part/\">TLS Security 6: Examples of TLS Vulnerabilities and Attacks | Acunetix</a></li>\n<li><a href=\"https://dokydoky.tistory.com/463\">HTTPS - 2. HTTPS의 Ciphersuite, Handshake, Key derivation</a></li>\n</ol>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\"><a href=\"https://herrymorison.tistory.com/entry/SSL-30%EC%9D%98-%EC%B7%A8%EC%95%BD%EC%A0%90-POODLE%EC%9D%B4%EB%9E%80\">SSL 3.0의 취약점 “POODLE”이란?</a><a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\"><a href=\"https://www.hahwul.com/2016/04/07/hacking-sslv2-drown-attackcve-2016-0800/\">SSLv2 DROWN Attack(CVE-2016-0800) 취약점 분석 / 대응방안</a><a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-3\"><a href=\"https://ko.wikipedia.org/wiki/%EC%9D%B8%EC%A6%9D_%EA%B8%B0%EA%B4%80\">인증 기관</a><a href=\"#fnref-3\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>","excerpt":"STEP 1. HTTPS란? STEP 1.1 HTTPS Handshake STEP 2. 로컬호스트 환경에 HTTPS 적용하기 STEP 2.1 minica를 이용한 로컬호스트 CA 인증서 발급 STEP 2.2 openssl 및 keytool을 이용한 p12, jks인증서 발급 STEP 2.3 로컬호스트 환경 스프링부트에 HTTPS 적용 확인 STEP 3. REFERENCE 개요 나중에 포스팅해야지 하고 넘어갔던 부분인데 이번에 다른 분께서 질문을 올려주셨어서 포스팅을 해보고자 한다. 제목과 같이  환경에서 HTTPS를 적용하는 것이 주된 목표이고, 확인 절차는 간단하게 스프링 부트를 통해서 작업하였다. MacOS에서 로컬 개발환경에 HTTPS 적용하기 STEP 1. HTTPS란? STEP 1.1 HTTPS Handshake STEP 2. 로컬호스트 환경에 HTTPS 적용하기 STEP 2.1 minica를 이용한 로컬호스트 CA 인증서 발급 STEP 2.2 openssl 및 keyto…","frontmatter":{"date":"March 25, 2022","title":"MacOS에서 로컬 개발환경에 HTTPS 적용하기","categories":"개발 인프라","author":"개발한입","emoji":"💻"},"fields":{"slug":"/https-apply-localhost/"}},"next":{"id":"b614bede-83e9-59c1-93bb-7b6881b7d0f9","html":"<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#step-11-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C\">STEP 1.1 운영체제와 시스템 콜</a></p>\n</li>\n<li>\n<p><a href=\"#step-21-io-%ED%96%A5%EC%83%81%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%88%98%EC%A4%80%EC%9D%98-%EA%B8%B0%EC%88%A0\">STEP 2.1 I/O 향상을 위한 운영체제 수준의 기술</a></p>\n<ul>\n<li><a href=\"#step-211-%EB%B2%84%ED%8D%BCbuffer\">STEP 2.1.1 버퍼(Buffer)</a></li>\n<li><a href=\"#step-212-scattergather\">STEP 2.1.2 Scatter/Gather</a></li>\n<li><a href=\"#step-213-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC\">STEP 2.1.3 가상메모리</a></li>\n<li><a href=\"#step-214-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%A7%B5-%ED%8C%8C%EC%9D%BC-memory-mapped-io\">STEP 2.1.4 메모리 맵 파일 (Memory-mapped I/O)</a></li>\n<li><a href=\"#step-215-%ED%8C%8C%EC%9D%BC-%EB%9D%BD\">STEP 2.1.5 파일 락</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-41-%EC%9E%90%EB%B0%94%EC%9D%98-%ED%8F%AC%EC%9D%B8%ED%84%B0-%EB%B2%84%ED%8D%BC-%EB%8F%84%EC%9E%85\">STEP 4.1 자바의 포인터 버퍼 도입</a></p>\n</li>\n<li>\n<p><a href=\"#step-42-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C-io-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A5%BC-%EC%A0%9C%EA%B3%B5-%EC%B1%84%EB%84%90-%EB%8F%84%EC%9E%85\">STEP 4.2 네이티브 I/O 서비스를 제공 채널 도입</a></p>\n</li>\n<li>\n<p><a href=\"#step-43-%EC%85%80%EB%A0%89%ED%84%B0-%EB%8F%84%EC%9E%85\">STEP 4.3 셀렉터 도입</a></p>\n</li>\n</ul>\n</div>\n<h1 id=\"시스템-콜과-자바에서의-시스템-콜-사용례\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C%EA%B3%BC-%EC%9E%90%EB%B0%94%EC%97%90%EC%84%9C%EC%9D%98-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C-%EC%82%AC%EC%9A%A9%EB%A1%80\" aria-label=\"시스템 콜과 자바에서의 시스템 콜 사용례 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시스템 콜과 자바에서의 시스템 콜 사용례</h1>\n<h1 id=\"목차\" style=\"position:relative;\"><a href=\"#%EB%AA%A9%EC%B0%A8\" aria-label=\"목차 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>목차</h1>\n<ul>\n<li>개요\n<ul>\n<li>STEP 1. 시스템 콜이란?\n<ul>\n<li>STEP 1.1 운영체제와 시스템 콜</li>\n</ul>\n</li>\n<li>STEP 2. 자바와 시스템 콜\n<ul>\n<li>STEP 2.1 I/O 향상을 위한 운영체제 수준의 기술\n<ul>\n<li>STEP 2.1.1 버퍼(Buffer)</li>\n<li>STEP 2.1.2 Scatter/Gather</li>\n<li>STEP 2.1.3 가상메모리</li>\n<li>STEP 2.1.4 메모리 맵 파일(MMIO)</li>\n<li>STEP 2.1.5 파일 락</li>\n</ul>\n</li>\n<li>STEP 2.2 중간정리</li>\n</ul>\n</li>\n<li>STEP 4. 자바에서의 블록킹 I/O와 논블로킹 I/O 차이\n<ul>\n<li>STEP 4.1 자바의 포인터 버퍼 도입</li>\n<li>STEP 4.2 네이티브 I/O 서비스를 제공 채널 도입</li>\n<li>STEP 4.3 셀렉터 도입</li>\n</ul>\n</li>\n<li>STEP 3. REFERENCE</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"개요\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EC%9A%94\" aria-label=\"개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개요</h1>\n<p>최근에 CS를 다시 공부하면서 궁금한 점이 많아졌다. 특히 그 부분 중에서 제일 컸던 부분은 시스템 콜 부분이었다. 운영체제를 공부하면서 많은 학부생들이나 개발자들이 느끼는 감정이 그래서 이게 어디서 쓰이는데 혹은 어디에 접목할 수 있는데 일 것이다.</p>\n<p>예를 들면 프로세스와 쓰레드도 그렇다고 생각한다. 단순하게 <code class=\"language-text\">synchorized</code> 키워드를 붙어서 동기화 처리를 한다고 생각하지만, <code class=\"language-text\">synchorized</code> 키워드를 사용할 경우에는 자바에서는 세마포어를 추상화 시킨 모니터라는 개념을 통해서 동시성 제어를 하게된다.</p>\n<p>이번에 CS를 공부하면서 초점을 맞춘 부분도 이론으로 배운 운영체제 내용들이 실제로 우리가 개발하는데 어떤 방식으로 사용되는지 궁금해졌고, 그 중에서 시스템 콜에 대해서 내용을 다루기로 생각했다.</p>\n<h1 id=\"step-1-시스템-콜이란\" style=\"position:relative;\"><a href=\"#step-1-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C%EC%9D%B4%EB%9E%80\" aria-label=\"step 1 시스템 콜이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1. 시스템 콜이란?</h1>\n<p>일단, 시스템 콜은 <strong>사용자 프로세스가 커널 프로세스에게 어떠한 문맥을 요청하면서 발생하는 것</strong>이다.</p>\n<p>이를 알기 전에 약간의 운영체제 지식이 필요하니 운영체제에 대해서 조금 훑고 가고자 한다.</p>\n<h2 id=\"step-11-운영체제와-시스템-콜\" style=\"position:relative;\"><a href=\"#step-11-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C\" aria-label=\"step 11 운영체제와 시스템 콜 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.1 운영체제와 시스템 콜</h2>\n<p>운영체제의 사용 목적은 다음과 같다.</p>\n<ul>\n<li><strong>사용자가 편리하게 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공</strong></li>\n<li><strong>컴퓨터 시스템 안의 하드웨어를 효율적으로 관리하기 위함</strong></li>\n</ul>\n<p>그렇다면 이러한 궁금증이 들 수 있다고 생각한다.</p>\n<blockquote>\n<p>어떻게 하드웨어를 효율적으로 관리하고, 편리하게 사용할 수 있는 환경을 제공할까?</p>\n</blockquote>\n<p>오늘날 대부분의 운영체제는 시분할 시스템이다. <strong>시분할 시스템은 일련의 작업들을 시간단위로 나눠서 처리</strong>한다. 이 작업들은 운영체제에서 자원을 할당받아서 돌아가는 프로세스이다.</p>\n<p>이 시간 단위가 매우 짧기 때문에 사용자 입장에서는 여러 프로그램들을 운영체제에서 실행해도 동시에 실행되는 것 처럼 느껴진다.</p>\n<p>즉, 프로세스는 <strong>운영체제 위에서 실행 중인 프로그램</strong>이라고 볼 수 있다.\n당연히 이러한 환경이다보니 어떤 프로세스의 자원 처리나 하드웨어 작업 등의 처리가 나날이 복잡해졌다.</p>\n<p>우리가 C언어를 사용할 때 생각해보자. 어떠한 메모리를 할당받았으면 반드시 프로그래머는 해당 구문이 더 이상 메모리가 필요가 없다면 <code class=\"language-text\">free()</code> 를 처리해서 자원을 반납해줬어야했다.</p>\n<p>하지만, Java와 같은 언어들은 <code class=\"language-text\">GC(Garbage Collection)</code>을 지원하면서 자원 반납에 대한 프로그래머의 부담을 해소시켜줬다.</p>\n<p>운영체제도 그러한 편리함을 제공해준다고 봐도 무방하지 않을까 생각이 든다.\n일례면 우리가 크롬을 켜두고 유튜브로 음악을 들으면서 워드로 문서 작업을 하고 있다고 생각해보자. 우리는 자원의 할당이나 반납을 생각하지 않고 사용하면 된다.</p>\n<p>위에서 나온 운영체제의 목적 중에서  <strong>사용자가 편리하게 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공</strong> 이 부분이라고 생각해도 될 것 같다.</p>\n<p>물론 가끔 너무 많은 리소스를 사용하면 해당 프로그램이 먹통이 되서 대기를 해야된다던가 강제 종료를 하는 부분이 존재하긴 하지만, 평소에 사용할 때는 아무 신경을 쓰지않는다. 이건 운영체제가 알아서 자원을 할당하고 처리해주기 때문이다.</p>\n<p>정리를 하자면, <strong>운영체제는 사용자가 자원의 관리나 할당에 신경을 쓰지 않고 처리할 수 있는 것들을 제공해서 편리하게 사용자들이 쓸 수 있게 해준다.</strong></p>\n<p>자 그러면 다시 생각해보자.</p>\n<blockquote>\n<p>엥 우리가 C로 짤때 <code class=\"language-text\">malloc</code> 과 같은 것으로 직접 메모리를 할당받고 그랬는데 이건 운영체제의 역할 아닌가요?</p>\n</blockquote>\n<p>정답이다.</p>\n<p>운영체제는 크게 2가지 모드로 프로세스를 동작시킨다.</p>\n<ol>\n<li>사용자 모드(User mode)</li>\n<li>커널 모드(Kernel mode)</li>\n</ol>\n<p>물론 크게 2가지로 나눠지는 것이고, 더 세분화된 모드들이 많다. 일단 위의 두 가지의 모드로만 봐보자.</p>\n<p>1은 우리가 <strong>사용하는 대부분의 프로그램들이 동작하는 모드</strong>이다.\n2는 <strong>운영체제 내부의 커널이 관리하는 프로세스의 모드</strong>이다.</p>\n<p>운영체제 수업때 돌이켜서 생각하면 운영체제가 보안적인 측면도 관리해준다고 교수님 혹은 조교(?)님께서 얘기해줬을 때가 있다. 운영체제는 커널 모드를 통해서 외부의 접근을 최소화해야하는 영역을 지정해두고 보안성을 높였다. 이 부분이 커널모드인 것이다.</p>\n<p><strong>사용자 모드가 커널 영역에 직접 접근하는 것이 아니라 운영체제에게 요청을 하면 해당 처리를 운영체제에 위임을 해서 처리하도록 하였다.</strong></p>\n<p>이것이 바로 <strong>시스템 콜</strong>이다.</p>\n<p>재밌는 만화가 있으니 참고해보자.\n<a href=\"https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&#x26;blogId=sheep_horse&#x26;logNo=221271778167\">유저영역과 커널영역 혹은 유저모드와 커널모드 : 네이버 블로그</a></p>\n<p>따라서, 우리가 C를 사용하면서 <code class=\"language-text\">malloc</code> 과 같은 명령어를 수행하면 내부적으로 시스템 콜이 발생해서 운영체제에게 이 요청을 위임한다.\n운영체제는 해당 명령어를 해석하고 할당해서 완료가 되면 해당 프로세스에게 알려주고 다시 프로세스는 사용자 모드로 동작한다.</p>\n<p>중요한 점은 단순하게 메모리 용량 할당 뿐만 아니라 I/O 작업이나 네트워크 작업 등 커널 영역이 필요한 모든 곳에서는 시스템 콜이 필요하다.</p>\n<p>즉, 우리가 사용하는 프로세스는 수 없이 많이 <strong>사용자모드와 커널모드</strong>를 왔다갔다하면서 작업을 수행하는 것이다.</p>\n<p>자 이제 시스템 콜에 대해서 얼추 알게되었다. 그렇다면 자바에서 주로 시스템 콜이 발생하는 부분은 어디일까? 제일 보편적인 것이 I/O 작업이라고 할 수 있다.</p>\n<p>이제 이것에 대해 알아보고자 한다.</p>\n<h1 id=\"step-2-자바와-시스템-콜\" style=\"position:relative;\"><a href=\"#step-2-%EC%9E%90%EB%B0%94%EC%99%80-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C\" aria-label=\"step 2 자바와 시스템 콜 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2. 자바와 시스템 콜</h1>\n<p>자바와 시스템 콜의 내용을 언급하기 이전에 JVM 내용이 들어갈 예정이니 <a href=\"https://brewagebear.github.io/fundamental-jvm-classloader/\">Java JVM과 Class Loader의 동작 과정 이해 - 개발 한입</a>를 한번 보고오는 것도 추천한다.</p>\n<p>위에서는 C의 예시를 들어서 시스템 콜을 얘기했다. C는 포인터를 통해서 메모리에 직접 접근할 수 있다보니 시스템 콜이 다이렉트로 발생시킬 수 있다고 할 수 있다. 물론 이 때문에 포인터를 사용해서 어떠한 작업을 한 뒤에 자원 반납을 프로그래머가 직접 작성해야되는 문제점이 있다.</p>\n<p>하지만, Java는 JVM 위에서 동작을 한다. 그렇기 때문에 시스템 콜 자체가 느려질 수 있는 상황이다.</p>\n<p>큰 차이점을 대략적으로 그림을 그려보았다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/22961251/159037748-447ecfb1-b145-4541-bb9c-f935267041f9.png\" alt=\"79A34C97-4FED-433C-8BD1-9CE861DD37CD\"></p>\n<p><img src=\"https://user-images.githubusercontent.com/22961251/159037763-4b35b28c-b08e-43c6-9ebf-17b197f02dba.png\" alt=\"E19A384D-C163-4042-8226-751983FA0FBE\"></p>\n<p>C의 경우에는 메모리 할당하는 부분이고, Java의 경우에는 디스크에서 파일을 읽을 때라고 가정한다.</p>\n<p>개략적으로 그린 그림이라 어떤차이인지 잘 모를 수 있다고 생각한다. 핵심은 C의 경우에는 시스템 콜을 직접 사용할 수 있지만 (<code class=\"language-text\">malloc</code> 이 시스템콜은 아니고 시스템 콜을 사용하는 API이다.) 자바의 경우에는 간접적으로 사용해야된다.</p>\n<p>만약 C로 I/O를 한다하면 아래와 같은 흐름으로 시스템 콜이 발생할 것이다.</p>\n<p><code class=\"language-text\">C 프로세스 -> 시스템 콜 -> 커널 -> 디스크 컨트롤러 -> 데이터 복사</code></p>\n<p>자바는 아래와 같은 흐름으로 이뤄진다.</p>\n<p><code class=\"language-text\">JVM -> JNI -> 시스템 콜 -> 커널 -> 디스크 컨트롤러 -> 커널 버퍼 복사 -> JVM 버퍼 복사</code></p>\n<p>즉, 시스템 콜을 사용하기 위해서 자바는 내부적으로 네이티브 메서드를 활용하기 때문에</p>\n<p>어떻게보면 JVM이라는 한 껍데기가 더 씌워져있기도 하고 내부에 버퍼가 존재하는데 여기서는 파일 읽기를 처리한다고 가정하였다. 이때 읽기 요청을 한 쓰레드가 디스크에서 프로세스 내부 버퍼로 복사를 할 때 Blocking이 발생하기도 한다.</p>\n<p>이 부분을 그림으로 표현하면 다음과 같다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/22961251/159037775-75bd8b44-9391-4bc0-bc8f-5ada04f28bf5.png\" alt=\"sync-blocking\"></p>\n<p>이렇게 <code class=\"language-text\">read()</code> 명령동안 해당 쓰레드는 작업을 못하게 되는 것이다.\n이러한 부분때문에 <strong>자바 IO는 느리다</strong> 라는 얘기가 나오게되었다.</p>\n<p>이러한 부분을 개선한 것이 <code class=\"language-text\">nio</code> 패키지인데 이를 보기 전에 느린 I/O를 처리하기하기 위해서 운영체제는 많은 기능을 제공하는데 다음을 알아보고자 한다.</p>\n<h2 id=\"step-21-io-향상을-위한-운영체제-수준의-기술\" style=\"position:relative;\"><a href=\"#step-21-io-%ED%96%A5%EC%83%81%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%88%98%EC%A4%80%EC%9D%98-%EA%B8%B0%EC%88%A0\" aria-label=\"step 21 io 향상을 위한 운영체제 수준의 기술 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.1 I/O 향상을 위한 운영체제 수준의 기술</h2>\n<p>자바 혹은 다른 언어를 사용하더라도 결국 <strong>시스템 콜</strong>을 사용하는 I/O는 느릴 수 밖에 없다. 그래서 운영체제는 이 I/O 향상을 위한 다양한 기술들을 제공하는데 크게 다음과 같다.</p>\n<ol>\n<li>버퍼(Buffer)</li>\n<li>Scatter/Gather</li>\n<li>가상메모리(Virtual Memory)</li>\n<li>메모리 맵 파일</li>\n<li>파일 락</li>\n</ol>\n<p>이를 각각 살펴보고자 한다.</p>\n<h3 id=\"step-211-버퍼buffer\" style=\"position:relative;\"><a href=\"#step-211-%EB%B2%84%ED%8D%BCbuffer\" aria-label=\"step 211 버퍼buffer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.1.1 버퍼(Buffer)</h3>\n<p>먼저 버퍼를 설명하기 앞서 시스템 콜 영역을 좀 더 세부적으로 그려보면 다음과 같다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/22961251/159037786-47c7eb77-f8f0-401d-ab9b-97b1326e28fa.png\" alt=\"C216A603-6E1C-4B6A-BB34-80AED5EA0952\"></p>\n<p>유저 영역과 커널 영역에서 버퍼를 사용하는 모습을 볼 수 있다.\n여기서 DMA(Direct Memory Access)<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup> 와 Disk Controller(I/O Controller)<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup> 는 운영체제 내용이니 넘어가고자 한다.</p>\n<p>버퍼는 무엇이고, 왜 사용하는 것일까?\n아주 단순하다 데이터를 하나씩 여러번 반복적으로 전달하는 것보다 중간에 버퍼를 두고 그 버퍼에 데이터를 모아 한 번에 효율적이기 때문이다.</p>\n<p>즉, 버퍼는 효율적으로 데이터를 전달하는 객체이다.\n따라서, 데이터를 전송하는 곳에서 대부분 버퍼를 사용하는데 운영체제도 예외는 아니다.</p>\n<p>버퍼의 이점을 알아보기 위해 세 가지 코드로 테스트 해보고자 한다.</p>\n<ol>\n<li>버퍼를 사용하지 않고 1바이트씩 10MB 파일을 읽어들임</li>\n<li>2048byte 크기의 버퍼를 만들어서 10MB 파일을 읽어들임</li>\n<li>10MB 크기의 버퍼를 만들어서 10MB 파일을 읽어들임</li>\n</ol>\n<p>먼저 버퍼를 사용하지 않는 코드를 볼텐데 코드는 다음과 같다.</p>\n<ul>\n<li>버퍼를 사용하지 않고 1바이트씩 10MB 파일을 읽어들임</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">NotUsedBuffer</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> COPY_ORIGIN_FILE <span class=\"token operator\">=</span> <span class=\"token string\">\"/Users/liquid.bear/Downloads/test.txt\"</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> COPY_DEST_FILE <span class=\"token operator\">=</span> <span class=\"token string\">\"/Users/liquid.bear/Downloads/test2.txt\"</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">long</span> startTime <span class=\"token operator\">=</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span>COPY_ORIGIN_FILE<span class=\"token punctuation\">,</span> COPY_DEST_FILE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">long</span> endTime <span class=\"token operator\">=</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"버퍼를 사용하지 않을 경우 처리 시간 : \"</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>endTime <span class=\"token operator\">-</span> startTime<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" milli seconds\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> origin<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> dest<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">IOException</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token keyword\">try</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">InputStream</span> in <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FileInputStream</span><span class=\"token punctuation\">(</span>origin<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">OutputStream</span> out <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FileOutputStream</span><span class=\"token punctuation\">(</span>dest<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n            <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">int</span> byteData <span class=\"token operator\">=</span> in<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>byteData <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                out<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>byteData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">test.text</code> 파일은 10MB 크기의 파일이다.\n맥을 사용하고 있다면 <code class=\"language-text\">mkfile -n 10m test.txt</code> 이런식으로 원하는 크기의 파일을 아주 손쉽게 만들 수 있다.</p>\n<p>핵심은 <code class=\"language-text\">copy()</code> 메서드 내부의 <code class=\"language-text\">while</code> 문이다. 1바이트씩 읽으면서 파일 쓰기를 처리하고 있다.</p>\n<p>다음은 2048byte 크기의 버퍼를 통해서 복사하는 예시이다.</p>\n<p>달라진 부분은 크게 없다 <code class=\"language-text\">BufferedInputStream inputBuffer = new BufferedInputStream(in, 2048);</code> 를 추가해서 읽기 버퍼를 추가했을 뿐이다.</p>\n<p>궁금한 점이 있을 수 있다</p>\n<blockquote>\n<p>왜 BufferedOutputStream은 사용하지 않았나요?</p>\n</blockquote>\n<p>즉, 쓰기 또한 1바이트씩 읽어서 쓰는게 아니라 버퍼에 담아두고 <code class=\"language-text\">EOF</code> 를 만났을 때 버퍼에 쓰인 값을 한번에 쓰는게 훨씬 빠를 것이다. 이 예시는 단순히 읽기 버퍼만 사용한 이유는 시간 값 차이를 확인하기 위함이라고 알아두면 될 것이다. (쓰기 버퍼를 쓰면 차이가 현저히 적어진다.)</p>\n<p>일단 먼저 두 개의 파일 복사 시간 차이를 확인해보자.</p>\n<img width=\"402\" alt=\"Screen Shot 2022-03-18 at 17 14 21\" src=\"https://user-images.githubusercontent.com/22961251/158962217-f810a078-0fd4-49bb-9b58-ff818828e15f.png\">\n<img width=\"399\" alt=\"Screen Shot 2022-03-18 at 17 14 16\" src=\"https://user-images.githubusercontent.com/22961251/158962219-2aed57ed-c18c-4252-a839-6e4befe2f511.png\">\n<p>생각보다 큰 차이를 보임을 알 수 있다. 그러면 읽기 버퍼를 파일 사이즈만큼 했을 때는 얼마나 빠를까?</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span>중략<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">int</span> available <span class=\"token operator\">=</span> in<span class=\"token punctuation\">.</span><span class=\"token function\">available</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> bufferSize <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span>available<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">int</span> byteData <span class=\"token operator\">=</span> in<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span>bufferSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span>중략<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre></div>\n<p>이런식으로 읽은 파일 크기 만큼 버퍼를 사용하도록 하였다.\n그렇다면 버퍼에 10MB 크기 전체가 읽힐 것이고, <strong>이 속도는 한번에 읽고 한번에 쓰기가 가능한 속도가 될 것이다.</strong></p>\n<img width=\"363\" alt=\"Screen Shot 2022-03-18 at 17 14 06\" src=\"https://user-images.githubusercontent.com/22961251/158962225-439e7937-90c2-4f68-bda6-04a05fc9f871.png\">\n<p>따라서 속도는 제일 빠르게 된다.</p>\n<p>전체 코드는 <a href=\"https://github.com/brewagebear/blog-example/tree/main/buffer-example/src/main/java\">blog-example/buffer-example</a> 을 참고해보자.</p>\n<p>이렇게 버퍼를 사용하지 않는 경우와 사용하는 경우는 I/O 속도차이가 꽤 난다는 것을 알 수 있다. 버퍼는 운영체제 뿐만 아니라 I/O가 많은 DB같은데서도 사용하는데 3번 예시와 같이 전체 파일의 크기로 버퍼를 만들면 당연히 <code class=\"language-text\">OOM</code> 발생 가능성이 존재하니 이를 테이블 데이터나 인덱스 크기에 맞춰서 적절한 값으로 튜닝하기도 한다.</p>\n<h3 id=\"step-212-scattergather\" style=\"position:relative;\"><a href=\"#step-212-scattergather\" aria-label=\"step 212 scattergather permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.1.2 Scatter/Gather</h3>\n<p>위에서는 버퍼에 대해서 알아보았다. 그렇다면 Scatter와 Gather는 어떤 기능을 제공해줄까?</p>\n<p>만약, 내가 버퍼를 N개를 만들어서 사용하는데 동시에 I/O 작업이 이뤄진다고 가정해보자. 그렇다면, N번의 시스템 콜이 일어날 수 있다고 추론할 수 있다. 시스템 콜은 문맥교환과 비교해서 적은 비용이지만 그렇다고 비용이 아예 발생하지 않는 건 아니다.</p>\n<p>이렇게 <strong>N번의 시스템 콜을 요청하는 경우 당연히 비효율적</strong>이라고 볼 수 있다.\n이러한 문제 때문에 운영체제는 Scatter와 Gather를 제공해준다.</p>\n<ul>\n<li>Scattering Read</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/22961251/159037807-6943164b-3068-4792-b8d5-e1256da1e5e6.png\" alt=\"6DDE1098-1B1C-4795-B28F-4B94F4D314B7\"></p>\n<ul>\n<li>Gathering Write</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/22961251/159037824-91d11a3b-dfdb-47a5-b0ae-eafa9f0120ae.png\" alt=\"5BED0995-D5D5-4FA1-BCF7-107038B13A7B\"></p>\n<p>Scatter와 Gather의 흐름은 위의 그림과 같다.\n이를 통하면 시스템 콜이 1번만 발생한다. 대신, 내부적으로 호출할 때마다 사용할 버퍼의 주소 목록을 넘겨줌으로서, 주어진 버퍼들로부터 순차적으로 읽거나 쓴다.</p>\n<p>자바에서는 이런 기능을 이용하기 위해서 <code class=\"language-text\">java.nio.channel</code> 패키지에\n<code class=\"language-text\">ScatteringByteChannel</code> 과 <code class=\"language-text\">GatheringByteChannel</code> 을 제공해준다.</p>\n<ul>\n<li>java.nio.channel.ScatteringByteChannel</li>\n</ul>\n<img width=\"435\" alt=\"Screen Shot 2022-03-18 at 17 59 20\" src=\"https://user-images.githubusercontent.com/22961251/159037840-711dd3a4-bb11-4f9e-ba0c-c1fbe28f64a9.png\">\n<ul>\n<li>java.nio.channel.GatheringByteChannel</li>\n</ul>\n<img width=\"428\" alt=\"Screen Shot 2022-03-18 at 18 00 40\" src=\"https://user-images.githubusercontent.com/22961251/159037880-8ee935bd-a4d3-4256-b9db-2d956d9649a1.png\">\n<p>이는 아마 다음 포스팅에서 I/O와 NIO 차이 포스팅을 생각중인데 그 때 자세히 다룰 것 같다.</p>\n<h3 id=\"step-213-가상메모리\" style=\"position:relative;\"><a href=\"#step-213-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC\" aria-label=\"step 213 가상메모리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.1.3 가상메모리</h3>\n<p>I/O 관점에서 가상메모리<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup> 를 다룰 예정이여서 가상메모리는 다른 참고자료들을 참고해보자.</p>\n<p>I/O 관점에서 가상메모리르 사용함으로 얻는 장점은 다음과 같다.</p>\n<ol>\n<li>실제 물리 메모리 크기보다 큰 가상 메모리 공간 사용 가능</li>\n<li>여러 개의 가상 주소가 하나의 물리적 메모리 주소를 참조함으로써 메모리를 효율적으로 사용 가능</li>\n</ol>\n<p>가상 메모리를 사용하면 2개의 버퍼를 사용하더라도 뒤에서 볼 <strong>메모리 맵 파일</strong>을 통해서 동일한 영역에 접근이 가능해진다. 따라서, 커널 영역 -> 유저 영역으로 데이터를 복사를 하지않아도 된다.</p>\n<ul>\n<li>커널 및 유저 영역과 매핑된 가상 메모리</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/22961251/159037912-0006eb17-c15f-44c2-bc7d-164393d33c07.png\" alt=\"C6434205-068F-4709-9EC2-ABF10C327B1A\"></p>\n<p>이런식으로 같은 영역을 사용한다고 볼 수 있다.</p>\n<h3 id=\"step-214-메모리-맵-파일-memory-mapped-io\" style=\"position:relative;\"><a href=\"#step-214-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%A7%B5-%ED%8C%8C%EC%9D%BC-memory-mapped-io\" aria-label=\"step 214 메모리 맵 파일 memory mapped io permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.1.4 메모리 맵 파일 (Memory-mapped I/O)</h3>\n<p>위에서 가상메모리와 버퍼에 대해서 이야기를 했다. 또한, 가상메모리를 설명할 때 유저 가상 메모리와 커널 가상 메모리가 매핑되려면 메모리 맵 파일을 사용한다하였는데 이번에 이 메모리 맵 파일에 대해서 알아보고자 한다.</p>\n<p>우리가 인텔리제이를 사용한다고 가정해보자. 인텔리제이 또한 자바 기반으로 만들어져있는데 코드를 입력할 때마다 I/O 시스템 콜이 발생할 것이다. 그리고 입력된 값을 다시 버퍼에 옮기는 작업이 이뤄질 것이고, <strong>복사를 한 후에 가비지가 생기고 이를 또 가비지 컬렉터가 처리할 것</strong>이다.</p>\n<p>가비지 컬렉터가 가비지를 수거하는 것은 상당히 느린 작업이고, 많은 기업들이 GC 튜닝하는데 공을 들이는 이유일 것이다.</p>\n<p>이러한 문제점을 해결하기 위해 운영체제에서 지원하는 것이 <code class=\"language-text\">MMIO(Memory-mapped I/O)</code><sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup> 이다.</p>\n<p>위의 가상메모리 부분을 구현하는 부분이 이 부분이라고 생각해도 좋을 것 같다.\n가상메모리 설명 부분에서 말했듯이 <code class=\"language-text\">MMIO</code> 를 통하면 <code class=\"language-text\">read()</code> , <code class=\"language-text\">write()</code> 와 같은 시스템 콜을 할 필요가 없어진다고 하였다.</p>\n<p>또 다른 장점으로는 매우 큰 파일을 복사하기 위해 많은 양의 메모리를 소비하지 않아도 된다는 점이다.  이러한 이유는 내부적으로 <code class=\"language-text\">MMIO</code> 는 시스템의 페이지들을 메모리로 바라보기 때문에 필요한 부분만 메모리에 로드해서 사용하기 때문이다.</p>\n<p>자바에서는 <code class=\"language-text\">java.nio.MappedByteBuffer</code> 클래스가 <code class=\"language-text\">MMIO</code> 과 관련해서 사용되는 버퍼이다.</p>\n<ul>\n<li>java.nio.MappedByteBuffer</li>\n</ul>\n<img width=\"436\" alt=\"Screen Shot 2022-03-18 at 18 26 33\" src=\"https://user-images.githubusercontent.com/22961251/159037930-af577366-4e2e-4595-a264-7a57abf22bdc.png\">\n<h3 id=\"step-215-파일-락\" style=\"position:relative;\"><a href=\"#step-215-%ED%8C%8C%EC%9D%BC-%EB%9D%BD\" aria-label=\"step 215 파일 락 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.1.5 파일 락</h3>\n<p>DB를 공부하면 배타 락(X-Lock, Exclusive-Lock)과 공유 락(S-Lock, Shared-Lock)에 대해서 듣게된다. 배타 락은 주로 <strong>쓰기 작업</strong>에 사용되고 공유 락은 <strong>읽기 작업</strong>에 사용된다.</p>\n<p>사실 이 배타 락과 공유 락은 DB에만 존재하는 개념이 아니라 운영체제에서도 사용된다.\n어떠한 파일을 통해서 작업을 하고 있는데 다른 프로세스나 혹은 쓰레드가 같은 파일에 대한 작업을 못하게 막아야하기 때문에 배타 락과 공유 락이 사용된다.</p>\n<p>원래 자바 1.4 이전에는 <strong>파일 락 기능을 제공하지 않았다</strong>고 한다. 이 부분도 운영체제의 기능 중 하나였기 때문이다. 또한, 파일 락은 프로세스들의 접근 자체를 제한하거나 접근하는 방법에 제한을 줘야 했어서 JVM에서 처리가 불가능하기도 했다.</p>\n<p>NIO 패키지에서는 이러한 파일 락 기능을 제공하기 시작했다.</p>\n<ul>\n<li>java.nio.channels.FileChannel.lock()</li>\n</ul>\n<img width=\"755\" alt=\"Screen Shot 2022-03-18 at 18 33 03\" src=\"https://user-images.githubusercontent.com/22961251/159037960-b00de0a5-dd67-4879-8673-f5df4316db0c.png\">\n<h1 id=\"step-4-자바에서의-블록킹-io와-논블로킹-io-차이\" style=\"position:relative;\"><a href=\"#step-4-%EC%9E%90%EB%B0%94%EC%97%90%EC%84%9C%EC%9D%98-%EB%B8%94%EB%A1%9D%ED%82%B9-io%EC%99%80-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-io-%EC%B0%A8%EC%9D%B4\" aria-label=\"step 4 자바에서의 블록킹 io와 논블로킹 io 차이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 4. 자바에서의 블록킹 I/O와 논블로킹 I/O 차이</h1>\n<p>위에서 다뤘던 내용은 대부분 블록킹 I/O에 관련된 내용이었다.  이제 NIO(None-Blocking I/O)에는 블록킹 I/O와 어떤 차이가 있는지 알아보고자 한다.</p>\n<ol>\n<li>자바의 포인터 버퍼 도입</li>\n<li>네티이브 I/O 서비스르 제공해주는 채널 도입</li>\n<li>셀렉터 도입</li>\n</ol>\n<p>위의 3가지가 가장 큰 차이라고 볼 수 있다.</p>\n<h2 id=\"step-41-자바의-포인터-버퍼-도입\" style=\"position:relative;\"><a href=\"#step-41-%EC%9E%90%EB%B0%94%EC%9D%98-%ED%8F%AC%EC%9D%B8%ED%84%B0-%EB%B2%84%ED%8D%BC-%EB%8F%84%EC%9E%85\" aria-label=\"step 41 자바의 포인터 버퍼 도입 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 4.1 자바의 포인터 버퍼 도입</h2>\n<p>블록킹 I/O와  NIO의 가장 큰 차이는 <code class=\"language-text\">Buffer</code> 클래스 도입일 것이다.\n위에서 본 내용 중에서 Java는 JVM 위에서 동작하고, JVM은 하나의 프로세스이기 때문에 I/O가 비효율적이며, 블록킹되며 운영체제가 제공해주는 효율적인 기능들도 사용하지 못했다.</p>\n<p>하지만 NIO에서는 커널에 의해 관리되는 <strong>시스템 메모리를 직접 사용할 수 있는</strong><code class=\"language-text\">Buffer</code> <strong>클래스가 도입되었다.</strong> 물론 <code class=\"language-text\">DirectByteBuffer</code> 에 한정된 것이지만, 이를 통해서 기존 배열로서 처리해야 했던 많은 부분들이 좀 더 효율적이고, 편리하게 다룰 수 있도록 배려해주는 많은 메서드도 제공해주기 시작했다.</p>\n<p>결론적으로 포인터가 자바에도 생겼다고 볼 수 있는데, 이는 다음 포스팅에 NIO를 다루면서 깊게 얘기해보고자 한다.</p>\n<h2 id=\"step-42-네이티브-io-서비스를-제공-채널-도입\" style=\"position:relative;\"><a href=\"#step-42-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C-io-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A5%BC-%EC%A0%9C%EA%B3%B5-%EC%B1%84%EB%84%90-%EB%8F%84%EC%9E%85\" aria-label=\"step 42 네이티브 io 서비스를 제공 채널 도입 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 4.2 네이티브 I/O 서비스를 제공 채널 도입</h2>\n<p>기존 스트림은 단방향이었던 거에 비해서, NIO에서는 채널(Channel)을 도입함으로써 양방향 통신이 가능하게 되었다. 또한, 운영체제에서 제공해주는 네이티브 I/O 서비스들을 이용할 수 있게 되었다.</p>\n<p>채널은 버퍼 클래스와 함께 작업하도록 되어있고 이를 통해서 시스템 메모리인 버퍼에 직접적으로 데이터를 읽거나 쓸 수 있게 되었다. 또한 채널은 위에서 알아본 것처럼 Scatter, Gather를 구현해서 I/O를 보다 효율적으로 처리할 수 있게 되었다.</p>\n<p>정리하자면, 네이티브 I/O 서비스를 이용할 수 있는 채널의 도입과 이로 인해 버퍼 클래스와 함께 작업하는 양방향 통신이 가능해졌다는 것이다.</p>\n<h2 id=\"step-43-셀렉터-도입\" style=\"position:relative;\"><a href=\"#step-43-%EC%85%80%EB%A0%89%ED%84%B0-%EB%8F%84%EC%9E%85\" aria-label=\"step 43 셀렉터 도입 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 4.3 셀렉터 도입</h2>\n<p>위에서 얘기한 내용처럼 버퍼, 채널과 함께 셀럭터라는 개념이 도입되었다.\n셀렉터는 네트워크의 효율을 높이기 위한 것인데 기존 자바 네트워크 프로그래밍에서는 클라이언트 하나당 스레드 하나를 생성해서 처리를 하였는데 이게 비효율적이여서 나중에는 쓰레드 풀을 도입해서 처리하기도 하였다.</p>\n<p>NIO에서는 셀렉터를 이용함으로써 단 한 개의 쓰레드로 수천에서 수 만의 동시 사용자를 처리할 수 있는 서비스를 만들 수 있게 되었다.</p>\n<p>이 또한 NIO 추가 포스팅을 통해서 알아보고자 한다.</p>\n<h1 id=\"step-5-정리\" style=\"position:relative;\"><a href=\"#step-5-%EC%A0%95%EB%A6%AC\" aria-label=\"step 5 정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 5. 정리</h1>\n<p>지금까지 운영체제에서 대략적인 시스템 콜과 시스템 콜이 제일 많이 발생하는 I/O 작업에 대해서 자바에서는 어떻게 처리되는지 그리고 어떻게 발전했는지 알아보았다.</p>\n<p>고전적인 Blocking I/O와 NIO의 차이도 알아보았는데 아마도 다음에는 NIO에 대해서 얘기를 하면서 깊게 들어가볼까 한다.</p>\n<p>대부분의 내용은 <a href=\"https://www.hanbit.co.kr/media/books/book_view.html?p_code=B3301693698\">자바 IO &#x26; NIO 네트워크 프로그래밍</a> 책을 참고하였다.</p>\n<p>운영체제의 내용은 <a href=\"http://www.kocw.net/home/search/kemView.do?kemId=1046323\">KOCW - 이화여대 운영체제</a> 강의 내용이 매우 좋으니 한번 쯤 보기를 권한다.</p>\n<h1 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>REFERENCE</h1>\n<ol>\n<li><a href=\"https://pages.cs.wisc.edu/~remzi/OSFEP/intro-syscall.pdf\">intro-syscall</a></li>\n<li><a href=\"https://www.quora.com/How-does-JVM-makes-system-calls\">How does JVM makes system calls? - Quora</a></li>\n<li><a href=\"https://limdongjin.github.io/concepts/blocking-non-blocking-io.html#ibm-%E1%84%8B%E1%85%A1%E1%84%90%E1%85%B5%E1%84%8F%E1%85%B3%E1%86%AF\">blocking, non-blocking IO, 동기, 비동기 개념 정리 | limdongjin</a></li>\n</ol>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\"><a href=\"https://en.wikipedia.org/wiki/Direct_memory_access\">Direct memory access - Wikipedia</a><a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\"><a href=\"https://witscad.com/course/computer-architecture/chapter/io-communication-io-controller\">I/O Communication and I/O Controller | Computer Architecture</a><a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-3\"><a href=\"https://ko.wikipedia.org/wiki/%EA%B0%80%EC%83%81_%EB%A9%94%EB%AA%A8%EB%A6%AC\">가상 메모리 - 위키백과, 우리 모두의 백과사전</a><a href=\"#fnref-3\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-4\"><a href=\"https://en.wikipedia.org/wiki/Memory-mapped_I/O\">Memory-mapped I/O - Wikipedia</a><a href=\"#fnref-4\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>","frontmatter":{"date":"March 18, 2022","title":"시스템 콜과 자바에서의 시스템 콜 사용례","categories":"개발","author":"개발한입","emoji":"💻"},"fields":{"slug":"/java-syscall-and-io/"}},"prev":{"id":"a7a5771a-6d88-57ce-830a-83e7b19280ba","html":"<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#step-1-bytebuffer\">STEP 1. ByteBuffer</a></p>\n</li>\n<li>\n<p><a href=\"#step-2-channel\">STEP 2. Channel</a></p>\n<ul>\n<li>\n<p><a href=\"#step-21-scatteringbytechannel-gatheringbytechannel\">STEP 2.1 ScatteringByteChannel, GatheringByteChannel</a></p>\n</li>\n<li>\n<p><a href=\"#step-22-filechannel\">STEP 2.2 FileChannel</a></p>\n<ul>\n<li><a href=\"#step-221-filechannel%EC%9D%98-%ED%8A%B9%EC%A7%95\">STEP 2.2.1 FileChannel의 특징</a></li>\n<li><a href=\"#step-222-filechannel%EC%9D%98-%EC%86%8D%EC%84%B1\">STEP 2.2.2 FileChannel의 속성</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-23-socketchannel\">STEP 2.3 SocketChannel</a></p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-3-selector\">STEP 3. Selector</a></p>\n<ul>\n<li>\n<p><a href=\"#step-31-%EA%B8%B0%EC%A1%B4%EC%9D%98-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%AA%A8%EB%8D%B8%EC%9D%98-%EB%8B%A8%EC%A0%90\">STEP 3.1 기존의 네트워크 프로그래밍 모델의 단점</a></p>\n</li>\n<li>\n<p><a href=\"#step-32-%EB%B9%84%EB%B8%94%EB%A1%9D%ED%82%B9-%EB%AA%A8%EB%8D%B8%EA%B3%BC-%EC%85%80%EB%A0%89%ED%84%B0-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC\">STEP 3.2 비블록킹 모델과 셀렉터 동작원리</a></p>\n<ul>\n<li><a href=\"#step-321-selectablechannel\">STEP 3.2.1 SelectableChannel</a></li>\n<li><a href=\"#step-322-selectionkey\">STEP 3.2.2 SelectionKey</a></li>\n<li><a href=\"#step-323-selector\">STEP 3.2.3 Selector</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-4-%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%B1%84%ED%8C%85-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%98%88%EC%A0%9C-%EB%B0%8F-io-%EB%AA%A8%EB%8D%B8\">STEP 4. 간단한 채팅 어플리케이션 예제 및 I/O 모델</a></p>\n<ul>\n<li><a href=\"#step-41-io-%EB%AA%A8%EB%8D%B8\">STEP 4.1 I/O 모델</a></li>\n<li><a href=\"#step-42-%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%B1%84%ED%8C%85-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-io--nio-%EC%98%88%EC%A0%9C\">STEP 4.2 간단한 채팅 어플리케이션 IO &#x26; NIO 예제</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h1 id=\"개요\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EC%9A%94\" aria-label=\"개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개요</h1>\n<p>이전 포스팅 <a href=\"https://brewagebear.github.io/java-syscall-and-io/\">시스템 콜과 자바에서의 시스템 콜 사용례</a> 에서는 시스템 콜이 어떤 것이고, 자바에서 시스템 콜이 주로 발생하는 IO 처리에 대해서 알아보았다.</p>\n<p>이번 시간에는 이전 포스팅에서 다뤘던 문제점들을 자바 NIO가 어떻게 해결하였고, 더 나아가 멀티플렉싱 I/O를 자바에서 어떻게 구현할 수 있는지 알아보고자 한다.</p>\n<p>그리고 결론으로 블록킹 I/O와 논블록킹 I/O를 만든 채팅 어플리케이션 샘플을 보면서 I/O 모델에 대해서 간략히 설명하고자 한다.</p>\n<p>이전 장에 내용을 간략히 복습하자면, 자바 I/O가 느린 고질적인 문제에 대해서 운영체제 수준의 기술(Native I/O)로 향상시킬 수 있다고 하였다. 그러한 기술들을 5가지로 분류하면 다음과 같았다.</p>\n<ol>\n<li>버퍼</li>\n<li>Scatter/Gather</li>\n<li>가상메모리</li>\n<li>메모리 맵 파일</li>\n<li>파일 락</li>\n</ol>\n<p>이렇게 볼 수가 있다. 이제 실제로 NIO에서 위의 기술들을 어떻게 활용하는지 알아보고자 한다.</p>\n<h2 id=\"step-1-bytebuffer\" style=\"position:relative;\"><a href=\"#step-1-bytebuffer\" aria-label=\"step 1 bytebuffer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1. ByteBuffer</h2>\n<p>Buffer에 대한 사용법은 많은 블로그나 인터넷 도처에 널려있으니 구글링을 통해서 학습을 추천한다. 그 중에서 볼만하다고 여겨지는 것은 <a href=\"http://tutorials.jenkov.com/java-nio/buffers.html\">Java NIO Buffer</a> 라는 아티클이다.</p>\n<p>NIO의 모든 기술을 다루고 네티까지 가기에는 시간이 매우 복잡해지므로, 여기서는 바이트버퍼( <code class=\"language-text\">ByteBuffer</code>)에 대해서만 설명하고자 한다.</p>\n<p><strong>왜 바이트버퍼만 다루려고하는 것인가?</strong></p>\n<blockquote>\n<p>바이트버퍼가 시스템 메모리를 직접 사용하는 다이렉트 버퍼를 만들 수 있는 버퍼 클래스이기 때문이다.</p>\n</blockquote>\n<p>그렇다면 <strong>왜? 바이트버퍼만 다이렉트 버퍼로 만들 수 있게 되었을까?</strong></p>\n<blockquote>\n<p>운영체제가 이용하는 가장 기본적인 데이터 단위가 바이트고, 시스템 메모리 또한 순차적인 바이트들의 집합이기 때문이다.</p>\n</blockquote>\n<ul>\n<li>java.nio.ByteBuffer.allocateDirect()</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 22.77777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA2UlEQVQY022NWXLEIAwF5ybBgA1IYPDg2Sv3P1ZP2U4+snx0lVolvXcKITBNE9M47mzuvWcYBqy1DINhMGb3b8yXm3/2J1VFc6H0lfnc2TznjIjsc1nOlLbsN3m7Vf0R8icwpcRaC713pFQkJWIIxLgRkdrwSbDO46zFObc/GvPxC3ME1rmx9CuX54v+elJvd4IWkmRiEmKIpDCR4lHirD9wI85PB27Eb2XWcpplYZaV1hvXz4bWjMx3cnsg84VaOldNrEXIWahyZk4NLRe0PtD2REvnppElC28cI5LWrAF0pQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"allocateDirect()\"\n        title=\"allocateDirect()\"\n        src=\"/static/d7af4ccaa699a6d10dadc3d276f4d4aa/37523/1.png\"\n        srcset=\"/static/d7af4ccaa699a6d10dadc3d276f4d4aa/e9ff0/1.png 180w,\n/static/d7af4ccaa699a6d10dadc3d276f4d4aa/f21e7/1.png 360w,\n/static/d7af4ccaa699a6d10dadc3d276f4d4aa/37523/1.png 720w,\n/static/d7af4ccaa699a6d10dadc3d276f4d4aa/00d43/1.png 1000w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>우리는 해당 메서드를 통해서 기존 <code class=\"language-text\">allocate()</code>  통해서 버퍼를 생성하는 것과 같이 다이렉트 버퍼를 만들 수 있다.</p>\n<p>여기서, 이전 포스팅에서 오류가 있던 점을 알 수 있었는데 나는 자바에서의 시스템 콜 호출순서가 아래와 같다고 설명하였다.</p>\n<p><code class=\"language-text\">JVM -> JNI -> 시스템 콜 -> 커널 -> 디스크 컨트롤러 -> 커널 버퍼 복사 -> JVM 버퍼 복사</code></p>\n<p>하지만 그림으로 예시를 들었던 부분은 이러하였다.</p>\n<p><img src=\"./318E7954-F9A4-41DE-96E5-C73D07CF2623%203.png\" alt=\"java-io-system-call\"></p>\n<p>즉, NIO에서는 위의 플로우가 맞지만, Blocking I/O에서는 (NIO를 제외한 나머지가 모두 Blocking I/O이다.) 데이터가 커널영역에 있는 버퍼로 전송되고, 다시 또 이 버퍼의 값을 JVM의 버퍼로 옮기는 이중 작업이 발생하였다고 했다.</p>\n<p>따라서, 명확히하자면 아래와 같이 수정하는 것이 맞다고 본다.</p>\n<p><code class=\"language-text\">JVM -> 시스템 콜 -> 커널 -> 디스크 컨트롤러 -> 커널 버퍼 복사 -> JVM 버퍼 복사 </code></p>\n<p>NIO의 경우에서 <code class=\"language-text\">ByteBuffer</code> 를 <code class=\"language-text\">allocateDirect()</code> 메서드로 생성할 경우 아래와 같은 플로우로 진행된다.</p>\n<p><code class=\"language-text\">JVM -> 시스템 콜 -> JNI -> 디스크 컨트롤러 -> MMIO</code></p>\n<p>MMIO는 이전 장에서 설명한 가상 메모리 방식이다. 즉, 다이렉트로 시스템 메모리에 복사를 할 수 있다.</p>\n<p>그렇기 때문에 <code class=\"language-text\">ByteBuffer</code> 가 중요한 것이다.</p>\n<p>위의 <code class=\"language-text\">allocateDirect()</code> 메서드를 살펴보면 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">ByteBuffer</span> <span class=\"token function\">allocateDirect</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> capacity<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DirectByteBuffer</span><span class=\"token punctuation\">(</span>capacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>즉 리턴 할 때 <code class=\"language-text\">DirectByteBuffer</code> 를 생성해주는데 이 녀석을 보면 아래와 같이 <code class=\"language-text\">MappedByteBuffer</code> 를 상속받는 놈임을 확인 할 수 있다.</p>\n<p><img src=\"./Screen%20Shot%202022-04-01%20at%2022.39.56%203.png\" alt=\"MappedByteBuffer\"></p>\n<p>따라서, <code class=\"language-text\">ByteBuffer</code> 를 사용하면 우리가 이전 시간에 말했던 <code class=\"language-text\">MMIO</code> 와 <code class=\"language-text\">가상메모리</code> 의 장점을 갖게되고 보다 빠르게 읽고 쓰기가 가능해진다.</p>\n<p>여기서 또 한가지 궁금증이 생길 수 있다.</p>\n<p>그렇다면 <strong>이 시스템 메모리를 어떻게 자바에서 사용가능한가</strong>이다.</p>\n<p>이것도 JNI를 사용해서 처리되는 것일까?</p>\n<p>그것은 아니다 JNI는 초기 시스템 메모리를 할당할때만 사용하고, JNI로 만들어진 시스템 메모리를 <strong>자바 객체로 래핑해서 사용</strong>한다.</p>\n<p>즉, 우리는 래핑된 이 객체를 이용해서 직접적으로 시스템 메모리를 제어할 수 있고, 이것을 실제로 시스템 메모리에 반영된다. 그리고, 이 객체 또한 GC의 관리 대상이기 때문에 GC가 발생하면 래핑하고 있는 주소의 시스템 메모리도 동시에 안전하게 해제되는 것이다.</p>\n<p>공부를 하면서 느낀 점인데 정말 자바는 <strong>추상화</strong> 가 아주 잘된 언어인 것 같다.</p>\n<p>또한, 이 <strong>다이렉트 버퍼가 중요한 점이 한 가지</strong>가 더 있다.\n바로, 뒤에서 볼 <strong>채널(Channel)의 타겟이 되는 것은 다이렉트 버퍼뿐</strong>이라는 것이다.</p>\n<p>논 다이렉트 버퍼를 채널의 타겟으로 설정하면 다음과 같은 일이 발생한다.</p>\n<ol>\n<li>논 다이렉트 버퍼를 채널에 전달</li>\n<li>임시로 사용할 다이렉트 버퍼를 생성</li>\n<li>논 다이렉트 버퍼에서 임시로 만든 다이렉트 버퍼로 데이터를 복사</li>\n<li>임시 버퍼를 사용해서 채널이 저수준 I/O를 수행</li>\n<li>임시 버퍼가 다 사용되면 GC한다.</li>\n</ol>\n<p>운영체제를 공부한 사람이라면 위의 문제가 어떤 문제를 발생하는 지 이해할 수 있을 것이다.</p>\n<p>일단 먼저 딱 봐도 <strong>기존 Blocking I/O와 비슷하게 작업되고 있을 뿐더러 실제 시스템 메모리를 임시로 만들고 해제하는 비용은 당연히 Heap 영역에 국한된 논 다이렉트 버퍼를 만드는 것보다 오버헤드가 상당히 발생</strong>할 것이다.</p>\n<p>그래서 내부적으로 채널의 타켓으로 논 다이렉트 버퍼를 사용하면 결국에는 다이렉트 버퍼를 임시로 만드는 오버헤드가 발생하고, 읽고 쓰기 또한 Blocking I/O와 똑같으므로 사용할 필요가 없으니 다이렉트 버퍼를 사용하는게 좋은 것이다.</p>\n<p>그렇다면 논 다이렉트 버퍼는 사용하지 않아야하는가?</p>\n<p>이건 또 아니다.  소프트웨어 쪽에서는 유명한 명언이 있다.</p>\n<blockquote>\n<p>No Silver Bullet - Essence and Accident in Software Engineering</p>\n</blockquote>\n<p><strong>은총알은 없다</strong>이다. 결국에는 트레이드오프인 것이다.</p>\n<p>하지만, 우리는 위에서 다이렉트 버퍼와 논 다이렉트 버퍼를 비교하면서 힌트를 얻었다.</p>\n<ol>\n<li><strong>다이렉트 버퍼(Direct Buffer)</strong>\n<ul>\n<li>장점 : 읽고 쓰기가 시스템 메모리를 사용하므로 매우 빠르다.</li>\n<li>단점 : 시스템 메모리를 사용하기 때문에 할당 / 해제 비용이 다소 비싸다.</li>\n</ul>\n</li>\n<li><strong>논 다이렉트 버퍼(Non-Direct Buffer)</strong>\n<ul>\n<li>장점 : 시스템 메모리가 아닌 Heap 영역에 생성되기 때문에 할당 / 해제 비용이 보다 저렴하다.</li>\n<li>단점 : 두 번의 버퍼를 거치기 때문에 읽고 쓰기가 느리다.</li>\n</ul>\n</li>\n</ol>\n<p>따라서, 일반적으로 성능에 민감하고 버퍼를 오랫동안 유지해서 사용할 필요가 있을 경우에는 다이렉트 버퍼를 사용하고, 그 외에는 논 다이렉트 버퍼를 사용한다.</p>\n<p>다이렉트 버퍼와 논 다이렉트 버퍼의 차이는 친절하게 자바 스펙에 나와있으니 참고해보자. <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/ByteBuffer.html\">ByteBuffer (Java SE 11 &#x26; JDK 11 )</a></p>\n<h2 id=\"step-2-channel\" style=\"position:relative;\"><a href=\"#step-2-channel\" aria-label=\"step 2 channel permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2. Channel</h2>\n<p><img src=\"./A4E31D91-FF77-40B7-BC47-D03AC22EF297%203.png\" alt=\"Channel\"></p>\n<p>채널은 스트림과 상당히 유사하지만 채널이 <strong>스트림의 확장이나 발전된 형태는 아니다.</strong> 일종의 게이트웨이라 볼 수 있는데 단지 기존의 파일이나 소켓 등에서 사용하던 스트림을 네이티브 IO 서비스를 이용할 수 있도록 도와주는 메서드를 제공한다.</p>\n<p>스트림과 차이점을 위주로 설명해보자면 (여기서 스트림은 자바 8의 스트림 API가 아닌 FileInputStream과 같은 스트림을 의미한다.)</p>\n<ol>\n<li>데이터를 받기 위한 타겟으로 <code class=\"language-text\">ByteBuffer</code> 를 사용</li>\n<li>채널을 이용하면 운영체제 수준의 네이티브 IO 서비스들을 직간접적으로 사용할 수 있다.\n<ul>\n<li>MMIO / 파일 락킹 등</li>\n</ul>\n</li>\n<li>스트림과 달리 단방향 뿐만 아니라 양방향 통신도 가능하다.\n<ul>\n<li>항상 양방향 통신을 사용할 수는 있지 않다\n<ul>\n<li>소켓 채널은 양방향 통신을 지원하지만 파일 채널은 지원하지않는다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p>우리가 다룰 채널은 <strong>파일채널</strong>과 <strong>소켓채널</strong>이다.</p>\n<p>그 전에 이전 포스팅에서 봤던 <code class=\"language-text\">ScatteringByteChannel</code> 과 <code class=\"language-text\">GatheringByteChannel</code> 을 보고자 한다.</p>\n<p>채널의 대부분 클래스들은 인터페이스로 되어있는데 위의<code class=\"language-text\">ScatteringByteChannel</code> 과 <code class=\"language-text\">GatheringByteChannel</code> 도 마찬가지이다.</p>\n<p>이렇게 인터페이스로 사용되는 이유는 확장성이 뛰어나고 유연한 시스템 구조를 갖게되는 점도 있지만, 무엇보다 자바의 핵심 원리인 <strong>WORA(Write Once, Run Anywhere)</strong> 를 이루기 위함이다.</p>\n<p>즉, 운영체제마다 I/O에 관련된 시스템 콜 명령어와 처리 루틴이 다르기 때문에 세부적인 구현은 각 운영체제에 맞춰서 구현하도록 한 것이다.</p>\n<p>그러면 채널과 스트림의 차이와 인터페이스로 구현되어있는 이유를 알아봤으니 다음으로 네이티브 I/O 서비스를 사용하는 <code class=\"language-text\">ScatteringByteChannel</code> 과 <code class=\"language-text\">GatheringByteChannel</code> 를 알아보자.</p>\n<h3 id=\"step-21-scatteringbytechannel-gatheringbytechannel\" style=\"position:relative;\"><a href=\"#step-21-scatteringbytechannel-gatheringbytechannel\" aria-label=\"step 21 scatteringbytechannel gatheringbytechannel permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.1 ScatteringByteChannel, GatheringByteChannel</h3>\n<p>이전 포스트에서 운영체제에서 지원하는 MMIO라는 기술을 알아보았다.</p>\n<p>NIO의 채널에서는 효율적인 입출력을 위해 운영체제가 지원하는 네이티브 IO 서비스인 Scatter/Gather를 사용할 수 있도록 위의 인터페이스를 제공해주고 있다.</p>\n<p>이 인터페이스를 사용함으로써 시스템 콜과 커널 영역에서 프로세스 영역으로 버퍼 복사를 줄여주거나 또는 완전히 없애줄 수 있다.</p>\n<p>실제 코드는 <a href=\"https://github.com/brewagebear/blog-example/blob/main/nio-example/src/main/java/GatheringWriteWithBuffer.java\">blog-example/GatheringWriteWithBuffer.java</a> 와 <a href=\"https://github.com/brewagebear/blog-example/blob/main/nio-example/src/main/java/ScatterBuffer.java\">blog-example/ScatterBuffer</a>를 참고해보자.</p>\n<h3 id=\"step-22-filechannel\" style=\"position:relative;\"><a href=\"#step-22-filechannel\" aria-label=\"step 22 filechannel permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.2 FileChannel</h3>\n<p>파일채널을 파일의 관련된 작업들을 지원하는 채널들로 아래의 특징을 갖고 있다.</p>\n<ol>\n<li>\n<p><code class=\"language-text\">ByteChannel</code> 인터페이스를 구현한다.</p>\n<ul>\n<li>이 인터페이스를 구현하므로 양방향성을 가질 수 있으나 항상 그런 것은 아니다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">AbstactInterruptibleChannel</code> 추상 클래스를 구현하고 있다.</p>\n<ul>\n<li>따라서, 비동기적인 방식으로 채널을 닫을 수 있게 되어 스레드와 채널 간의 상태불일치가 발생하지 않도록 보장해준다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">ScatteringByteChannel, GatheringByteChannel</code> 을 구현한다.</p>\n<ul>\n<li>따라서, 보다 빠른 I/O 수행이 가능하다.</li>\n</ul>\n</li>\n</ol>\n<p>위는 구현에 관련된 특징이라면, 실제로 파일채널들이 갖는 특징은 다음과 같다.</p>\n<ol>\n<li><strong>파일채널은 항상 블록킹 모드이며, 비블록킹 모드로 설정할 수 없다.</strong></li>\n<li><strong>파일채널 객체는 직접 만들 수 없다.</strong></li>\n<li><strong>대부분의 채널처럼 파일채널도 가능하면 네이티브 I/O 서비스를 사용하려한다.</strong></li>\n<li><strong>파일채널 객체는 스레드에 안전하다. (thread-safe)</strong></li>\n</ol>\n<h4 id=\"step-221-filechannel의-특징\" style=\"position:relative;\"><a href=\"#step-221-filechannel%EC%9D%98-%ED%8A%B9%EC%A7%95\" aria-label=\"step 221 filechannel의 특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.2.1 FileChannel의 특징</h4>\n<ol>\n<li><strong>파일채널은 항상 블록킹 모드이며, 비블록킹 모드로 설정할 수 없다.</strong></li>\n</ol>\n<p>이 이유는 운영체제의 기능과 연관이 있는데 현대의 운영체제들은 강력한 캐싱과 프리패치 알고리즘으로 디스크의 I/O를 사용하지만, 비블록킹 모드를 사용할 경우 처리 루틴이 달라져서 이러한 기능들을 사용하는데 제한되기 때문이다.</p>\n<p>그렇다면, 항상 파일채널은 블록킹 I/O로만 써야하는가?</p>\n<blockquote>\n<p>그렇지는 않다. 비동기식 I/O로 처리할 수가 있다.</p>\n</blockquote>\n<p>이는 이 포스팅의 핵심 주제이므로 나중에 같이 정리해보고자한다.</p>\n<ol start=\"2\">\n<li><strong>파일채널 객체는 직접 만들 수 없다.</strong></li>\n</ol>\n<p>파일채널 객체는 이미 열려있는 파일 객체의 팩토리 메서드(<code class=\"language-text\">getChannel()</code>)를 호출해서 생성된다. 따라서, <code class=\"language-text\">FileIntputStream</code> 으로 생성된 채널은 <strong>읽기</strong>만, <code class=\"language-text\">FileOutputStream</code> 으로 생성된 채널은 <strong>쓰기</strong>만 가능하다.</p>\n<ol start=\"3\">\n<li><strong>대부분의 채널처럼 파일채널도 가능하면 네이티브 I/O 서비스를 사용하려한다.</strong></li>\n</ol>\n<p>이는 위에서 상속과 구현관련 특징에서도 있는데 <code class=\"language-text\">ScatteringByteChannel</code> 을 통해서 MMIO가 가능하고 운영체제 네이티브 I/O인 파일락킹 등을 지원한다는 뜻이다.</p>\n<ol start=\"4\">\n<li><strong>파일채널 객체는 스레드에 안전하다. (thread-safe)</strong></li>\n</ol>\n<p>같은 파일채널 인스턴스에 대해 여러 쓰레드들이 동시에 메서드를 호출해도 동기화 문제가 발생하지 않는다.</p>\n<p>이게 가능한 이유는 여러 쓰레드가 접근했을 때 만약 한 쓰레드가 파일 크기 또는 파일채널의 포지션을 변경하는 부분을 수행하는 메서드를 호출하면 다른 쓰레드들은 해당 작업을 마무리할 때까지 기다렸다가 수행하기 때문이다.</p>\n<p>이 부분은 자바 공식문서에도 친절하게 설명되어있다.  <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/channels/FileChannel.html\">FileChannel (Java SE 11 &#x26; JDK 11 )</a></p>\n<p><img src=\"./Screen%20Shot%202022-04-03%20at%2017.37.09%203.png\" alt=\"FileChannel-Thread\"></p>\n<p>이제 파일채널의 중요한 속성들을 알아보고자 한다.</p>\n<h4 id=\"step-222-filechannel의-속성\" style=\"position:relative;\"><a href=\"#step-222-filechannel%EC%9D%98-%EC%86%8D%EC%84%B1\" aria-label=\"step 222 filechannel의 속성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.2.2 FileChannel의 속성</h4>\n<ol>\n<li><strong>파일 락킹(File Locking)</strong></li>\n</ol>\n<p>이전 포스팅에서 말한 바와 같이 공유 락과 배타 락이 있는데, 이 책에 나온 것으로 보면 일부 운영체제는 공유 락을 지원안한다고 하는데 이 책이 쓰인 게 벌써 18년이 지난 얘기로 그냥 뇌피셜로 공유 락은 요즘 다 지원하지 않을까? 생각은 해본다.</p>\n<p>어쨋든 자세한 내용은 이전 포스팅에 달아뒀으니 중요한 특징만 살펴보겠다.</p>\n<ul>\n<li>파일 락킹은 채널이 아닌 파일을 대상으로 하는 것이다.</li>\n<li>동일한 JVM 내부의 여러 스레드 사이가 아닌 외부 프로세스 사이에서 파일의 접근을 제어하기 위함이다.</li>\n</ul>\n<p>파일 락킹의 경우에는 채널에 락이 걸렸을 경우에 <code class=\"language-text\">FlieLock</code> 객체가 리턴이 되며, 이 객체 내부의 메서드들을 통해서 공유 락인지 아닌지(<code class=\"language-text\">isShared()</code>) 락을 해제할 것인지 (<code class=\"language-text\">release()</code>) 등을 처리할 수 있다.</p>\n<p>자세한 사용법은 <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/channels/FileLock.html\">FileLock (Java SE 11 &#x26; JDK 11 )</a> 을 참고해보자.</p>\n<p>그렇다면 예시 코드를 한번 살펴보자.</p>\n<ul>\n<li>파일 락킹 예시</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">FileLocking</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">File</span> file <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/Users/liquid.bear/Downloads/test.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">FileChannel</span> channel <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RandomAccessFile</span><span class=\"token punctuation\">(</span>file<span class=\"token punctuation\">,</span> <span class=\"token string\">\"rw\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getChannel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">FileLock</span> lock <span class=\"token operator\">=</span> channel<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Long</span><span class=\"token punctuation\">.</span>MAX_VALUE<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">boolean</span> isShared <span class=\"token operator\">=</span> lock<span class=\"token punctuation\">.</span><span class=\"token function\">isShared</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Is Shared Lock? : \"</span> <span class=\"token operator\">+</span> isShared<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위의 코드를 보면 <code class=\"language-text\">try-resource</code> 문으로 처리하여 <code class=\"language-text\">release()</code> 를 명시적으로 선언안해줘도 알아서 <code class=\"language-text\">release()</code> 가 된다. 이 부분이 궁금하면 실제 클래스를 까보기를 바란다.</p>\n<p>코드 자체는 채널을 가져오고 락을 걸어서 공유락이지 판단하고 릴리즈까지 하는 일련의 예시 코드라고 볼 수 있다.</p>\n<ol start=\"2\">\n<li>메모리 매핑</li>\n</ol>\n<p>MMIO를 이전 포스팅에서 설명했었다. 파일 채널은 이를 지원을 한다.\n추상 메서드인 <code class=\"language-text\">map()</code> 을 통해서 처리가 된다.</p>\n<p><img src=\"./Screen%20Shot%202022-04-03%20at%2017.48.41%203.png\" alt=\"\"></p>\n<p>이때 인자를 보면 <code class=\"language-text\">MapMode</code> 객체를 받는 것을 확인할 수 있는데 이 객체는 세가지 상수 값을 갖는다.</p>\n<ol>\n<li><code class=\"language-text\">READ_ONLY</code> : 버퍼에서 읽기만 가능한 모드</li>\n<li><code class=\"language-text\">READ_WRITE</code> : 버퍼에서 읽기와 쓰기 모두 가능한 모드</li>\n<li><code class=\"language-text\">PRIVATE</code> : 읽기와 쓰기 둘다 가능하지만 쓰기를 할 경우 복사본을 만들어 변경 내역을 별도로 보관하여 원본 파일에는 적용되지 않는다.</li>\n</ol>\n<p>이렇게 <code class=\"language-text\">map()</code>  메서드를 통해서 MMIO를 구현할 수 있다. 하지만, 주의할 점은 위에서 파일 락킹 같은 경우에는 <code class=\"language-text\">release()</code> 를 통해서 해제되지만, 매모리 매핑은 해제를 할 수 없고, 한번 생성되면 GC가 발생할 때까지 남아있게 된다.</p>\n<p>이렇게 설계 된 이유는 보안문제와 성능문제 때문이라고 한다.</p>\n<p>메모리 매핑의 예시 코드는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">initFileBuffer</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> size<span class=\"token punctuation\">,</span> <span class=\"token class-name\">File</span> file<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">FileNotFoundException</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> bufferCount <span class=\"token operator\">=</span> size <span class=\"token operator\">/</span> FILE_BLOCK_SIZE<span class=\"token punctuation\">;</span>\n    size <span class=\"token operator\">=</span> bufferCount <span class=\"token operator\">*</span> FILE_BLOCK_SIZE<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">RandomAccessFile</span> fileData <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RandomAccessFile</span><span class=\"token punctuation\">(</span>file<span class=\"token punctuation\">,</span> <span class=\"token string\">\"rw\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        fileData<span class=\"token punctuation\">.</span><span class=\"token function\">setLength</span><span class=\"token punctuation\">(</span>size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">ByteBuffer</span> fileBuffer <span class=\"token operator\">=</span> fileData<span class=\"token punctuation\">.</span><span class=\"token function\">getChannel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MapMode</span><span class=\"token punctuation\">.</span>READ_WRITE<span class=\"token punctuation\">,</span> <span class=\"token number\">0L</span><span class=\"token punctuation\">,</span> size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token function\">divideBuffer</span><span class=\"token punctuation\">(</span>fileBuffer<span class=\"token punctuation\">,</span> FILE_BLOCK_SIZE<span class=\"token punctuation\">,</span> fileQueue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre></div>\n<p>어떤 파일의 버퍼를 만드는데 이때 빠른 I/O 처리를 하기 위해서 사용할 수 있다.</p>\n<p>이 예시는 단순한 버퍼 풀을 만든 예제인데 전체 코드는 <a href=\"https://github.com/brewagebear/blog-example/blob/main/nio-example/src/main/java/ByteBufferPool.java\">blog-example/ByteBufferPool</a> 를 참고해보자.</p>\n<ol start=\"3\">\n<li>채널 간 직접 전송</li>\n</ol>\n<p>채널은 버퍼를 거쳐서 처리할 수도 있지만 <strong>채널 사이에서 다이렉트로 데이터를 전송할 수도 있다.</strong></p>\n<p>이런 기능은 <code class=\"language-text\">transTo()</code> 메서드와 <code class=\"language-text\">transFrom()</code> 메서드를 통해서 가능하다.</p>\n<p>그렇다면 속도는 얼마나 빠를지 궁금하다.</p>\n<p>이전 포스팅과 마찬가지로 다양한 버퍼 복사 방식과 채널 직접 전송과의 차이를 비교해보자.</p>\n<ul>\n<li>파일의 크기와 같은 버퍼 사용 시 파일 복사 속도</li>\n</ul>\n<p><img src=\"./Screen%20Shot%202022-04-03%20at%2018.00.02%203.png\" alt=\"\"></p>\n<ul>\n<li>메모리 매핑 사용 시 파일 복사 속도</li>\n</ul>\n<p><img src=\"./Screen%20Shot%202022-04-03%20at%2018.00.48%203.png\" alt=\"\"></p>\n<ul>\n<li>논 다이렉트 바이트 버퍼 사용 시 파일 복사 속도</li>\n</ul>\n<p><img src=\"./Screen%20Shot%202022-04-03%20at%2018.01.56%203.png\" alt=\"\"></p>\n<ul>\n<li>다이렉트 바이트 버퍼 사용 시 파일 복사 속도</li>\n</ul>\n<p><img src=\"./Screen%20Shot%202022-04-03%20at%2018.02.44%203.png\" alt=\"\"></p>\n<ul>\n<li>채널 직접 전송 시 파일 복사 속도</li>\n</ul>\n<p><img src=\"./Screen%20Shot%202022-04-03%20at%2018.03.23%203.png\" alt=\"\"></p>\n<p>이를 통해서 채널 직접 전송 시 파일 복사 속도는 메모리 매핑을 사용하는 것보다 조금 나은 성능을 갖는다고 알 수 있다.</p>\n<p>500MB 파일을 복사하는 것으로 예제 코드를 짰으며, 전체 코드는 <a href=\"https://github.com/brewagebear/blog-example/tree/main/nio-example/src/main/java/nio_copy\">blog-example/nio-example</a>  이곳을 참고해보자.</p>\n<h3 id=\"step-23-socketchannel\" style=\"position:relative;\"><a href=\"#step-23-socketchannel\" aria-label=\"step 23 socketchannel permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.3 SocketChannel</h3>\n<p>이제 얼마 안남았다.\n채널의 양대산맥 중에 하나인 소켓채널에 대해서 알아보고자 한다.</p>\n<p>소켓 채널은 파일 채널과 비교하여 몇 가지 다른 특징이 존재한다.</p>\n<ol>\n<li><strong>비블록킹 모드 지원</strong></li>\n<li><strong>SelectableChannel을 상속해서 Selector와 함께 멀티플렉스 I/O가 가능</strong></li>\n</ol>\n<p>기존 소켓이나 I/O를 통한 네트워크 프로그래밍의 가장 큰 문제는 <strong>블록킹이 된다</strong>는 점이었다.</p>\n<p><strong>이 때문에, 멀티쓰레드 모델을 사용하게 되었지만, 이 모델은 클라이언트당 쓰레드 한 개를 사용해야 하므로 자원을 비효율적으로 사용하게 되었다. 하지만, 많은 클라이언트들이 접속해서 사용해야 될 쓰레드의 개수가 많아지면서 쓰레드 컨텍스트 스위칭 오버헤드가 많아지면서 성능 저하를 가져왔다.</strong> (그래서 현대에서는 쓰레드풀 모델을 사용한다.)</p>\n<p>하지만, 논블록킹 소켓채널이 도입됨에 따라 멀티플렉스 I/O를 지원하는 <code class=\"language-text\">Selector</code> 가 도입되어서 기존의 문제가 해결되었다.</p>\n<p>참고로, 소켓 채널은 별다른 설정을 하지 않으면 기본적으로 <strong>블록킹 모드로 설정</strong>된다.\n따라서 아래와 같이 논블록킹 모드로 바꿔줘야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">SocketChannel</span> socketChannel <span class=\"token operator\">=</span> <span class=\"token class-name\">SocketChannel</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">open</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">InetSocketAddress</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"host ip\"</span><span class=\"token punctuation\">,</span> port<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nsocketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">configureBlocking</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>소켓 채널을 실제 사용해서 간단한 논블록킹 채팅프로그램을 만들었는데 이는 셀렉터를 본 다음 결론에 넣을 예정이니 그때 같이 참고하면 될 것같다.</p>\n<p>이제 대망의 셀렉터를 볼 차례이다.</p>\n<h2 id=\"step-3-selector\" style=\"position:relative;\"><a href=\"#step-3-selector\" aria-label=\"step 3 selector permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3. Selector</h2>\n<p>셀렉터는 리액터(Reactor) 패턴<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>  중에서 리액터의 역할을 하는 놈이다.</p>\n<p>리액터 패턴의 상세한 부분은 주석을 달아놓은 링크를 참고하고, 여기서는 간략하게 설명하고자 한다.</p>\n<p>요즘 날 네트워크 프로그래밍을 하다보면 나오는 개념 중에 하나가 바로 이벤트 주도 아키텍처(Event-driven Architecture)<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup>일 것이다. 리액터 패턴도 그 아키텍처의 구성요소 중에 하나인데, 이 패턴은 이벤트 중심의 어플리케이션이 하나 이상의 클라이언트로부터 하나의 어플리케이션으로 동시에 전달되는 서비스 요청들을 나눠 각 요청에 상응하는 서비스 제공자에게 구별해서 보내준다.</p>\n<p>좀 더 깊게 설명하면, 클라이언트들의 모든 요청을 앞단의 큐에 저장하고 큐를 모니터링하는 스레드에 이벤트를 보낸다. 그러면 큐를 모니터링하는 스레드는 큐에 저장된 요청을 적절한 로직으로 보내서 해당 요청을 처리하게 한다.</p>\n<p>어? 이거 어디서 본 방식 같은데라고 생각할 수 있다. 이러한 방식을 채택해서 개발자에게 제일 친숙한 것이 바로 <strong>Node.js의 이벤트 루프(Event Loop)</strong><sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup> 이다.</p>\n<p><img src=\"./eventloop%203.webp\" alt=\"\"></p>\n<p>이 또한, 따로 찾아보기를 권장하며 (범위를 벗어나기에) 우리가 중점으로 두어야할 내용은 이벤트 주도 아키텍처에서 리액터 패턴이라는 것이 존재하고, 셀렉터는 바로 이 리액터 패턴을 구성하는 요소 중에 리액터를 담당하는 놈이라고 이해하면된다.</p>\n<p>즉, 여러 <code class=\"language-text\">SelectableChannel</code> 의 <code class=\"language-text\">SelectionKey</code>를 자신에게 등록하게 하고 등록된 <code class=\"language-text\">SelectableChannel</code> 의 이벤트 요청들을 나눠서 적절한 서비스 제공자에게\n보내 처리하는 것이다.</p>\n<p>이것을 통해 바로 <strong>멀티플렉스 I/O</strong><sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup>를 가능하게 해준다.</p>\n<p>이제, 기존의 네트워크 프로그래밍 모델의 단점과 셀렉터의 동작원리에 대해서 알아보고자 한다.</p>\n<h3 id=\"step-31-기존의-네트워크-프로그래밍-모델의-단점\" style=\"position:relative;\"><a href=\"#step-31-%EA%B8%B0%EC%A1%B4%EC%9D%98-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%AA%A8%EB%8D%B8%EC%9D%98-%EB%8B%A8%EC%A0%90\" aria-label=\"step 31 기존의 네트워크 프로그래밍 모델의 단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.1 기존의 네트워크 프로그래밍 모델의 단점</h3>\n<p>여기서 말하는 기존 네트워크 프로그래밍 모델은 멀티 쓰레드 모델이다.\n그러나, 쓰레드 풀을 사용하는 모델은 아님을 알고 봐줬으면 좋겠다.</p>\n<p>과거 <code class=\"language-text\">CGI</code> 를 사용하던 시절에는 멀티 쓰레드가 아닌 멀티 프로세스 모델로 각각 프로세스들이 띄워졌었다. 그러나, 프로세스는 쓰레드에 비해 컨텍스트 스위칭 비용이 훨씬 비쌌다. 그래서 자바를 통한 멀티 쓰레드 모델은 각광을 받았었다.</p>\n<p>허나, 이러한 멀티쓰레드 모델도 다음과 같은 문제점을 지녔다.</p>\n<ol>\n<li>\n<p>많은 쓰레드 생성에 따른 스레드 컨텍스트 스위치 부하</p>\n<ul>\n<li>당연히 프로세스보다 쓰레드의 컨텍스트 스위치 비용이 싸긴 하지만 수많은 쓰레드가 쌓였을 경우에는 무시를 못한다.</li>\n</ul>\n</li>\n<li>\n<p>쓰레드 자체가 CPU와 고유 스택을 갖는 데 따른 컴퓨터 리소스 부하</p>\n<ul>\n<li>쓰레드가 프로세스의 문맥자체를 공유하긴 하지만 스택은 별도로 존재하기 때문에 많은 쓰레드가 생길 경우 이 문제도 무시를 못한다.</li>\n</ul>\n</li>\n<li>\n<p>클라이언트의 빈번한 접속과 종료에 따른 많은 가비지 생성 문제</p>\n<ul>\n<li>서버를 통해 주고받는 데이터는 대부분 일회성이다. 이전 포스팅에서 본 내용처럼 두번의 버퍼를 나눠쓰기 때문에 이 과정에서 많은 가비지가 생성이 된다. 그리고 접속이 빈번하면 쓰레드의 생성과 소멸에 따른 가비지도 많을 것이다.</li>\n</ul>\n</li>\n<li>\n<p>클라이언트가 접속할 때마다 매번 쓰레드를 생성하는 부담</p>\n<ul>\n<li>요즘은 쓰레드 풀 모델을 사용해서 이런 문제가 좀 완화되었다고 하지만, 우리가 중점으로 볼 내용은 멀티 쓰레드 모델이므로 1번 요청당 1번 쓰레드가 생성한다 생각하면 많은 부담이 될 수 있다고 느껴진다.</li>\n</ul>\n</li>\n<li>\n<p>서버의 OOM(OutOfMemoryException) 발생 문제</p>\n<ul>\n<li>당연히 수많은 쓰레드가 생기면 OOM이 발생할 수 있다. 그렇기 때문에 <strong>쓰레드 풀 모델이 각광 받은 것</strong>이다. 즉, 1번의 문제(쓰레드 컨텍스트 스위칭)과 5번의 문제(OOM) 때문에 요즘날 쓰레드 풀 모델을 사용한다 생각하면 된다.  그러나, 쓰레드 풀 모델을 사용한다해도 <strong>확장성 문제</strong>는 어쩔 수 없다.</li>\n</ul>\n</li>\n</ol>\n<p>이러한 문제 때문에 비블록킹 모델이 주목받기 시작한 것이다.</p>\n<h3 id=\"step-32-비블록킹-모델과-셀렉터-동작원리\" style=\"position:relative;\"><a href=\"#step-32-%EB%B9%84%EB%B8%94%EB%A1%9D%ED%82%B9-%EB%AA%A8%EB%8D%B8%EA%B3%BC-%EC%85%80%EB%A0%89%ED%84%B0-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC\" aria-label=\"step 32 비블록킹 모델과 셀렉터 동작원리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.2 비블록킹 모델과 셀렉터 동작원리</h3>\n<p>위에서 왜 비블록킹 모델이 탄생했는지 알아보았다.\n이러한 모델을 만들기위한 핵심적인 기능들은 크게 세가지로 볼 수 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 51.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABcSAAAXEgFnn9JSAAABYElEQVQoz42R24rCQAyG5/0fzasiCBUPtcUDta09Wq06yfJlGZHFiw2EdDLpf8i4y+Wi6/Val8ulLhYLTZJE27bV/8T1etUsy3S73WpZlvp4PNTVda23203v97s1pmnSpml0HEfrkXwzRw2zfd/r6XTSzWajURTZPQQOhvl8bkx5nuv5fNb9fm8qAWBoGAY7A/R6vfT5fBp5lmZaVZX1mIPEAZKmqclerVYmHTaG/kZRFAYaQkTsTB8S7706mgRWyBAMoJr9QsYqgl3IUIiDrusMkMo/b0AssbsQ2OTBqCjGGqA4CPboxXGss9lMj8fj7w5hAgglWAYA6Shhl6wjDEMeHg5V9AGGGAyI3TRNUhSFtG0rwzBIVVVS17V953kucRzbnfceK+8kuq6z7PtemqaRcRzF4Xu321nCwi7C4lHK/ecjfOa3cN776HA4REmSWJZlGYlIpKrv5Bx6n/Vb/gARJf1j8usPxQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"68747470733a2f2f77736f322e636f6d2f66696c65732f4553425f322e706e67\"\n        title=\"68747470733a2f2f77736f322e636f6d2f66696c65732f4553425f322e706e67\"\n        src=\"/static/79186cf8d8dfac4223e4bb8e4995dbed/0b533/68747470733a2f2f77736f322e636f6d2f66696c65732f4553425f322e706e67.png\"\n        srcset=\"/static/79186cf8d8dfac4223e4bb8e4995dbed/e9ff0/68747470733a2f2f77736f322e636f6d2f66696c65732f4553425f322e706e67.png 180w,\n/static/79186cf8d8dfac4223e4bb8e4995dbed/f21e7/68747470733a2f2f77736f322e636f6d2f66696c65732f4553425f322e706e67.png 360w,\n/static/79186cf8d8dfac4223e4bb8e4995dbed/0b533/68747470733a2f2f77736f322e636f6d2f66696c65732f4553425f322e706e67.png 500w\"\n        sizes=\"(max-width: 500px) 100vw, 500px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ol>\n<li>\n<p><code class=\"language-text\">Selector</code>  : 리액터 패턴에서 리액터 역할을 해주는 객체</p>\n<ul>\n<li><code class=\"language-text\">SelectionKey</code> 에 등록된 채널들이 발생시킨 이벤트에 대해 적절한 핸들러로 요청을 분기시키는 역할을 한다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">SelectableChannel</code> : 셀렉터에 등록할 수 있는 채널들은 이 클래스를 상속받는다. 우리가 볼 예제는 소켓채널 클래스이므로, 셀렉터에 등록할 수 있다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">SelectionKey</code> : 특정 채널과 <code class=\"language-text\">Selector</code> 사이에서 해당 이벤트에 대한 내용에 대한 정보를 들고 있는다. 이 값을 토대로 이벤트 요청을 처리한다.</p>\n</li>\n</ol>\n<p>위의 내용을 토대로 전체적인 흐름을 보자면</p>\n<ol>\n<li>\n<p>채널을 <code class=\"language-text\">Selector</code>에 등록하면 이 등록에 관련된 채널과 <code class=\"language-text\">Selector</code>와 연관 정보를 갖고 있는 <code class=\"language-text\">SelectionKey</code>가 <code class=\"language-text\">Selector</code>에 저장되고, 리턴된다.</p>\n</li>\n<li>\n<p>위의 <code class=\"language-text\">SelectionKey</code>를 토대로 어떤 채널이 자신이 등록한 모드에 대해 동작할 준비가 되면 <code class=\"language-text\">SelectionKey</code>는 그 준비상태를 내부적으로 저장한다.</p>\n</li>\n<li>\n<p>소켓 서버의 예시를 들자면 클라이언트를 <code class=\"language-text\">accept</code>할 준비가되면 <code class=\"language-text\">SelectionKey</code>는 <strong>준비상태</strong>가 된 것이고, 이 때 <code class=\"language-text\">Selector</code>가 <code class=\"language-text\">select()</code> 메서드를 호출해서 자신에게 등록된 모든 <code class=\"language-text\">SelectionKey</code>를 검사하여 준비상태이면, 하나씩 순서대로 꺼내서 요청한 이벤트에 대해 적절하게 처리한다.</p>\n</li>\n</ol>\n<p>이제 이 동작원리를 토대로 하나씩 살펴보자.</p>\n<h4 id=\"step-321-selectablechannel\" style=\"position:relative;\"><a href=\"#step-321-selectablechannel\" aria-label=\"step 321 selectablechannel permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.2.1 SelectableChannel</h4>\n<p>앞에서 말한 바와 같이 이 <strong>클래스를 상속받은 클래스</strong>만이 셀렉터에 등록이 될 수 있다하였다.</p>\n<p>우리가 살펴 볼  <code class=\"language-text\">SelectableChannel</code> 의 기능은 2가지인데 첫 번째는 소켓채널에서 본 논블록킹 모드 활성화 기능이고 두 번째는 어떻게 셀렉터에 등록하느냐이다.</p>\n<p>첫 번째의 경우에는 소켓채널에서 알려줬으니 두 번째 기능을 알아보고자 한다.</p>\n<p><img src=\"./Screen%20Shot%202022-04-05%20at%2015.18.45.png\" alt=\"\">\n<img src=\"./Screen%20Shot%202022-04-05%20at%2015.19.13.png\" alt=\"\"></p>\n<p>위 두개의 <code class=\"language-text\">register()</code> 메서드를 통해서 채널을 셀렉터에 등록을 할 수 있다.\n세번째 인자인 <code class=\"language-text\">Object att</code> 는 <code class=\"language-text\">SelectionKey</code> 를 다룰 때 설명하고자 한다.</p>\n<p>여기서 <code class=\"language-text\">ops</code> 는 이벤트의 모드라고 볼 수 있다. <code class=\"language-text\">Selector</code>에 등록할 수 있는 이벤트 모드들은 4가지가 있다.</p>\n<ol>\n<li><strong>OP_READ</strong> : 서버가 클라이언트의 요청을 <code class=\"language-text\">read</code> 할 수 있을 때 발생하는 이벤트</li>\n<li><strong>OP_WRITE</strong> : 서버가 클라이언트의 응답을 <code class=\"language-text\">write</code> 할 수 있을 때 발생하는 이벤트</li>\n<li><strong>OP_CONNECT</strong> : 서버가 클라이언트의 접속을 허락했을 때 발생하는 이벤트</li>\n<li><strong>OP_ACCEPT</strong> : 클라이언트가 서버에 접속했을 때 발생하는 이벤트</li>\n</ol>\n<p>위의 이벤트들은 <code class=\"language-text\">SelectionKey</code>에 상수로 등록되어있다.</p>\n<p><img src=\"./Screen%20Shot%202022-04-05%20at%2015.23.28.png\" alt=\"\"></p>\n<p>그래서 아래와 같은 코드로 채널을 셀렉터에 등록할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// 셀렉터 생성</span>\n<span class=\"token class-name\">Selector</span> selector <span class=\"token operator\">=</span> <span class=\"token class-name\">Selector</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">open</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 서버소켓 채널 생성</span>\n<span class=\"token class-name\">ServerSocketChannel</span> server <span class=\"token operator\">=</span> <span class=\"token class-name\">ServerSocketChannel</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">open</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nserver<span class=\"token punctuation\">.</span><span class=\"token function\">configureBlocking</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 논블록킹 모드 활성화</span>\n\n<span class=\"token class-name\">ServerSocket</span> socket <span class=\"token operator\">=</span> server<span class=\"token punctuation\">.</span><span class=\"token function\">socket</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">SocketAddress</span> addr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">InetSocketAddress</span><span class=\"token punctuation\">(</span>port<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nsocket<span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>addr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 소켓 생성 후 해당 주소에 바인드</span>\n\n<span class=\"token comment\">// 셀렉터에 생성된 ServerSocketChannel과 ACCEPT 이벤트 등록</span>\nserver<span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span>selector<span class=\"token punctuation\">,</span> <span class=\"token class-name\">SelectionKey</span><span class=\"token punctuation\">.</span>OP_ACCEPT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </code></pre></div>\n<p>각 채널 구현체마다 등록될 수 있는 이벤트는 다른데 아래와 같다.</p>\n<table>\n<thead>\n<tr>\n<th>채널 구현체</th>\n<th>등록할 수 있는 이벤트</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ServerSocketChannel</td>\n<td>OP_ACCEPT</td>\n</tr>\n<tr>\n<td>SocketChannel</td>\n<td>OP_CONNECT, OP_READ, OP_WRITE</td>\n</tr>\n<tr>\n<td>DatagramChannel</td>\n<td>OP_READ, OP_WRITE</td>\n</tr>\n<tr>\n<td>Pipe.SourceChannel</td>\n<td>OP_READ</td>\n</tr>\n<tr>\n<td>Pipe.SinkChannel</td>\n<td>OP_WRITE</td>\n</tr>\n</tbody>\n</table>\n<p>여러 개의 이벤트를 등록할 수 있는 채널은 아래와 같이 여러개의 이벤트도 등록할 수 있으며, 하나의 셀렉터의 여러개의 채널도 등록할 수 있다.</p>\n<ul>\n<li>하나의 셀렉터에 여러 이벤트와 채널 등록</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Selector</span> selector <span class=\"token operator\">=</span> <span class=\"token class-name\">Selector</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">open</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">SocketChannel</span> channel1 <span class=\"token operator\">=</span> <span class=\"token class-name\">SocketChannel</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">open</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nchannel1<span class=\"token punctuation\">.</span><span class=\"token function\">configureBlocking</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">SocketChannel</span> channel2 <span class=\"token operator\">=</span> <span class=\"token class-name\">SocketChannel</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">open</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nchannel2<span class=\"token punctuation\">.</span><span class=\"token function\">configureBlocking</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">ServerSocketChannel</span> server <span class=\"token operator\">=</span> <span class=\"token class-name\">ServerSocketChannel</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">open</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nserver<span class=\"token punctuation\">.</span><span class=\"token function\">configureBlocking</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nserver<span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span>selector<span class=\"token punctuation\">,</span> <span class=\"token class-name\">SelectionKey</span><span class=\"token punctuation\">.</span>OP_ACCEPT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nchannel1<span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span>selector<span class=\"token punctuation\">,</span> <span class=\"token class-name\">SelectionKey</span><span class=\"token punctuation\">.</span>OP_READ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nchannel2<span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span>selector<span class=\"token punctuation\">,</span> <span class=\"token class-name\">SelectionKey</span><span class=\"token punctuation\">.</span>OP_READ <span class=\"token operator\">|</span> <span class=\"token class-name\">SelectionKey</span><span class=\"token punctuation\">.</span>OP_WRITE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">Set</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">SelectionKey</span><span class=\"token punctuation\">></span></span> keys <span class=\"token operator\">=</span> selector<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">SelectionKey</span> key <span class=\"token operator\">:</span> keys<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">.</span><span class=\"token function\">channel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">+</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">interestOps</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>결과를 살펴보면 아래와 같다.</p>\n<p><img src=\"./Screen%20Shot%202022-04-05%20at%2016.00.29.png\" alt=\"\"></p>\n<p>그림으로 보면 다음과 같을 것이다.</p>\n<p><img src=\".AC194916-DA9B-4690-9652-92D95746040D.png\" alt=\"\"></p>\n<p>셀렉터는 이렇게 이벤트가 발생한 채널들만 선택해서 각 이벤트에 맞는 동작을 하도록 모든 이벤트들에 대한 컨트롤러 역할을 한다.</p>\n<h4 id=\"step-322-selectionkey\" style=\"position:relative;\"><a href=\"#step-322-selectionkey\" aria-label=\"step 322 selectionkey permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.2.2 SelectionKey</h4>\n<p>어떤 채널이 어떤 <code class=\"language-text\">Selector</code>에, 어떤 이벤트 모드로 등록됐는지, 그 등록한 이벤트를 수행할 준비가 되어있는지에 대한 정보들을 담고 있는 객체이다.</p>\n<p>즉, 이벤트 처리에 대해서 <code class=\"language-text\">Selector</code> 와 <code class=\"language-text\">SelectableChannel</code>  사이에서 도와주는 역할을 하는 객체이다.</p>\n<p><code class=\"language-text\">SelectionKey</code> 에는 크게 두가지 집합이 존재한다.</p>\n<ol>\n<li>interest set</li>\n<li>ready set</li>\n</ol>\n<p><strong>interest set</strong>은 위에서 여러 채널과 이벤트를 등록하는 예시 코드를 보여줬는데 이 코드에서<code class=\"language-text\">key.interestOps()</code> 라는 호출부가 존재한다.</p>\n<p>코드를 보면 알겠지만 이 정보들은 <code class=\"language-text\">register</code> 할 때 등록했던 상수들 값이다.\n따라서 <strong>interest set</strong>은 셀렉터에 등록한 이벤트 정보를 담는 집합이라고 알고 있으면 된다.</p>\n<p><strong>ready set</strong>은 <code class=\"language-text\">SelectableChannel</code> 에서 이벤트가 발생하면 그 이벤트들을 저장하는 집합이다.</p>\n<p>즉, <code class=\"language-text\">SelectioKey</code>는 <strong>interest set</strong> 과 <strong>ready set</strong>을 활용하여 이벤트 핸들링을 도와주는 역할을 한다.</p>\n<p><code class=\"language-text\">SelectableChannel</code> 의 <code class=\"language-text\">register()</code> 부분에서 세번째 인자인 <code class=\"language-text\">att</code>\n는 본 챕터에서 설명을 한다고 하였다.</p>\n<p><img src=\"./Screen%20Shot%202022-04-05%20at%2015.19.13%202.png\" alt=\"\"></p>\n<p>이 인자는 <code class=\"language-text\">SelectionKey</code> 에 참조할 객체를 추가하는 메서드고 해당 키에 참조할 객체가 있으면 그 객체를 리턴하고, 없으면 null을 리턴한다.</p>\n<p>이 인자는 <code class=\"language-text\">attachement()</code> 메서드로 가져올 수 있으며, <code class=\"language-text\">register()</code> 로 등록이 가능하지만 <code class=\"language-text\">attach()</code> 메서드로도 등록할 수 있다.</p>\n<p>이 메서드의 사용 이유는 클라이언트마다 특정 세션 값 부여 및 접속을 오래 유지하지 않은 클라이언트에 그 처리를 담당하는 핸들러를 붙여서 사용하는 등의 용도로 사용된다고 한다.</p>\n<p>그러나, <code class=\"language-text\">attach()</code> 메서드로 첨부된 객체는 GC의 대상이 아니므로, <code class=\"language-text\">SelectionKey</code> 가 삭제될 때 같이 삭제해줘야 메모리 릭이 발생안한다.</p>\n<h4 id=\"step-323-selector\" style=\"position:relative;\"><a href=\"#step-323-selector\" aria-label=\"step 323 selector permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.2.3 Selector</h4>\n<p>셀렉터는 위에서 언급한 바와 같이 <strong>등록된 채널들이 발생시킨 이벤트에 대해 적절한 처리 핸들러로 요청을 분기해주는 컨트롤러 역할</strong>을 한다.</p>\n<p>위에서 셀렉터에 대한 내용은 많이 언급했으니 중요한 특징만 설명하고자 한다.</p>\n<p><code class=\"language-text\">Selector</code> 또한 등록된 이벤트를 처리하기 위해서는 자신에게 등록된 채널과 연관된 <code class=\"language-text\">SelectionKey</code> 에 대해서 알고 있어야할 것이다.</p>\n<p>그러므로 <code class=\"language-text\">Selector</code> 내부에는 <code class=\"language-text\">SelectionKey</code> 에 대한 집합을 가지고 있다.\n이 집합은 크게 세 가지이며, <code class=\"language-text\">Selector</code> 내부에서는 아래의 집합들을 관리한다.</p>\n<ol>\n<li><strong>등록된 키 집합(Registered Key Set)</strong>\n<ul>\n<li><code class=\"language-text\">Selector</code> 에 등록된 모든 <code class=\"language-text\">SelectionKey</code> 의 집합이다. 하지만 이 집합에 있는 모든 키가 유효하지는 않다.</li>\n<li>메서드 : <code class=\"language-text\">Selector.keys()</code></li>\n</ul>\n</li>\n<li><strong>선택된 키 집합(Selected Key Set)</strong>\n<ul>\n<li>선택된 키 집합 ⊂ 등록된 키 집합</li>\n<li><code class=\"language-text\">SelectionKey</code> 가 수행 준비상태가 되서 <strong>ready set</strong>이 비어있지 않은 키들이 <code class=\"language-text\">Selector.select()</code> 메서드에 호출되서 선택됐을 때 이 집합에 추가된다.</li>\n</ul>\n</li>\n<li><strong>취소된 키 집합(Cancelled Key Set)</strong>\n<ul>\n<li>취소된 키 집합 ⊂ 등록된 키 집합</li>\n<li>등록을 해제하고 싶을 때 <code class=\"language-text\">SelectionKey.cancel()</code> 메서드로 등록을 취소할 수 있는데 이 키는 바로 유효하지 않은 키로 설정되고 취소된 키 집합에 추가된다.</li>\n</ul>\n</li>\n</ol>\n<p>주의사항으로는 <code class=\"language-text\">Selector</code> 는 쓰레드 세이프하지만, 세 가지 키 집합은 쓰레드 세이프하지 않으므로, 멀티쓰레드 환경에서 이 키에 접근하고자 하면 반드시 <strong>동기화 처리</strong>를 해줘야한다.</p>\n<p>이제 셀렉터의 동작 원리에 대해서 살펴보고자 한다.\n<code class=\"language-text\">Selector</code>는 <code class=\"language-text\">select()</code> , <code class=\"language-text\">poll()</code> 과 같은 시스템 콜을 래핑한 것이다.</p>\n<p>실제 사용 방식은 <code class=\"language-text\">select()</code> 메서드를 호출하면서 사용되는데 다음과 같은 방식으로 동작한다.</p>\n<ul>\n<li><strong>Selector 동작 방식</strong></li>\n<li><strong>취소된 키 집합을 체크한다. ··· ①</strong>\n<ul>\n<li>만약 집합이 비어 있지 않다면\n<ul>\n<li>이 집합에 저장된 각각의 키들은 Selector가 관리하는 세가지 집합에서 모두 삭제되어 각 키와 연관된 채널이 Selector에서 등록이 해제된다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>등록된 키 집합을 체크한다. ··· ②</strong>\n<ul>\n<li>만약 <strong>ready set</strong>이 비어있지 않은 <code class=\"language-text\">SelectionKey</code>가 존재한다면\n<ul>\n<li>등록된 키 집합에 넣는다. (이미 존재한다면 그 키를 업데이트 처리만 한다.)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code class=\"language-text\">Selector</code> <strong>가</strong> <code class=\"language-text\">selectedKeys()</code> <strong>메서드를 호출한다. ··· ③</strong>\n<ul>\n<li>저장된 선택된 키 집합을 가져오고, 그 안에 저장된 <code class=\"language-text\">SelectionKey</code> 의 이벤트 형식에 따라 적절한 핸들러에게 처리를 넘긴다.</li>\n</ul>\n</li>\n</ul>\n<p>① ~ ③의 동작과정을 반복하면서 진행하는데 그 실행 시점과 블록킹 여부 차이만 있다.</p>\n<p><code class=\"language-text\">Selector</code> 가 제공하는 <code class=\"language-text\">select</code> 함수는 총 세가지이다.</p>\n<ol>\n<li>\n<p><code class=\"language-text\">select()</code></p>\n<ul>\n<li>블록킹되는 메서드이며, 선택된 키 집합이 비어있다면 키가 추가될 때까지 블록킹 된다. 그러다가 사용할 수 있는 키가 추가되면 ① ~ ③을 실행한다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">select(long timeout)</code></p>\n<ul>\n<li>밀리세컨드마다 <code class=\"language-text\">select()</code> 함수와 동일하게 처리된다.  따라서, 해당 시간마다 블록킹이 된다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">selectNow()</code></p>\n<ul>\n<li>논블록킹 메서드이다. 따라서 이용 가능한 채널이 없으면 0을 리턴하고, 아니면 마찬가지로 등록된 키 집합안에 들어있는 <code class=\"language-text\">SelectionKey</code>의 개수를 리턴한다.</li>\n</ul>\n</li>\n</ol>\n<p>그리고 추가로, <code class=\"language-text\">wakeup()</code> 메서드는 쓰레드가 블록킹 되어있는 경우 이 블록킹된 쓰레드를 깨우는데 사용한다.</p>\n<p>이제 실제 간단한 채팅프로그램 예시를 통해 기존 네트워크 모델과 어떻게 다른지 더 나아가 I/O 모델이 무엇인지 정리 후에 이 포스팅을 마치고자 한다.</p>\n<h2 id=\"step-4-간단한-채팅-어플리케이션-예제-및-io-모델\" style=\"position:relative;\"><a href=\"#step-4-%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%B1%84%ED%8C%85-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%98%88%EC%A0%9C-%EB%B0%8F-io-%EB%AA%A8%EB%8D%B8\" aria-label=\"step 4 간단한 채팅 어플리케이션 예제 및 io 모델 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 4. 간단한 채팅 어플리케이션 예제 및 I/O 모델</h2>\n<h3 id=\"step-41-io-모델\" style=\"position:relative;\"><a href=\"#step-41-io-%EB%AA%A8%EB%8D%B8\" aria-label=\"step 41 io 모델 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 4.1 I/O 모델</h3>\n<p>자 이제 어떻게 보면 이 포스팅의 핵심 주제로 왔다.\nIO / NIO를 다루면서 자주 했던 말은 블록킹과 논블록킹이었다.</p>\n<p>이것들은 I/O 모델이라는 개념에 속해있다.\n이번 포스팅에서는 4가지 I/O 모델을 다루려고한다.</p>\n<ol>\n<li><strong>블록킹(Blocking) I/O 및 동기(Synchronous) I/O 모델</strong></li>\n<li><strong>논블록킹(Non-Blocking) I/O 모델</strong></li>\n<li><strong>비동기(Asynchronous) I/O 모델</strong></li>\n<li><strong>I/O 다중화(Multiplexing) 모델</strong></li>\n</ol>\n<ul>\n<li><strong>블록킹(Blocking) I/O 및 동기(Synchronous) I/O 모델</strong></li>\n</ul>\n<p><img src=\"./Screen%20Shot%202022-04-05%20at%2023.34.47.png\" alt=\"\"></p>\n<p>위의 그림을 보면 알겠지만 어플리케이션은 커널의 응답이 올 때까지 <strong>블록킹</strong> 된다. (다른 작업을 하지 못한다.)</p>\n<p>이전 포스팅에서 말한 시스템 콜의 예시로 들면 <strong>사용자 모드에서 커널 모드로 전환 후에 작업을 처리하여 다시 사용자 모드로 돌아올 때 까지 작업이 차단</strong>되는 것이다.</p>\n<p>당연히, 우리 똑똑한 어르신들은 이러한 응답을 대기하는 유휴시간이 발생하기 때문에 이 시간을 줄일 수 없을까? 고민을 하게 되었고 그렇게 나온 I/O 모델이 논블록킹 I/O 모델이다.</p>\n<ul>\n<li><strong>논블록킹(Non-Blocking) I/O 모델</strong></li>\n</ul>\n<p><img src=\"./Screen%20Shot%202022-04-05%20at%2023.38.15.png\" alt=\"\"></p>\n<p>논 블록킹은 위에서 보는 바와 같이 시스템 콜이 발생된 뒤에 이 응답이 끝날때 까지 기다리는 것이 아니라 제어권이 다시 어플리케이션에게 전달되는 것을 확인할 수 있다.\n이때 주기적으로 I/O의 처리 가능한 상태를 판단하면서 다른 일을 수행한다.</p>\n<p>폴링 통신 방식과 흡사하다고 생각하면 된다.</p>\n<p>그렇다면, 비동기 I/O 모델이랑은 어떻게 다른 것일까?</p>\n<ul>\n<li><strong>비동기(Asynchronous) I/O 모델</strong></li>\n</ul>\n<p><img src=\"./Screen%20Shot%202022-04-05%20at%2023.42.15.png\" alt=\"\"></p>\n<p>가장 큰 차이점은 논블록킹 I/O 모델처럼 주기적으로 처리 여부를 응답하는 것이 아니라 커널에 시스템 콜을 한 뒤에 어플리케이션은 계속 다른 일을 하다가 커널이 <strong>콜백</strong> 으로 완료여부를 알려준다. 즉, <strong>I/O 처리가 완료가 된 타이밍에 결과를 회신하는 모델</strong>이다.</p>\n<p>차이점을 정리하자면 비동기 I/O 모델은 완료를 했을 때 통지를 하지만 논블록킹 I/O 모델은 처리가 가능한 상태를 판단하면서 처리한다.</p>\n<p>이제 I/O 다중화 모델만 남아있는데 이를 더 잘 이해하기 위해서는 논블록킹 I/O의 단점을 살펴보는 것이 좋다.</p>\n<p>위에서 말한 것과 같이 이는 폴링 방식과 매우 흡사하다고 하였다.\n즉, <strong>시스템 콜이 계속해서 요청될 수 있는 단점이 존재하는 것</strong>이다.</p>\n<p>그래서 옛 성인들께서는 이를 필요할 때만 호출하게끔 하면 더 좋은 성능을 얻을 수 있게 될 것이라고 판단하였다.</p>\n<p>위의 단점이 안 와닿을 수 있기에 스타벅스 사이렌 오더를 만든다 가정해보자.\n이를 논블록킹 서버로 만들었다면, 우리에게 계속 귀찮게 “야 너 주문할 커피 있어?” 라고 알림이 올 것이다.</p>\n<p>하지만, 이를 필요한 시점에만 물어보게끔 할 수 있다면?\n즉, 이벤트를 등록해두는 것이다. “사용자 커피 주문 요청”이라는 이벤트를 등록해두고 없으면 호출을 안하다가 내가 사이렌 오더를 통해서 주문 요청을 하면 이 이벤트가 등록이 될 것이고, 이 때 처리를 하면 될 것이다.</p>\n<p>이게 바로 <strong>I/O 다중화 모델</strong> 이다.</p>\n<ul>\n<li><strong>I/O 다중화 모델</strong></li>\n</ul>\n<p><img src=\"./Screen%20Shot%202022-04-05%20at%2023.54.12.png\" alt=\"\"></p>\n<p>우리가 봤던 <code class=\"language-text\">Selector</code>와 <code class=\"language-text\">SelectionKey</code> 등의 개념을 기억하면서 위의 그래프를 살펴보자.  <strong>select</strong> 시스템 콜은 <code class=\"language-text\">Selector.select()</code> 라고 볼 수 있을 것이며 <strong>data ready</strong> 부분은 <code class=\"language-text\">SelectionKey</code> 의 <strong>ready set</strong> 이 존재하는 경우일 것이다.</p>\n<p>즉, 우리가 공부한 NIO는 <strong>I/O 다중화 모델</strong>을 구현할 수 있는 객체들이다.\n이러한 개념들을 출발하여 오늘날 I/O 모델의 중심이라 볼 수 있는 이벤트 주도 아키텍처(Event-Driven Architecture)나 사가 패턴<sup id=\"fnref-5\"><a href=\"#fn-5\" class=\"footnote-ref\">5</a></sup>등이 탄생하였다고 볼 수 있다.</p>\n<h3 id=\"step-42-간단한-채팅-어플리케이션-io--nio-예제\" style=\"position:relative;\"><a href=\"#step-42-%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%B1%84%ED%8C%85-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-io--nio-%EC%98%88%EC%A0%9C\" aria-label=\"step 42 간단한 채팅 어플리케이션 io  nio 예제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 4.2 간단한 채팅 어플리케이션 IO &#x26; NIO 예제</h3>\n<p>코드는 너무 길다보니 링크로 대체하고 설명을 해보고자한다.</p>\n<ol>\n<li><a href=\"https://github.com/brewagebear/blog-example/tree/main/nio-example/src/main/java/simple_chatting_example/io\">멀티쓰레드 I/O - 채팅프로그램 예제</a></li>\n<li><a href=\"https://github.com/brewagebear/blog-example/tree/main/nio-example/src/main/java/simple_chatting_example/nio\">멀티플렉스 I/O - 채팅프로그램 예제</a></li>\n</ol>\n<p>멀티쓰레드 I/O를 먼저 보면 <code class=\"language-text\">ChatThread</code> 를 통해서 클라이언트와 통신한다.\n클라이언트 쪽을 보면 <code class=\"language-text\">InputThread</code> 와 <code class=\"language-text\">Client</code> 를 분리해뒀는데 이렇게 분리한 이유는 메인 쓰레드가 키보드로부터 입력을 받을 때 블록킹이 발생하므로 <code class=\"language-text\">InputThread</code> 로 입력처리를 나눈 것이다.</p>\n<p>멀티플렉스 I/O를 보면 여기서는 <code class=\"language-text\">ChatThread</code> 하나만 존재한다.\n이는 단순하게 쓰기 작업을 위한 쓰레드이다. 블록킹이 발생하지 않으므로 <code class=\"language-text\">InputThread</code> 는 존재하지 않는다.</p>\n<p>이게 가장 큰 차이라고도 볼 수 있다.</p>\n<p>클라이언트가 입력을 처리하는 부분의 코드 블록만 가져와서 차이를 보자.</p>\n<ul>\n<li>InputThread.java (IO 예제)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">InputThread</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Thread</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Socket</span> socket <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">BufferedReader</span> reader <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">InputThread</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Socket</span> socket<span class=\"token punctuation\">,</span> <span class=\"token class-name\">BufferedReader</span> reader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>socket <span class=\"token operator\">=</span> socket<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>reader <span class=\"token operator\">=</span> reader<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token class-name\">String</span> line <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>line <span class=\"token operator\">=</span> reader<span class=\"token punctuation\">.</span><span class=\"token function\">readLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>line<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> ignored<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>reader <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    reader<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> ignored<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>socket <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    socket<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> ignored<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>Client.java (NIO 예제)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">startReader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Reader is started..\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\">// 셀렉터의 select() 메서드로 준비된 이벤트가 있는지 확인한다.</span>\n                selector<span class=\"token punctuation\">.</span><span class=\"token function\">select</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token class-name\">Iterator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">SelectionKey</span><span class=\"token punctuation\">></span></span> iterator <span class=\"token operator\">=</span> selector<span class=\"token punctuation\">.</span><span class=\"token function\">selectedKeys</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">iterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n                <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">hasNext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token class-name\">SelectionKey</span> key <span class=\"token operator\">=</span> iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">.</span><span class=\"token function\">isReadable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token function\">read</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                    iterator<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            log<span class=\"token punctuation\">.</span><span class=\"token function\">warn</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"start()\"</span><span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre></div>\n<p>원래 기존에 블록킹이 되기 때문에 별도의 쓰레드를 둬서 처리한 부분을 <code class=\"language-text\">Selector</code> 로 처리하여 블록킹이 발생하지 않게 처리가 가능함을 볼 수 있다.</p>\n<p>위의 코드들은 좀 더 나은 코드로 바꾸면서 다음 포스팅에서는 리액터 및 프로리액터패턴과 적용하여 어떤 차이가 있는지 확인해보고자한다.</p>\n<h1 id=\"step-5-정리-및-결론\" style=\"position:relative;\"><a href=\"#step-5-%EC%A0%95%EB%A6%AC-%EB%B0%8F-%EA%B2%B0%EB%A1%A0\" aria-label=\"step 5 정리 및 결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 5. 정리 및 결론</h1>\n<p>초기에 시스템 콜의 사용례를 알아보다가 I/O 쪽에서 많이 쓰인다는 것을 알게되었고,  이를 공부하다보니 동기 I/O, 비동기 I/O, 블록킹 I/O, 논블록킹 I/O 등을 알게되었다.</p>\n<p>그러다가 스프링 웹 플럭스나 네티에 대해서 관심이 좀 있었는데 이번 기회에 논블록킹 I/O가 어떤 것이고, 어떻게 만들 수 있는지에 대해서 정리가 되서 좀 더 이해가 수월하지 않을까 생각이 든다.</p>\n<h1 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h1>\n<ol>\n<li><a href=\"http://tutorials.jenkov.com/java-nio/buffers.html\">Java NIO Buffer</a></li>\n<li><a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/ByteBuffer.html\">ByteBuffer (Java SE 11 &#x26; JDK 11 )</a></li>\n<li><a href=\"https://jongmin92.github.io/2019/03/05/Java/java-reactor-pattern/\">번역 Java Reactor Pattern - 92Hz</a></li>\n<li><a href=\"http://i5on9i.blogspot.com/2013/11/reactor-pattern.html\">쿠…sal: 컴 Reactor Pattern 에 대해 알아보자.</a></li>\n<li><a href=\"https://jeremyko.blogspot.com/2012/05/proactor-design-pattern.html\">쭌안아빠: proactor design pattern (번역)</a></li>\n<li><a href=\"https://riverandeye.tistory.com/entry/1-Reactor-Pattern\">1 Reactor Pattern</a></li>\n<li><a href=\"https://kksuny.tistory.com/19\">Proactor pattern</a></li>\n<li><a href=\"https://sjh836.tistory.com/184\">Reactor Pattern 과 I/O Multiplexing (반응자 패턴, 입출력 다중화, select, epoll, 혼동 포인트, ProjectReactor)</a></li>\n<li><a href=\"https://brunch.co.kr/@myner/42\">리액터패턴 / 프로액터패턴</a></li>\n<li><a href=\"https://github.com/kasun04/nio-reactor\">GitHub - kasun04/nio-reactor: A reference implementation of the Reactor Pattern with Java NIO.</a></li>\n<li><a href=\"http://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf\">http://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf</a></li>\n</ol>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\"><a href=\"https://jongmin92.github.io/2019/03/05/Java/java-reactor-pattern/\">번역 Java Reactor Pattern - 92Hz</a><a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\"><a href=\"https://en.wikipedia.org/wiki/Event-driven_architecture\">Event-driven architecture - Wikipedia</a><a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-3\"><a href=\"https://dev.to/_staticvoid/node-js-under-the-hood-3-deep-dive-into-the-event-loop-135d\">Node.js Under The Hood #3 - Deep Dive Into the Event Loop - DEV Community</a><a href=\"#fnref-3\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-4\"><a href=\"https://www.cs.toronto.edu/~krueger/csc209h/f05/lectures/Week11-Select.pdf\">I/O Multiplexing</a><a href=\"#fnref-4\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-5\"><a href=\"https://microservices.io/patterns/data/saga.html\">Sagas</a><a href=\"#fnref-5\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>","frontmatter":{"date":"April 05, 2022","title":"자바 NIO의 동작원리 및 IO 모델","categories":"개발","author":"개발한입","emoji":"💻"},"fields":{"slug":"/fundamental-nio-and-io-models/"}},"site":{"siteMetadata":{"siteUrl":"https://brewagebear.github.io","comments":{"utterances":{"repo":"brewagebear/blog-comments"}}}}},"pageContext":{"slug":"/https-apply-localhost/","nextSlug":"/java-syscall-and-io/","prevSlug":"/fundamental-nio-and-io-models/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}