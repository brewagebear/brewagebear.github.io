{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/개발",
    "result": {"pageContext":{"currentCategory":"개발","categories":["All","개발","인프라","독서요약"],"edges":[{"node":{"id":"addafc2f-d783-5e3c-9397-e7d16b087547","excerpt":"STEP 1. 서론 STEP 1.1 병렬성과 동시성 STEP 1.2 Run Queue와 Wait Queue STEP 1.2.1 Run Queue STEP 1.2.2 Wait Queue STEP 1.3 리눅스 내에서 기본적인 스케줄링 STEP 1.3.1 프로세스 상태 변화 STEP 1.4 가상 주소 공간 STEP 1.5 MMIO(Memory Mapped I/O) STEP 2. 본론 STEP 2.1 VIRT & RES & SHR STEP 2.2 Memory Commit STEP 2.3 프로세스의 상태 2.4 프로세스의 우선순위 STEP 3. Load Averrage와 시스템 부하 STEP 3.1 CPU Bound vs I/O Bound 개요 최근에 커널 책을 같이 읽고 정리하는 스터디를 시작하였다. 이를 다루기 앞서, 난이도가 조금 있다보니 배경지식이 조금 필요한 것으로 보인다.\n이에 따라, 중요한 개념 몇가지만 짚고 이와 연관된 내용으로 같이 얘기를 해보고자 한다. STEP 1. 서…","fields":{"slug":"/linux-kernel-internal-1/"},"frontmatter":{"categories":"개발 인프라 독서요약","title":"[Kernel] 리눅스 스케줄링 매커니즘과 Load Average","date":"August 23, 2023"}},"next":{"fields":{"slug":"/overview-reactive-system/"}},"previous":null},{"node":{"id":"5c0b255f-8197-5d9a-88fe-29ede82e6c42","excerpt":"STEP 2. 리액티브 시스템과 리액티브 프로그래밍 STEP 2.1 리액티브 시스템이란? STEP 2.2 리액티브 프로그래밍이란? STEP 2.2.1 Blocking I/O에서 Non-Blocking I/O로 STEP 2.2.1.1 블록킹 시나리오 STEP 2.2.1.2 콜백 시나리오 STEP 2.2.1.3 Future 시나리오 STEP 2.2.1.4 CompletableFuture 시나리오 STEP 2.2.2 리액티브 프로그래밍의 특징 STEP 2.2.2.1 명령형 프로그래밍 패러다임 vs 선언형 프로그래밍 패러다임 STEP 2.2.3 리액티브 프로그래밍의 구성 STEP 2.3 리액티브 스트림즈 STEP 2.3.1 리액티브 스트림즈 구성요소 STEP 3. Project Reactor STEP 3.1 Cold Sequence & Hot Sequence STEP 3.1.1 Cold Sequence STEP 3.1.1 Hot Sequence STEP 3.2 Sinks STEP 3.2 …","fields":{"slug":"/overview-reactive-system/"},"frontmatter":{"categories":"개발","title":"리액티브 시스템과 리액티브 스트림즈","date":"August 02, 2023"}},"next":{"fields":{"slug":"/fundamental-jvm-memory/"}},"previous":{"fields":{"slug":"/linux-kernel-internal-1/"}}},{"node":{"id":"5f019a9d-4ba5-5404-8fb7-15a85aac4e66","excerpt":"STEP 1. 자바 메모리 관리 STEP 2. 메모리 영역 STEP 2.1 스택 영역 STEP 2.1.1 지역변수 배열 STEP 2.1.2 피연산자 스택 STEP 2.1.3 프레임 데이터 STEP 2.2 힙 영역 STEP 2.3 번외) 레퍼런스 타입 사용 주의사항 STEP 3. 실행 엔진 STEP 3.1 GC STEP 3.1.1 GC Root Set STEP 3.2 식별 알고리즘 STEP 3.2.1 스탑-더-월드 STEP 3.2.2 레퍼런스 카운팅 STEP 3.3 정리 알고리즘 STEP 3.3.1 기본 정리 알고리즘 STEP 3.3.2 압축-정리 알고리즘 STEP 3.3.3 복제-정리 알고리즘 STEP 3.4 GC 알고리즘 중간 정리 STEP 3.5 Generational Algorithm STEP 3.6 힙의 구조와 GC의 기본 동작 STEP 4. 메서드 영역(메타스페이스 영역) STEP 4.1 자바 8 이전과 이후의 메서드 영역 STEP 4.2 메서드 영역에서의 GC 동작 ST…","fields":{"slug":"/fundamental-jvm-memory/"},"frontmatter":{"categories":"개발","title":"Fundamental of JVM and Memory and GC - Java JVM과 메모리 그리고 GC의 동작 과정 이해","date":"July 15, 2023"}},"next":{"fields":{"slug":"/fundamental-os-page-cache/"}},"previous":{"fields":{"slug":"/overview-reactive-system/"}}},{"node":{"id":"174ae09d-f54c-5e52-9b16-a17b05c7b0c0","excerpt":"STEP 1.1 과거의 이야기 STEP 1.2 번외) NVMe를 스왑 영역으로 잡으면 RAM과 속도가 비슷할까? STEP 2.1 운영체제의 캐시 영역과 스와핑 STEP 2.1.1 캐시영역 STEP 2.1.2 스와핑 STEP 2.1.3 운영체제의 메모리 재할당 방식 STEP 2.2 자바, 페이지 캐시 그리고 가비지 컬렉션 STEP 2.2.1 페이지 캐시와 더티 페이지 동기화 STEP 2.2.2 자바 메모리와 가비지 컬렉션 STEP 3.1 추신 STEP 1. 서론 STEP 1.1 과거의 이야기 STEP 1.2 번외) NVMe를 스왑 영역으로 잡으면 RAM과 속도가 비슷할까? STEP 2. 본론 STEP 2.1 운영체제의 캐시 영역과 스와핑 STEP 2.1.1 캐시영역 STEP 2.1.2 스와핑 STEP 2.1.3 운영체제의 메모리 재할당 방식 STEP 2.2 자바, 페이지 캐시 그리고 가비지 컬렉션 STEP 2.2.1 페이지 캐시와 더티 페이지 동기화 STEP 2.2.2 자바 메모리와…","fields":{"slug":"/fundamental-os-page-cache/"},"frontmatter":{"categories":"개발 인프라","title":"왜 처리량이 중요한 JVM 어플리케이션은 vm.swappiness = 1로 설정하라고 할까?","date":"June 19, 2023"}},"next":{"fields":{"slug":"/overview-streaming-system/"}},"previous":{"fields":{"slug":"/fundamental-jvm-memory/"}}},{"node":{"id":"e998a957-d71c-5e82-94b1-2e6d9da2e186","excerpt":"STEP 1. 분산 시스템(Distribution System)의 대두 STEP 1.1 이벤트 주도 아키텍처(Event-Driven Architecture)란? STEP 1.1.1 메시지(Message)와 이벤트(Event) STEP 1.1.2 이벤트 주도 아키텍처 정리 STEP 2. 스트리밍 시스템 STEP 2.1 Bounded Data vs Unbounded Data STEP 2.2 Stream Proccesing STEP 2.3 스트리밍 시스템 vs 전통적인 아키텍처 STEP 2.3.1 어플리케이션(Application) STEP 2.3.2 백엔드 서비스(Backend Services) STEP 2.3.3 배치 프로세싱(Batch Processing) STEP 2.4 정리 STEP 3. 간단한 스트리밍 시스템 STEP 4. 레퍼런스 개요 벌써, 1년 6개월 정도 진행 중인 스터디가 있다. 각자 읽고 싶은 책을 투표하여 완독을 목표로 하는 스터디로 간단하게 삼색볼펜법을 통해서 …","fields":{"slug":"/overview-streaming-system/"},"frontmatter":{"categories":"개발","title":"스트리밍 시스템 톺아보기","date":"January 09, 2023"}},"next":{"fields":{"slug":"/ligthsail-ci-cd-setup/"}},"previous":{"fields":{"slug":"/fundamental-os-page-cache/"}}},{"node":{"id":"485157c8-d131-526c-b6b1-d59105dae6b1","excerpt":"STEP 1. AWS Lightsail란? STEP 2. AWS Lightsail과 Github를 이용한 CI/CD 파이프라인 구축 예시 STEP 2.1. Spring Boot Application Dockerize STEP 2.1.1. Docker Buildkit STEP 2.2 Lightsail 배포 전 사전 작업 STEP 3. 정리 추신 STEP 4. REFERENCE 개요 이직을 한 후에 너무 바쁘다보니 블로그 포스팅을 신경을 쓰지 못하였다.\n아직도 바쁘긴하지만, 그래도 여유가 조금씩 생기고 있어서 틈틈히 썼던 초안을 다듬어서 올려보려고 노력해보겠다. 이번 포스팅의 내용은 AWS Lightsail와 Github를 통한 CI/CD 구축 예시이다. AWS Lightsail과 Github를 이용한 CI/CD 파이프라인 구축 예시 STEP 1. AWS Lightsail란? STEP 2. AWS Lightsail과 Github를 이용한 CI/CD 파이프라인 구축 예시 STEP 2.1…","fields":{"slug":"/ligthsail-ci-cd-setup/"},"frontmatter":{"categories":"개발 인프라","title":"AWS Lightsail과 Github를 이용한 CI/CD 파이프라인 구축 예시","date":"October 23, 2022"}},"next":{"fields":{"slug":"/concurrency-distributed-transaction-with-tcc/"}},"previous":{"fields":{"slug":"/overview-streaming-system/"}}},{"node":{"id":"c46233c3-14c3-5e14-b09f-add2037e3923","excerpt":"STEP 1. 주문 <-> 재고 서비스에서의 동시성 문제 STEP 1.1 동시성 문제 해결 전략 STEP 1.1.1 낙관적 락(Optimistic Lock) STEP 1.1.2 비관적 락(Pessimitic Lock) STEP 1.1.3 단일 쓰레드 메시지 큐 도입 STEP 2. 분산 트랜잭션(Distributed Transaction)이란? STEP 3.1 최종적 일관성(Eventaul Consistency)란? STEP 3.2 스프링 카프카 예외 처리 및 재시도 매커니즘 개요 사실 분산트랜잭션과 아직 MSA에 대해서는 모르는 부분이 너무나 많다. 이 글을 쓰게된 이유는 주문 <-> 재고 서비스 간의 동시성 제어(Concurrency Control)관련해서 궁금한 점이 생겼고 실제로 이 상황에서 어떻게 처리할 수 있을지 궁금해져서 찾게 되었다. 그러다가 어쩌다 보니 분산 트랜잭션을 구현한 아티클을 보게 되었다. REST 기반의 간단한 분산 트랜잭션 구현라는 글이였고, 작성자인 유…","fields":{"slug":"/concurrency-distributed-transaction-with-tcc/"},"frontmatter":{"categories":"개발 인프라","title":"동시성 문제 해결 전략 - 스프링으로 구현한 TCC패턴","date":"June 11, 2022"}},"next":{"fields":{"slug":"/fundamental-nio-and-io-models/"}},"previous":{"fields":{"slug":"/ligthsail-ci-cd-setup/"}}},{"node":{"id":"a7a5771a-6d88-57ce-830a-83e7b19280ba","excerpt":"STEP 1. 바이트 코드(ByteBuffer) STEP 2. 채널(Channel) STEP 2.1 ScatteringByteChannel, GatheringByteChannel STEP 2.2 파일채널(FileChannel) STEP 2.2.1 파일채널의 특징 STEP 2.2.2 파일채널의 속성 STEP 2.3 소켓채널(SocketChannel) STEP 3. 셀렉터(Selector) STEP 3.1 기존의 네트워크 프로그래밍 모델의 단점 STEP 3.2 비블록킹 모델과 셀렉터 동작원리 STEP 3.2.1 SelectableChannel STEP 3.2.2 SelectionKey STEP 3.2.3 Selector STEP 4. 간단한 채팅 어플리케이션 예제 및 I/O 모델 STEP 4.1 I/O 모델 STEP 4.2 간단한 채팅 어플리케이션 IO & NIO 예제 개요 이전 포스팅 시스템 콜과 자바에서의 시스템 콜 사용례 에서는 시스템 콜이 어떤 것이고, 자바에서 시스템 콜이 주…","fields":{"slug":"/fundamental-nio-and-io-models/"},"frontmatter":{"categories":"개발","title":"자바 NIO의 동작원리 및 IO 모델","date":"April 05, 2022"}},"next":{"fields":{"slug":"/https-apply-localhost/"}},"previous":{"fields":{"slug":"/concurrency-distributed-transaction-with-tcc/"}}},{"node":{"id":"fb3adfe3-bbf4-58e7-8f02-a9ecca8de581","excerpt":"STEP 1. HTTPS란? STEP 1.1 HTTPS Handshake STEP 2. 로컬호스트 환경에 HTTPS 적용하기 STEP 2.1 minica를 이용한 로컬호스트 CA 인증서 발급 STEP 2.2 openssl 및 keytool을 이용한 p12, jks인증서 발급 STEP 2.3 로컬호스트 환경 스프링부트에 HTTPS 적용 확인 STEP 3. REFERENCE 개요 나중에 포스팅해야지 하고 넘어갔던 부분인데 이번에 다른 분께서 질문을 올려주셨어서 포스팅을 해보고자 한다. 제목과 같이  환경에서 HTTPS를 적용하는 것이 주된 목표이고, 확인 절차는 간단하게 스프링 부트를 통해서 작업하였다. MacOS에서 로컬 개발환경에 HTTPS 적용하기 STEP 1. HTTPS란? STEP 1.1 HTTPS Handshake STEP 2. 로컬호스트 환경에 HTTPS 적용하기 STEP 2.1 minica를 이용한 로컬호스트 CA 인증서 발급 STEP 2.2 openssl 및 keyto…","fields":{"slug":"/https-apply-localhost/"},"frontmatter":{"categories":"개발 인프라","title":"MacOS에서 로컬 개발환경에 HTTPS 적용하기","date":"March 25, 2022"}},"next":{"fields":{"slug":"/java-syscall-and-io/"}},"previous":{"fields":{"slug":"/fundamental-nio-and-io-models/"}}},{"node":{"id":"b614bede-83e9-59c1-93bb-7b6881b7d0f9","excerpt":"STEP 1.1 운영체제와 시스템 콜 STEP 2.1 I/O 향상을 위한 운영체제 수준의 기술 STEP 2.1.1 버퍼(Buffer) STEP 2.1.2 Scatter/Gather STEP 2.1.3 가상메모리 STEP 2.1.4 메모리 맵 파일 (Memory-mapped I/O) STEP 2.1.5 파일 락 STEP 4.1 자바의 포인터 버퍼 도입 STEP 4.2 네이티브 I/O 서비스를 제공 채널 도입 STEP 4.3 셀렉터 도입 시스템 콜과 자바에서의 시스템 콜 사용례 목차 개요 STEP 1. 시스템 콜이란? STEP 1.1 운영체제와 시스템 콜 STEP 2. 자바와 시스템 콜 STEP 2.1 I/O 향상을 위한 운영체제 수준의 기술 STEP 2.1.1 버퍼(Buffer) STEP 2.1.2 Scatter/Gather STEP 2.1.3 가상메모리 STEP 2.1.4 메모리 맵 파일(MMIO) STEP 2.1.5 파일 락 STEP 2.2 중간정리 STEP 4. 자바에서의 블록…","fields":{"slug":"/java-syscall-and-io/"},"frontmatter":{"categories":"개발","title":"시스템 콜과 자바에서의 시스템 콜 사용례","date":"March 18, 2022"}},"next":{"fields":{"slug":"/soap-and-wsdl/"}},"previous":{"fields":{"slug":"/https-apply-localhost/"}}},{"node":{"id":"6a4a185e-59a6-54d6-b8e7-2e214c10d7b4","excerpt":"GDS(Global Distribution Systems) SOAP와 WSDL SOAP(Simple Object Access Protocol)란? WSDL(Web Services Description Language) 란? Spring Boot SOAP 예시 XML 스키마 파일 작성 XML 파일을 자바 클래스 파일로 만들기 Endpoint 클래스 및 Config 클래스 실제 테스트 개요 현재, 간단하게 여행 도메인 관련한 토이 프로젝트를 진행하고 있는 상황이다.\n먼저 항공쪽 서비스를 먼저 만들고 있었는데 궁금했던 점은 스카이 스캐너와 같은 서비스에서 어떻게 수 많은 항공사의 정보를 가져오는지 궁금했고, 이 도메인에 대해서 알게된 점과 요청, 응답 스펙에 대해서 알아보고자 한다. GDS(Global Distribution Systems) 수 많은 온라인 여행사(OTA)들이 전 세계의 항공 정보를 가져오고 있다.\n위에 개요에 말한 것 처럼 나는 이게 어떻게 가져오는 지 궁금해졌고, 리…","fields":{"slug":"/soap-and-wsdl/"},"frontmatter":{"categories":"개발","title":"Spring 공식 예제로 알아보는 SOAP와 WSDL","date":"February 17, 2022"}},"next":{"fields":{"slug":"/fundamental-jvm-classloader/"}},"previous":{"fields":{"slug":"/java-syscall-and-io/"}}},{"node":{"id":"ccd2f160-9bde-5736-b66e-498b63f2da3a","excerpt":"STEP 2.1 클래스 로더 시스템 영역(Class Loader System Area) STEP 2.1.1 클래스 로더의 특징(Class Loader’s feature) STEP 2.2 메모리 영역(Runtime Data Area) STEP 2.3 실행 엔진(Execution Engine) 인터프리터 JIT 컴파일러 GC(Garbage Collector) STEP 2.4 클래스 로딩 과정(Class Loading Process) STEP 2.4.1 동적로딩 STEP 2.4.2 로드타임 동적 로딩(load-time dynamic loading) STEP 2.4.3 런타임 동적 로딩(load-time dynamic loading) STEP 4.1 Class Loader를 통한 Hot Swap 예제 STEP 4.2 바이트코드 조작을 통한 Hot Swap 예제 목차 개요 STEP 1. Write Once, Run Anywhere(WORA) STEP 2. JVM 구조 STEP 2.1 클래스…","fields":{"slug":"/fundamental-jvm-classloader/"},"frontmatter":{"categories":"개발","title":"Fundamental of JVM and Class Loader in java - Java JVM과 Class Loader의 동작 과정 이해","date":"December 29, 2020"}},"next":{"fields":{"slug":"/better-logging-with-redis/"}},"previous":{"fields":{"slug":"/soap-and-wsdl/"}}},{"node":{"id":"287f6419-a82a-51e9-8464-09d3be200c24","excerpt":"STEP 1. Redis Write Back을 도입하는 여정기 STEP 1. Redis Collection 설계 및 구현 STEP 2.1 추가 요구사항 STEP 3. 문제점 목차 개요 STEP 1. Redis Write Back을 도입하는 여정기 STEP 2. Redis Collection 설계 및 구현 STEP 2.1 추가 요구사항 STEP 3. 문제점 STEP 4. REFERENCE 개요 현재 재직 중인 회사에서 추천 시스템을 도입하기 위해서 기존의 로깅 방식에 대해서 고도화가 필요했었다. 일단, 아주 단순하게 기존 사용자에게 추천됐던 아이템과 읽은 아이템을 토대로 추천 시스템을 만들고자하였다. 이 업무를 진행하기에 앞서 진행되어야하는 부분이 바로 어떤 아이템들이 추천되었고, 어떤 아이템을 읽었는지에 대한 로그를 수집하는 일이었다. 기존에는 사용자가 클릭을 수행하면 바로 DB에 저장이 되는 형식이였으나 사용자가 증가함에 따라 DB 부하 문제도 있고, 개선책을 찾게 되었다. ST…","fields":{"slug":"/better-logging-with-redis/"},"frontmatter":{"categories":"개발 인프라","title":"To The Moon - 더 나은 로깅시스템을 위한 여정 (Redis 편)","date":"December 29, 2020"}},"next":{"fields":{"slug":"/review-essence-of-object-orientation/"}},"previous":{"fields":{"slug":"/fundamental-jvm-classloader/"}}},{"node":{"id":"71473346-b939-5b1f-9fc7-2698078a9f3f","excerpt":"STEP 1.1 실세계 예시를 통한 객체지향 들여다보기 STEP 1.1.1 요청과 응답으로 구성된 협력 STEP 1.1.2 역할과 책임 STEP 1.2 중간 정리 STEP 2.1 상태와 행동을 함께 지닌 자율적인 객체 STEP 2.2 협력과 메시지 STEP 2.3 메서드와 자율성 객체지향의 사실과 오해 1장 리뷰 STEP 1. 객체지향은 실세계의 모방이다? STEP 1.1 실세계 예시를 통한 객체지향 들여다보기 STEP 1.1.1 요청과 응답으로 구성된 협력 STEP 1.1.2 역할과 책임 STEP 1.2 중간 정리 STEP 2. 협력 속에 사는 객체 STEP 2.1 상태와 행동을 함께 지닌 자율적인 객체 STEP 2.2 협력과 메시지 STEP 2.3 메서드와 자율성 STEP 3. 객체지향의 본질 STEP 4. 객체를 지향하라 개요 이 책을 보고 나서 많은 것들을 깨닫고, 많은 생각을 하게 되었다. 정말 객체지향이란 무엇인지? 에 대해서 가슴에 와닿게 설명해준 책이라 생각한다. 특…","fields":{"slug":"/review-essence-of-object-orientation/"},"frontmatter":{"categories":"개발 독서요약","title":"Book Review - 객체지향의 사실과 오해 1장 리뷰","date":"November 15, 2020"}},"next":{"fields":{"slug":"/review-startup-homework/"}},"previous":{"fields":{"slug":"/better-logging-with-redis/"}}},{"node":{"id":"2d56fc77-4903-5159-a64c-f40e3e42384e","excerpt":"STEP 1.1 콜렉션 리팩토링에 대한 고민 STEP 1.1.1 비즈니스에 종속적인 자료구조 생성 STEP 1.1.2 Collection의 불변성을 보장 STEP 1.1.3 과제에서 활용한 방법 STEP 1.2 인조키와 자연키에 대한 고민 STEP 1.3 JPA 설계에 대한 고민 STEP 2.1 JPA LazyInitializationException 핸들링 STEP 2.1.1 JPA 지연로딩과 즉시로딩 STEP 2.1.2 JPA N+1 문제 STEP 2.1.3 Fetch Join을 통한 트러블 슈팅 STEP 2.2 동일 객체 GroupBy 핸들링 STEP 3.1 정적 팩토리 메소드 리팩토링 관련 STEP 1. 구현 중에 맞딱드린 고민과 해결방법 STEP 1.1 콜렉션 리팩토링에 대한 고민 STEP 1.2 인조키와 자연키에 대한 고민 STEP 1.3 JPA 설계에 대한 고민 STEP 2. 트러블 슈팅 STEP 2.1 JPA LazyInitializationException 핸들링 …","fields":{"slug":"/review-startup-homework/"},"frontmatter":{"categories":"개발","title":"Review after the homework of a Startup - 어떤 스타트업의 과제 전형 참여 후기","date":"November 10, 2020"}},"next":{"fields":{"slug":"/fundamental-of-flutter-widget/"}},"previous":{"fields":{"slug":"/review-essence-of-object-orientation/"}}},{"node":{"id":"046ab165-f7ab-5189-ae06-b420507f5eb2","excerpt":"STEP 2.1 StatelessWidget vs StatefulWiget STEP 2.2 Stateless Widget STEP 2.2 StatefulWidget STEP 2.2.1 State란? STEP 2.3 StatelessWidget과 StatefulWidget 선택 방법 STEP 1. 서론 STEP 2. 본론 STEP 2. StatelessWidget vs StatefulWiget STEP 2.1 StatelessWidget vs StatefulWiget STEP 2.2 Stateless Widget STEP 2.3 Stateful Widget STEP 2.3.1 State란? STEP 2.3 StatelessWidget과 StatefulWidget 선택 방법 STEP 3. 결론 STEP 4. Reference Flutter - Widget, State, BuildContext 그리고 InheritedWidget Part 1 STEP 1. 서론 Flutter 공식팀에서 …","fields":{"slug":"/fundamental-of-flutter-widget/"},"frontmatter":{"categories":"개발","title":"Flutter - Widget, State, BuildContext 그리고 InheritedWidget (Part 1)","date":"April 28, 2020"}},"next":{"fields":{"slug":"/fundamentals-of-javascript/"}},"previous":{"fields":{"slug":"/review-startup-homework/"}}},{"node":{"id":"782cdf08-b721-5fb0-995c-d7c56e001ce1","excerpt":"STEP 1.1 let 키워드 STEP 1.2 호이스팅(Hoisting) STEP 1.3 자바스크립트 실행컨텍스트(JavaScript Execution Context) STEP 1.3.1 생성 단계(Creation Phase) STEP 1.3.2 실행 단계(Execution Phase) STEP 1. ES6 VS ES6 이전 자바스크립트 STEP 1.1 let 키워드 STEP 1.2 호이스팅(Hoisting) STEP 1.3 자바스크립트 실행컨텍스트(JavaScript Execution Context) STEP 1.3.1 생성 단계(Creation Phase) STEP 1.3.2 실행 단계(Execution Phase) STEP 4. Review STEP 5. Reference STEP 1. ES6 vs ES6 이전 자바스크립트 기존의 ES6 이전의 자바스크립트에서는 블록단위의 스코프가 존재하지 않았다. C나 Java등 많은 프로그래밍언어를 했던 사람이라면, for문 안에서 돌아가…","fields":{"slug":"/fundamentals-of-javascript/"},"frontmatter":{"categories":"개발","title":"자바스크립트 동작원리와 ES6 - Fundamentals of JavaScript & ES6","date":"September 09, 2019"}},"next":{"fields":{"slug":"/hello-servlet-request/"}},"previous":{"fields":{"slug":"/fundamental-of-flutter-widget/"}}},{"node":{"id":"636a189c-46f9-5ff6-b3a9-cd3a500e4627","excerpt":"STEP 1.1 RequestDispatcher 클래스 STEP 1.1.2 HttpServletResponse 클래스 STEP 1.1.1.1 HttpServletResponse 예제 소스 STEP 1.1.2 RequestDispatcher 클래스 STEP 1.1.2.1 RequestDispatcher 예제 소스 STEP 1. 포워딩(Forwading)이란? STEP 1.1 HttpServletRequest 클래스 STEP 1.1.1 HttpServletResponse 클래스 STEP 1.1.1.1 HttpServletResponse 예제 소스 STEP 1.1.2 RequestDispatcher 클래스 STEP 1.1.2.1 RequestDispatcher 예제 소스 개요 이번에는 서블릿 WebApplication에서 사용하는 포워딩 기법을 알아보기 위해서, 정리하려고 글을 남겨본다.\n잡설이지만, 원래는 포스팅을 올릴 때 한땀 한땀 쓰려고 노력하고 있는데 요즘에 너무 몰아쓰면서 전반…","fields":{"slug":"/hello-servlet-request/"},"frontmatter":{"categories":"개발","title":"Java Servlet Fowarding - 서블릿 포워딩을 어떻게 구현할까?","date":"July 10, 2019"}},"next":{"fields":{"slug":"/front-controller-and-command-pattern/"}},"previous":{"fields":{"slug":"/fundamentals-of-javascript/"}}},{"node":{"id":"343cceaf-52c2-583c-b523-aba9a0c29c4a","excerpt":"STEP 1.1 디렉토리 패턴 STEP 1.2 확장자 패턴 STEP 2.1 FrontController-pattern STEP 2.2 FrontController-pattern 예제 소스 STEP 3.1 Command-pattern STEP 3.2 Command-pattern 예제 소스 STEP 1. URI-pattern STEP 1.1 디렉터리 패턴 STEP 1.2 확장자 패턴 STEP 2. FrontController-pattern STEP 2.1 FrontController-pattern이란? STEP 2.2 FrontController-pattern 예제 소스 STEP 3. Command-pattern STEP 3.1 Command-pattern이란? STEP 3.2 Command-pattern 예제 소스 STEP 4. Review 개요 MVC 패턴을 통한 Servlet WebApplication을 만들 때 사용하는 주된 패턴 중에 하나이다.\n앞으로 계속해서 서블릿과 JSP…","fields":{"slug":"/front-controller-and-command-pattern/"},"frontmatter":{"categories":"개발","title":"FrontController & Command Pattern - 프론트 컨트롤러와 커맨드 패턴","date":"July 09, 2019"}},"next":{"fields":{"slug":"/spring-triangle/"}},"previous":{"fields":{"slug":"/hello-servlet-request/"}}},{"node":{"id":"0c588027-74a3-5b30-8f05-e3a905c0576a","excerpt":"STEP 1.1 제어 역전(Inversion of Control)이란? STEP 1.2 Bean 등록 방법 STEP 1.3 의존성 주입(DI)란? STEP 2.1 관점 지향 프로그래밍(AOP)란? STEP 2.2 프록시 패턴이란? STEP 2.3 AOP 적용 예제 STEP 3.1 서비스 추상화(PSA)란? STEP 3.2 스프링 트랙잭션 STEP 1. 제어 역전(IoC, Inversion of Control) STEP 1.1 제어 역전(IoC)이란? STEP 1.2 Bean 등록 방법 STEP 1.3 의존성 주입(DI)란? STEP 2. 관점 지향 프로그래밍(Aspect Oriented Programming) STEP 2.1 관점 지향 프로그래밍(AOP)란? STEP 2.2 프록시 패턴이란? STEP 2.3 AOP 적용 예제 STEP 3. 서비스 추상화(Portable Service Abstraction) STEP 3.1 서비스 추상화(PSA)란? STEP 3.2 스프링 트랙잭션 …","fields":{"slug":"/spring-triangle/"},"frontmatter":{"categories":"개발","title":"Java Spring Triangle - 자바 스프링 핵심 3대 요소","date":"July 09, 2019"}},"next":{"fields":{"slug":"/aes-algorithm-and-chiper-mode/"}},"previous":{"fields":{"slug":"/front-controller-and-command-pattern/"}}},{"node":{"id":"0340325e-6f6b-5dd6-9d7f-7c746ff5292d","excerpt":"개요 오랜만에 쓰는 글입니다. 요 근래 정신이 너무 없어서 블로그 글도 못쓰고 있던 찰나에 인턴으로 근무하고 있는 회사에서 맡게 된 업무인 C# 암호화, Java 복호화에 대해서 설명하고자 합니다.  먼저, 저희회사에는 C#과 Java로 만들어지는 프로그램이 있었으며, 저는 그 사이에서 중간 단계 역할을 하는 인터페이스를 만드는 업무를 부여받았습니다. 일단, 인터페이스 이전에 제가 보안에는 문외한이였습니다. \n그래서 우선적으로 C# 암호화 후 Java에서 복호화를 처리하는 샘플 소스코드를 작성하게 됐습니다. AES Algorithms combined with Block Chipher mode in C# and Java STEP 1. 안전한 암호화 방식 STEP 1.1 암호의 종류 STEP 1.1.1 해시함수 STEP 1.1.2 대칭키 암호 방식 STEP 1.1.3 비 대칭키 암호 방식 STEP 1.1.4 정리 STEP 2. AES256 알고리즘이란? STEP 2.1 Dive int…","fields":{"slug":"/aes-algorithm-and-chiper-mode/"},"frontmatter":{"categories":"개발","title":"안전한 암호화를 위한 AES 알고리즘에 대한 이해와 구현코드(Java, C#)","date":"January 16, 2019"}},"next":{"fields":{"slug":"/connect-nginx-with-tomcat/"}},"previous":{"fields":{"slug":"/spring-triangle/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}