{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/concurrency-distributed-transaction-with-tcc/",
    "result": {"data":{"cur":{"id":"c46233c3-14c3-5e14-b09f-add2037e3923","html":"<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#step-1-%EC%A3%BC%EB%AC%B8---%EC%9E%AC%EA%B3%A0-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%97%90%EC%84%9C%EC%9D%98-%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C\">STEP 1. 주문 &#x3C;-> 재고 서비스에서의 동시성 문제</a></p>\n</li>\n<li>\n<p><a href=\"#step-11-%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5\">STEP 1.1 동시성 문제 해결 전략</a></p>\n<ul>\n<li><a href=\"#step-111-%EB%82%99%EA%B4%80%EC%A0%81-%EB%9D%BDoptimistic-lock\">STEP 1.1.1 낙관적 락(Optimistic Lock)</a></li>\n<li><a href=\"#step-112-%EB%B9%84%EA%B4%80%EC%A0%81-%EB%9D%BDpessimitic-lock\">STEP 1.1.2 비관적 락(Pessimitic Lock)</a></li>\n<li><a href=\"#step-113-%EB%8B%A8%EC%9D%BC-%EC%93%B0%EB%A0%88%EB%93%9C-%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90-%EB%8F%84%EC%9E%85\">STEP 1.1.3 단일 쓰레드 메시지 큐 도입</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-2-%EB%B6%84%EC%82%B0-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98distributed-transaction%EC%9D%B4%EB%9E%80\">STEP 2. 분산 트랜잭션(Distributed Transaction)이란?</a></p>\n</li>\n<li>\n<p><a href=\"#step-31-%EC%B5%9C%EC%A2%85%EC%A0%81-%EC%9D%BC%EA%B4%80%EC%84%B1eventaul-consistency%EB%9E%80\">STEP 3.1 최종적 일관성(Eventaul Consistency)란?</a></p>\n</li>\n<li>\n<p><a href=\"#step-32-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%B9%B4%ED%94%84%EC%B9%B4-%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC-%EB%B0%8F-%EC%9E%AC%EC%8B%9C%EB%8F%84-%EB%A7%A4%EC%BB%A4%EB%8B%88%EC%A6%98\">STEP 3.2 스프링 카프카 예외 처리 및 재시도 매커니즘</a></p>\n</li>\n</ul>\n</div>\n<h1 id=\"개요\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EC%9A%94\" aria-label=\"개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개요</h1>\n<p>사실 분산트랜잭션<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>과 아직 MSA<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup>에 대해서는 모르는 부분이 너무나 많다.</p>\n<p>이 글을 쓰게된 이유는 주문 &#x3C;-> 재고 서비스 간의 동시성 제어(Concurrency Control)<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup>관련해서 궁금한 점이 생겼고 실제로 이 상황에서 어떻게 처리할 수 있을지 궁금해져서 찾게 되었다.</p>\n<p>그러다가 어쩌다 보니 분산 트랜잭션을 구현한 아티클을 보게 되었다.</p>\n<p><a href=\"https://github.com/YooYoungmo/article-tcc\">REST 기반의 간단한 분산 트랜잭션 구현</a>라는 글이였고, 작성자인 유영모님께서 아주 자세한 설명이 담긴 아티클과 예제 코드를 공유를 해주셔서 이를 기반으로 설명해보고자 한다.</p>\n<p>대부분의 내용은 오히려 유영모님의 TCC 패턴 시리즈 글을 보는 것이 도움이 될 것이라고 생각한다.</p>\n<ol>\n<li><a href=\"https://www.popit.kr/rest-%EA%B8%B0%EB%B0%98%EC%9D%98-%EA%B0%84%EB%8B%A8%ED%95%9C-%EB%B6%84%EC%82%B0-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B5%AC%ED%98%84-1%ED%8E%B8/\">REST 기반의 간단한 분산 트랜잭션 구현 - 1편</a></li>\n<li><a href=\"https://www.popit.kr/rest-%EA%B8%B0%EB%B0%98%EC%9D%98-%EA%B0%84%EB%8B%A8%ED%95%9C-%EB%B6%84%EC%82%B0-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B5%AC%ED%98%84-2%ED%8E%B8-tcc-cancel-timeout/\">REST 기반의 간단한 분산 트랜잭션 구현 - 2편 (TCC Cancel, Timeout)</a></li>\n<li><a href=\"https://www.popit.kr/rest-%EA%B8%B0%EB%B0%98%EC%9D%98-%EA%B0%84%EB%8B%A8%ED%95%9C-%EB%B6%84%EC%82%B0-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B5%AC%ED%98%84-3%ED%8E%B8-tcc-confirmeventual-consistency/\">REST 기반의 간단한 분산 트랜잭션 구현 - 3편 TCC Confirm(Eventual Consistency)</a></li>\n<li><a href=\"https://www.popit.kr/rest-%EA%B8%B0%EB%B0%98%EC%9D%98-%EA%B0%84%EB%8B%A8%ED%95%9C-%EB%B6%84%EC%82%B0-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B5%AC%ED%98%84-4%ED%8E%B8-rest-retry/\">REST 기반의 간단한 분산 트랜잭션 구현 - 4편 REST Retry</a></li>\n</ol>\n<p>이렇게 잘 설명된 글이 존재하는데 나는 어떤 글을 쓸 것인지 궁금해할 것이다.</p>\n<p>이번에 내가 다루고자하는 내용은 아래와 같다.</p>\n<ol>\n<li>동시성 문제가 발생한 이유</li>\n<li>해결 방법</li>\n<li>분산 트랜잭션은 무엇인지</li>\n<li>메시지를 소비할 수 없는 상황에서 처리할 수 있는 방법</li>\n</ol>\n<p>어려운 내용이다보니 틀린 내용이 많을 수도 있다.\n이 부분 감안하고 봐주시면 좋을 것 같다.</p>\n<h1 id=\"동시성-문제-해결-전략---스프링으로-구현한-tcc패턴\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5---%EC%8A%A4%ED%94%84%EB%A7%81%EC%9C%BC%EB%A1%9C-%EA%B5%AC%ED%98%84%ED%95%9C-tcc%ED%8C%A8%ED%84%B4\" aria-label=\"동시성 문제 해결 전략   스프링으로 구현한 tcc패턴 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동시성 문제 해결 전략 - 스프링으로 구현한 TCC패턴</h1>\n<ul>\n<li>STEP 1. 주문 &#x3C;-> 재고 서비스에서의 동시성 문제\n<ul>\n<li>STEP 1.1 동시성 문제 해결 전략\n<ul>\n<li>STEP 1.1.1 낙관적 락(Optimistic Lock)</li>\n<li>STEP 1.1.2 비관적 락(Pessimitic Lock)</li>\n<li>STEP 1.1.3 단일쓰레드 메시지 큐 도입</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>STEP 2. 분산 트랜잭션(Distributed Transaction)이란?</li>\n<li>STEP 3. 카프카를 사용한 TCC 패턴 적용\n<ul>\n<li>STEP 3.1 최종적 일관성(Eventaul Consistency)란?</li>\n<li>STEP 3.2 스프링 카프카 예외 처리 및 재시도 매커니즘</li>\n</ul>\n</li>\n<li>STEP 4. REFERENCE</li>\n</ul>\n<h2 id=\"step-1-주문---재고-서비스에서의-동시성-문제\" style=\"position:relative;\"><a href=\"#step-1-%EC%A3%BC%EB%AC%B8---%EC%9E%AC%EA%B3%A0-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%97%90%EC%84%9C%EC%9D%98-%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C\" aria-label=\"step 1 주문   재고 서비스에서의 동시성 문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1. 주문 &#x3C;-> 재고 서비스에서의 동시성 문제</h2>\n<p>이커머스 시스템을 단순화해서 생각해보자. 실제 비지니스 환경에서는 아래와 같이 진행될 것이다.</p>\n<ol>\n<li>사용자가 장바구니 담음</li>\n<li>사용자 결제 요청</li>\n<li>주문서 데이터 생성</li>\n<li>재고 처리</li>\n<li>결제 처리</li>\n</ol>\n<p>여기 흐름에서 궁금한 점은 만약 재고 처리하는 도중에 결품인 것을 확인된다면? 결제는 성공했는데 어떻게 처리할지 등이 궁금할 것이다.</p>\n<p>일단 이를 이해하기 앞 서 간단하게 주문 재고 서비스를 만든다고 가정하자.</p>\n<p>그렇다면, 주문이 되면 재고 서비스에 해당 상품의 재고값을 업데이트하는 식으로 처리할 수 있을 것이다.</p>\n<p>하지만, 멀티쓰레드 환경에서 하나의 상품에 대해서 다량의 주문 요청이 들어올 경우에 갱신분실(Lost Update) 문제가 발생 할 수 있다.</p>\n<p>예시 시나리오를 한번 봐보자.</p>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 53.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACUUlEQVQoz51SXUtUURS9/yqyfI2MCkwHQhHyQaJCKioKHwzrrcAeUrCih7CHUkkoHWl0UPMDJU0jzVEStDFn1Jm51/t17j3n7L3izodCjy1Y7POw9mKtwzYgHRsINQAFkCrNEvmfecxIx+U3K6YidqSUVcbdZBZXhjPcPu+hd5PROi1w7YvA+00BvdaGg4VWhD/b8O6XwPWpAK3TPno3gfZFhRuTLh5+I2hGFAhaU9xoSDhc3Z/j2qECP16SfHrQ5hMDNj9ddjiYu8BbI6fYmz3PT5ZMrvpgcfWgzR3LzJdGQz7Zl+O6pOJAg5gZmmjSQGAC8BlFhPgPRLulhETjRlN8H2f6d7l51ELnD4mLcRs1n1y8WDGB1UbkZmqRmYwhP1cHbLTg2UqAc3EPsaTA7SWgMemj5qOpO1cjS5owbk25aBx1+OaMQE9Ko2HMRSzh4c26DaSuwvrahIO5Zhwk6xBMNaFr4RCxEReX+zO4k7DQMuagftjU3WtUMiyGFhbDswAE5QbyqEsF6Z5FzNe/ht03C+zsY7ulG9v33pZWKpWVmjCU0hC+YNt24Bxa8H0PWgYgIrAKygwhbAt+IYfAD6FCBQolvM9DyL/s4vyr5zpYX4sCjBusdTGI5/uc3dtDJpuB5x5CaX2UkImQ/72F7EYKdnobmhgBK+wP9CL96AH/6bhP4vtiJJ0wQBoV0whmoYC9bBau6yA6hSKJoiOLOgFEEGYBu+sp5HfSlTVVrCxlwojEkWGJ6vjnIiOtj0kVUtlYA4EAC8EchiAZ+lKps38BoGUYtUylGy4AAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"lost update\" title=\"lost update\" src=\"/static/4ea080f3ae40e8d02149db28ea05ebf5/37523/lost-update.png\" srcset=\"/static/4ea080f3ae40e8d02149db28ea05ebf5/e9ff0/lost-update.png 180w,\n/static/4ea080f3ae40e8d02149db28ea05ebf5/f21e7/lost-update.png 360w,\n/static/4ea080f3ae40e8d02149db28ea05ebf5/37523/lost-update.png 720w,\n/static/4ea080f3ae40e8d02149db28ea05ebf5/302a4/lost-update.png 1080w,\n/static/4ea080f3ae40e8d02149db28ea05ebf5/07a9c/lost-update.png 1440w,\n/static/4ea080f3ae40e8d02149db28ea05ebf5/033f0/lost-update.png 3536w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em>그림 1. 갱신 분실</em>\n</p>\n<p>위의 그림처럼 <strong>트랜잭션 A가 트랜잭션 B</strong> 전에 미리 처리가 된다면, 재고 값을 2에서 1로 업데이트하려고 하기 때문에 갱신 분실이 발생한다.</p>\n<p>이를 해결하는 방법은 여러가지가 있을 것이다. 그 중에서 낙관적 락(Optimistic Lock)<sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup>, 비관적 락(Pessimistic Lock)<sup id=\"fnref-5\"><a href=\"#fn-5\" class=\"footnote-ref\">5</a></sup>이 대표적일 것이다.</p>\n<p>이번 챕터에서는 이러한 처리 방법의 장단점을 알아보고 메시지 큐를 통해서 처리하는 방법등을 알아보고자 한다.</p>\n<h2 id=\"step-11-동시성-문제-해결-전략\" style=\"position:relative;\"><a href=\"#step-11-%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5\" aria-label=\"step 11 동시성 문제 해결 전략 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.1 동시성 문제 해결 전략</h2>\n<h3 id=\"step-111-낙관적-락optimistic-lock\" style=\"position:relative;\"><a href=\"#step-111-%EB%82%99%EA%B4%80%EC%A0%81-%EB%9D%BDoptimistic-lock\" aria-label=\"step 111 낙관적 락optimistic lock permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.1.1 낙관적 락(Optimistic Lock)</h3>\n<p>먼저, 낙관적 락이다.</p>\n<p>낙관적 락은 MVCC(Multi Version Concurrency Control)<sup id=\"fnref-6\"><a href=\"#fn-6\" class=\"footnote-ref\">6</a></sup>처럼 버전을 명시하는 방식이다.\n이를 위해서 먼저, MVCC에 대해서 간략하게 이해를 하고 넘어가야할 필요가 존재한다.</p>\n<p>DB 벤더는 Mysql 기준으로 설명하도록 하겠다.</p>\n<p>MVCC는 Mysql InnoDB 스토리지 엔진 사용 시 언두로그를 활용하여 레코드 마다 여러개의 버전(Multi Version)을 동시에 관리하는 것을 뜻한다.</p>\n<p>이를 통해서 Mysql은 잠금없는 일관된 읽기(Non-Locking Consistent Read)를 구현한다.\n용어가 어려울 수 있는데 INSERT와 연결되지 않은 순수한 읽기는 다른 트랜잭션의 작업과 관계없이 항상 잠금을 대기하지 않고 읽는다는 뜻이다.</p>\n<p>즉, 어떤 트랜잭션에서 서울이라는 값을 경기로 업데이트 한 후 아직 커밋을 안했더라도 변경 전 값인 ‘서울’을 언두로그에 읽어서 일관되게 읽게끔 하는 방식이다.</p>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 406px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 114.44444444444446%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAYAAAALHW+jAAAACXBIWXMAABYlAAAWJQFJUiTwAAACBklEQVQ4y6WVyaryQBCF8+ouxJWP4cIHcCeIK0EF51lwxnmex/r5CtobY6L38jc0lY6d0+fUqS4t+TIej4fG2+0mx+Px5Z3bsL4B3u93jfV6XSKRyBPQC9T6xszE2WwmnU5HLpfLC6gT2PICMxsNw8ViIaPR6O3AXzF0smMcDgdlORgMZDqdekr/KhmZlUpFwZjj8ViWy+XfAO0bS6WSxONxaTQasl6v3/bY9xItJ4D9mbwNh0Nl1mw2le1qtXoa46bIcjvJDKSRL5j1+30FJpfUJL9tNhuN1+v1laGz7oyzu91OWe73e3V4MpkoCOter6fseccBT8Dz+SypVEqlcBOy2ayk02kFIm/JZFJyuZzuiUajkkgk1GkKPZ/PK/PT6fQDiIRMJiPz+Vza7bZUq1Wp1WoaQ6GQBAIBCQaD4vf7xefzSTgc1o9hzEGxWOzFdYsEk2xzT+0D1sYUpMGqXC4/5bKGiEmRAtrdNfljskY28vjIyMQkcosRxowXl503w+427gJGhCEySZET6KUO3YrTPCMZlkSYAQg7Z4N4Y+hVpIB1u93nHW61WsrWDvin5kDNIXm73apkzMC8j4DGDEPfbgofA0akKRSLRQVz60a/7thuzD/2Q1yjHKgrqr5QKGi7ot7oNNwWpv16fWTItUEOTppCxgzeMckha3vx/teflJdkL8B/ITL1sLp3ZJoAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"mvcc\" title=\"mvcc\" src=\"/static/2cf69e7ffd345d363b2c3c71945588cc/e33ef/mvcc.png\" srcset=\"/static/2cf69e7ffd345d363b2c3c71945588cc/e9ff0/mvcc.png 180w,\n/static/2cf69e7ffd345d363b2c3c71945588cc/f21e7/mvcc.png 360w,\n/static/2cf69e7ffd345d363b2c3c71945588cc/e33ef/mvcc.png 406w\" sizes=\"(max-width: 406px) 100vw, 406px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em>Real MySQL 8.0, p.103, 백은빈, 이성욱 저</em>\n</p>\n<p>낙관적 락은 MVCC와 비슷하게 처리된다. 버전을 통해서 위의 상황같이 동시에 작업이 들어와도 Version이 다를 경우에는 트랜잭션이 어보트되서 갱신분실을 막을 수가 있다.</p>\n<p>MVCC와 낙관적 락의 어떻게 보면 문제 해결 전략자체는 비슷하다고 볼 수 있으나 MVCC는 언두 레코드 자체에 잠금을 걸 수 없는 문제가 있어서 순수한 읽기가 아닌 <code class=\"language-text\">SELECT ~ FOR UPDATE</code> 와 같은 구문에는 원본 레코드의 값을 가져와서 팬텀 리드가 발생할 수 있다.</p>\n<p>아래와 비슷하게 처리된다고 볼 수 있다.</p>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 642px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 98.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAABYlAAAWJQFJUiTwAAACTElEQVQ4y42UW29BURCF/XESwpsX0b8gHjwhHiReELcUIXGNllKXFqV1qbtpvp3sk6Ol7STbPkf2WbNmzZpt2W63slgsZL1ey3K5lM/PTyHO57NaOvS7/u90Oqnv+Ga1Wqn9cDiIZTKZSDqdlpeXF7X6/f4PgO9LR7FYlEqlIm9vbzIYDGQ+n4vl/f1dqtWqNJtN9ScJNOCt2O12ilW9XpdSqSRPT08yHA5ls9mIRR8ajUYX5RH7/V6m06liQGLk4KPZbKYA2KlIkyAsWo/xeGxoQ6CPx+MRu90uNptNrFaruN1uabVahm6dTkeV/PHxYRAxAF9fXy/Y0SQ0SiQSEolEJJvNSjwel4eHBwUGAdg9Pj4q7W4CmuN4PKqyKAk3IAHlAwhTGKI9ZwxAzajdbsvz87PqNCUA4vP5xOv1yt3dnVq8ox32QEt2ElwFrNVqks/nVUl0jz0Wi0kwGBS/3y+hUEjC4fBF8wga9aNkHtBDG5ySyJzL5SQajUogEJBkMqk0pOvm5nH2gqHO1Ov11GGykZVO3t/fq2ZkMhm1s8wdvQnIA4CA8YFmeivME3MV0OzD/8S/AL/7EMvgsVQqpUqmfKyCfcxBJb/6UIvNqDEZLpdLTYvD4RCn0ymNRsO4XWgkjuDsnwxhwmWBcWHX7XaVkQGBERJhtXK5fMmQHwAxtJkhgDQKRoVCQd0oeJMklMl5ABnPq7bRf/7WCHTl6iIZZTMt2moGIDYBjIxMAaPFM0x4RwrK/MtGBqCeDMysPah3vRAdZrducjPoF50R5n4raqjCAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"phantom read\" title=\"phantom read\" src=\"/static/67bd98f2fc9f679c7281ff5ce37a4f18/1bba8/phantom-read.png\" srcset=\"/static/67bd98f2fc9f679c7281ff5ce37a4f18/e9ff0/phantom-read.png 180w,\n/static/67bd98f2fc9f679c7281ff5ce37a4f18/f21e7/phantom-read.png 360w,\n/static/67bd98f2fc9f679c7281ff5ce37a4f18/1bba8/phantom-read.png 642w\" sizes=\"(max-width: 642px) 100vw, 642px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em>Real MySQL 8.0, p.182, 백은빈, 이성욱 저</em>\n</p>\n<p>그렇다면 낙관적 락은 어떻게 처리되는가?</p>\n<p>실제로 버전 컬럼이 존재하고, 이 버전을 토대로 트랜잭션이 진행되는데 먼저 진행된 트랜잭션으로 인해 버전이 변경되었고, 다음 트랜잭션은 이전 버전을 기준으로 수행 되기때문에 이 트랜잭션은 어보트된다.</p>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 53.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACXklEQVQoz51STWsTURSdvTsX3bkRxJ8gVrsUrKigJWitXaiUolKwdNeFIrhS1IUf1I1Q3GhbrFhISkyaxtia2m9obC0Wv6qZScbJZD5f5r13j8w0TdGlBw738R6ce869T4GtW/BNwU2NgxgH0CD9U3coOUD1M3GSETaDIGhW+nMGLo6XqG+ihMF1gZ4pH5ff+nix4UOs9qM814Pax348/+zjSo6h552HZxvA9XmOq1kHNxYkBEEAgBAyrrQnbWoZ0elM0qFbS4IOj1bpwIhFd5ZsYvkT9DVxiNzp43R7sULNL01qGbXo5hLR6Tc1OjikU1uaExOQRAQhZVYBqwDCIrg6AAf/AQrNRQ6lzCid8RKODP2k9jEVd5cZTiZstI45eLJSAQod0KdOoZiN4Xe+DVjvwv0VhmNxF7G0j95FoCPtofV1RdwrhJJyUrmWc3A+ZVPv+xoG1iTOpRzEki4GP1nAWjfM2U6U8xdQTreB5TrxcK6KWMLB2eEi+lI2ujIeYuOWeLRWF4xM+ybBrQBg9QRBI8s2fgzMYyb2FNbwNPBdxbdLD/Cl+zGwqWErsgyXMqlwLuB7PlmWDbtqwvNciIBBSgnirEHfNODqJTCXQYZe6g0p+jcQohZASpFRSIjIiOt5pGoaimoRrlMFF6LhMNygvlrAr5kpmAsfYGVTMCbiMDLjMFIJEiVNRoE5n1QgBbZFQ1QMA5qqwnHsSIhIRhW8PobCMmb3N2Fi725k9zUhv2cXWOIVj3IzllQojCYEbZHvTC4UE+JvhndBACprkCUVshRVIt8L372gVjv6B2zeEmbUw4btAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"optimistic lock\" title=\"optimistic lock\" src=\"/static/ad08b63c38b34d0fc55bed818ecfb3a8/37523/optimistic-lock.png\" srcset=\"/static/ad08b63c38b34d0fc55bed818ecfb3a8/e9ff0/optimistic-lock.png 180w,\n/static/ad08b63c38b34d0fc55bed818ecfb3a8/f21e7/optimistic-lock.png 360w,\n/static/ad08b63c38b34d0fc55bed818ecfb3a8/37523/optimistic-lock.png 720w,\n/static/ad08b63c38b34d0fc55bed818ecfb3a8/302a4/optimistic-lock.png 1080w,\n/static/ad08b63c38b34d0fc55bed818ecfb3a8/07a9c/optimistic-lock.png 1440w,\n/static/ad08b63c38b34d0fc55bed818ecfb3a8/033f0/optimistic-lock.png 3536w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em>그림 2. 낙관적 락</em>\n</p>\n<p>낙관적 락은 이름 그대로 낙관적인 락킹방법이다.</p>\n<blockquote>\n<p>먼저 자원에 락을 걸어서 선점하지말고 충돌 날 때 처리하자</p>\n</blockquote>\n<p>라는 <strong>낙관적인</strong> 방법론에서 탄생한 기법이라고 볼 수 있다.</p>\n<p>그렇다면 이 낙관적 락으로 처리를 못할 케이스도 존재할까?</p>\n<p>위에서 설명한 흐름을 다시 가져와보자.</p>\n<ol>\n<li>사용자가 장바구니 담음</li>\n<li>사용자 결제 요청</li>\n<li>주문서 데이터 생성</li>\n<li>재고 처리</li>\n<li>결제 처리</li>\n</ol>\n<p>결제 요청 후에 재고 처리할 때, 만약 결제 처리가 API를 통해서 이뤄진다면 이 순서대로 이뤄지는 것이 아닐 수도 있다.</p>\n<p>즉, 이미 결제가 성공된부분은 어떻게 처리할 것인가? 에 대한 문제가 존재한다.</p>\n<p>이를 위해 원자적으로 프로세스를 순차적으로 처리하는 방식을 쓸 수 있다.\n이 때 사용할 수 있는 것이 비관적 락이다.</p>\n<h3 id=\"step-112-비관적-락pessimitic-lock\" style=\"position:relative;\"><a href=\"#step-112-%EB%B9%84%EA%B4%80%EC%A0%81-%EB%9D%BDpessimitic-lock\" aria-label=\"step 112 비관적 락pessimitic lock permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.1.2 비관적 락(Pessimitic Lock)</h3>\n<p>비관적 락은 말 그대로 직접 락을 걸어서 하나의 작업만 처리되게끔 보장하는 것이다.</p>\n<p>하지만, 락을 직접 걸기 때문에 만약 고객들이 몰리는 상황에서는 느린 주문 경험을 사용자가 얻게 될 것이다.</p>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 53.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACBUlEQVQoz1VSO2/UQBD270IJFUjpoEBIVFCCACHxaECCigbq0FBBhMSjzul0QeScJol45AogKThEjlzOxud7+bmv70Nr+3LOSJ93Z3bmm9nP61BGM1Jokoo0qlwtoFDtUfkl5nmm7ls7klKecR588nmt4eHxbsK1LnjLTXijnfBdN6Pef8Tgy22Knw/5tpvz+pbknfaMT/bAjWPy7o7kTTfm6gHsQNTaNJwrzQmW3//DpfURnnY0zrkKyy2J550p8t2LOGyeRbp9Ac86MZY+EivtDJddYO2Xwfn1DEsfhrj/GaYgNMZ1WBqqldM3beYbnSJ0EqxM7xxw9LJFKlkP2zRtP8aYTScMRwyCIaRSxdHf1y79RqfIkjojjCa0KiqDrX3+ftGkSkTJoo2disaUVzbGtB2RJMzjGJCSWggqWkiaXFCJlFqkhJKE0rWZUDSB1iWU0jZWEDJNiMAHAp9p7w/7e9/o//hONfTI2Yhq5JNKMZeSg36fg6MeZ1F0SidovSCEEEQSA0lMS848ItOYec9j1vMYhz7TeMosTalkxiQaM4piClsHlPMuCDedeqP5Jg1Cbl9d5dd7rxj4Aw5Dj6GdmJrRbELP8zkej+uEZnHlUgdUWhS00WTK48Mep8Pw1F+2OYu2qGuoKsKWA/uEUFohdvmkFiTGnKA4r/llybwOqZRy5T8E2DnJ6QBD9wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"pessimitic lock\" title=\"pessimitic lock\" src=\"/static/1530537281300df4914cb9020ae51d5a/37523/pessimitic-lock.png\" srcset=\"/static/1530537281300df4914cb9020ae51d5a/e9ff0/pessimitic-lock.png 180w,\n/static/1530537281300df4914cb9020ae51d5a/f21e7/pessimitic-lock.png 360w,\n/static/1530537281300df4914cb9020ae51d5a/37523/pessimitic-lock.png 720w,\n/static/1530537281300df4914cb9020ae51d5a/302a4/pessimitic-lock.png 1080w,\n/static/1530537281300df4914cb9020ae51d5a/07a9c/pessimitic-lock.png 1440w,\n/static/1530537281300df4914cb9020ae51d5a/033f0/pessimitic-lock.png 3536w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em>그림 3. 비관적 락</em>\n</p>\n<p>그렇다면 이 비관적 락처럼 하나의 작업만 처리하지만 보다 빠르게 처리할 수 없는 방법이 없을까?</p>\n<p>바로, 단일 쓰레드 메시지 큐(Redis와 같은 것들)을 도입함으로써 해결 할 수 있다.</p>\n<h3 id=\"step-113-단일-쓰레드-메시지-큐-도입\" style=\"position:relative;\"><a href=\"#step-113-%EB%8B%A8%EC%9D%BC-%EC%93%B0%EB%A0%88%EB%93%9C-%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90-%EB%8F%84%EC%9E%85\" aria-label=\"step 113 단일 쓰레드 메시지 큐 도입 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.1.3 단일 쓰레드 메시지 큐 도입</h3>\n<p>Redis가 6.0 부터 Thread I/O를 제공하여 멀티쓰레드로 돌아가나? 라고 생각할 수 있지만 대부분의 명령들은 메인쓰레드(싱글쓰레드)에서 동작을 한다.</p>\n<p>따라서, 원자적인 작업을 지원한다. 또한, 단일 쓰레드여서 불필요한 락이나 컨텍스트 스위칭과 같은 부분에 대해서 고려하는 점이 최소화되다보니 비관적 락을 쓰는거보다 빠르게 처리할 수 있다.</p>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 53.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB5ElEQVQoz32SvWsUURTFF7XQyiqNoIh2kiZiZWHt/xGwsklhJZheOxsJUbEQGzGgxWLWoFGRmODCriBDAjubZHazu+MO2czOx753594j82YmuyGJF+68x2Pu751zZkrM7DNzIiKkNZGKAgLFJKOQVBRSpECxAoUx0zBUFMZizsJIEScJMQtxVi2t9e0SAEha6YYJVtvDsuXio9VDfbsH3/kOt/EJ/e1vcHc20Gssw7Ur2He3wGbIPBIzzlwuFTzNhilPLZEzC/ty7nkg89Wh4Oe02EsXxF29KaM/96SzdF7ab88KO4vmfWGdjnMO/DpWmGlEMPDRsR10my34PQ/K2kK/vg6/Vod22ojVDnjUgVCcactmC4VfxkAiA4xfPYN9/SKa01Poz81h5c5jvLw2i9eXZmE/+gBV+MvmirUArh5TmHT3oH6tQVXXoe0mDmq7GGw04P3YRFBzEA08aM8HR+oQejIwV6jfvIAzcwWtmasIF54YRQSNYK+LtVvz+HzjASqX76Px8F0GZD4FyCZX8G4T0UrZNDU2kV6TsIY6CPC3XEevXEP3fRXD3w4m3B3JsLB7aPtIpWcnHE9kOPmVj2doLCRJ1une/GmSZZXwuHNHeYaUAyuliVtO0fH/mrAXaa3v/gOtKzRWrse6WwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"single thread queue\" title=\"single thread queue\" src=\"/static/4a8d6b59a835d846a1d5789445c1af16/37523/single-thread-queue.png\" srcset=\"/static/4a8d6b59a835d846a1d5789445c1af16/e9ff0/single-thread-queue.png 180w,\n/static/4a8d6b59a835d846a1d5789445c1af16/f21e7/single-thread-queue.png 360w,\n/static/4a8d6b59a835d846a1d5789445c1af16/37523/single-thread-queue.png 720w,\n/static/4a8d6b59a835d846a1d5789445c1af16/302a4/single-thread-queue.png 1080w,\n/static/4a8d6b59a835d846a1d5789445c1af16/07a9c/single-thread-queue.png 1440w,\n/static/4a8d6b59a835d846a1d5789445c1af16/033f0/single-thread-queue.png 3536w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em>그림 4. 단일 쓰레드 메시지 큐</em>\n</p>\n<p>그래서 최종적으로 아래와 같은 흐름대로 처리할 수 있다.</p>\n<ol>\n<li>사용자가 장바구니 담음</li>\n<li>사용자 결제 요청</li>\n<li>주문서 데이터 생성 및 큐에 적재</li>\n<li>결제 처리 &#x26; 재고 처리 (각각 따로 처리)</li>\n<li>결품이 발생하면 해당 주문서를 취소처리</li>\n</ol>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 53.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACLUlEQVQoz3VTz2tTQRB+V/8FwZNgD6WCVLBq6EUR8agievHiqR4VwYCXSKEnY70EUbAi/moptVar0ChJicUePHhoQUPyyI+2SZvU/H6+t7Mzn+zLa4qUDnw7u7Dzzew3sxZr3WSlNCtFrImY2YeIkNaaXNclz/N8uMolYkWkVe+eH6cUs/LWlOOcstA1wY6J9A6e56FarWJ7u4p6rQEQ9jNtFgY+WVzISefdW2nPvBH6+UN8SmExFiTy4fJfmS9My0z2pcSL70WBhJo1ac9OmljuzE5C2ZlFS8c/oBTqk+LQYbjRSLdIrQ2rD2Y/OcruBs58HsDx6UO4lBhGDS007VXkQ/1iDx3RhVA/2rNTCYvqHbh2SbxsHl6pBmHuwhAyg83ePMdVaK1toFHMo71eAXQgjFKA8rTxTJS0CuMLSPTdkS+D97By89W+IjWXMkgeDWNu4BaWTkbg2pWe+BLQs0jSonIDTq4uevQhqoOnkb14Fm7kNjYnUli+PI5vV6LIjc1DHI1OugTnVwFOpgL2KOihL43RyMiTtL5ufcTw4jG5fv8Ant84iHR4BFtPRpGfS+H73adIhR8j/SKO1mYW69fOIX3hBMojVwFNCDooPqGpkDlh/W6sSGx1DI/sB5KgZT8r/TdHgVTNP2g9i6EWi6L9egIwjdsl5IAwuWcOmZR/GSwQYh/QvEdTCWY2eDYFhAsWC4NYiYE2lUtPl10g8EQ97HyAYF6Nd5RS5/8BussgLNx3j2oAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"single thread queue fail\" title=\"single thread queue fail\" src=\"/static/704d708ad979064dd1da40342c0f275d/37523/single-thread-queue-fail.png\" srcset=\"/static/704d708ad979064dd1da40342c0f275d/e9ff0/single-thread-queue-fail.png 180w,\n/static/704d708ad979064dd1da40342c0f275d/f21e7/single-thread-queue-fail.png 360w,\n/static/704d708ad979064dd1da40342c0f275d/37523/single-thread-queue-fail.png 720w,\n/static/704d708ad979064dd1da40342c0f275d/302a4/single-thread-queue-fail.png 1080w,\n/static/704d708ad979064dd1da40342c0f275d/07a9c/single-thread-queue-fail.png 1440w,\n/static/704d708ad979064dd1da40342c0f275d/033f0/single-thread-queue-fail.png 3536w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em>그림 5. 단일 쓰레드 메시지 큐 - 실패 시나리오</em>\n</p>\n<p>이러한 방식으로도 접근 할 수 있다고 생각한다.</p>\n<p>기본적으로 어떤 방식으로 주문 &#x3C;-> 재고 서비스 간에서 동시성 제어를 할 수 있는지 알아보았다.</p>\n<p>서론에서도 말했지만, 틀린 내용이 존재할 수 있다고 생각하니 이 부분 양해바란다.</p>\n<p>위 방식은 어떻게 보면 최종적 일관성과 분산 트랜잭션 방식을 사용한 것인데 각각 서비스들이 분산된 환경에서 이 트랜잭션들을 처리하는 방법을 알기 위해 분산 트랜잭션과 최종적 일관성에 대해 알아보고자 한다.</p>\n<h2 id=\"step-2-분산-트랜잭션distributed-transaction이란\" style=\"position:relative;\"><a href=\"#step-2-%EB%B6%84%EC%82%B0-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98distributed-transaction%EC%9D%B4%EB%9E%80\" aria-label=\"step 2 분산 트랜잭션distributed transaction이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2. 분산 트랜잭션(Distributed Transaction)이란?</h2>\n<p>이 부분은 <a href=\"https://dataintensive.net/\">DDIA(Designing Data-Intensive Applications, 데이터 중심 어플리케이션 설계)</a>라고 부르는 책의 9장을 많이 참고하였다.</p>\n<p>처음에 분산 트랜잭션을 이해할 때는 DB가 분산되어 있는 상황에서 해당 트랜잭션을 관리하는 것으로 알고 있었다.</p>\n<p>그러나 수 많은 예시들 TCC패턴이나 사가(Saga)패턴을 보면 메시지를 발급해서 커밋 롤백 처리를 하는 것도 보았다.</p>\n<p>정확한 예시는 이 책을 보고 알게되었는데 크게 분산 트랜잭션은 두 가지로 분류된다.</p>\n<ol>\n<li>데이터베이스 내부 분산 트랜잭션</li>\n</ol>\n<ul>\n<li>어떤 분산 데이터베이스(복제나 파티셔닝을 사용하는)는 데이터베이스 노드 사이의 내부 트랜잭션을 지원한다. 이 경우 트랜잭션에 참여하는 모든 노드는 동일한 데이터베이스 소프트웨어를 실행한다. (즉 전자의 예시)</li>\n</ul>\n<ol start=\"2\">\n<li>이종 분산 트랜잭션</li>\n</ol>\n<ul>\n<li>두 가지 다른 벤더의 데이터베이스 혹은 카프카와 레디스와 같은 메시지 큐와 데이터베이스 사이의 트랜잭션 등으로 구성된 환경에서의 트랜잭션 (후자의 예시)</li>\n</ul>\n<p>이번에 주로 다룰 내용은 이종 분산 트랜잭션이다.</p>\n<p>메시지 큐를 통해서 재고차감 메시지를 발급하고 이를 컨슘하는 시스템이라 보면 될 것 같다.</p>\n<p>이제 이에 대해서 설명하고자 한다.</p>\n<h1 id=\"step-3-카프카를-사용한-tcc-패턴-적용\" style=\"position:relative;\"><a href=\"#step-3-%EC%B9%B4%ED%94%84%EC%B9%B4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-tcc-%ED%8C%A8%ED%84%B4-%EC%A0%81%EC%9A%A9\" aria-label=\"step 3 카프카를 사용한 tcc 패턴 적용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3. 카프카를 사용한 TCC 패턴 적용</h1>\n<h2 id=\"step-31-최종적-일관성eventaul-consistency란\" style=\"position:relative;\"><a href=\"#step-31-%EC%B5%9C%EC%A2%85%EC%A0%81-%EC%9D%BC%EA%B4%80%EC%84%B1eventaul-consistency%EB%9E%80\" aria-label=\"step 31 최종적 일관성eventaul consistency란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.1 최종적 일관성(Eventaul Consistency)란?</h2>\n<p>이 부분은 서두에서 말한 것과 같이 대부분의 코드와 매커니즘을 유용모님께서 작성한 컬럼에서 가져왔다.</p>\n<p>원래 이 코드 자체에도 주문, 재고, 결제 서비스가 존재하지만 나는 여기서 주문, 재고 서비스만 가져왔다.</p>\n<p>자세한 부분은 <a href=\"https://github.com/YooYoungmo/article-tcc\">REST 기반의 간단한 분산 트랜잭션 구현</a>을 참고하자.</p>\n<p>여기서 중점적으로 볼 사항은 <strong>최종적 일관성(Eventual Consistency)</strong><sup id=\"fnref-7\"><a href=\"#fn-7\" class=\"footnote-ref\">7</a></sup>이다.</p>\n<p>위에서 말한거처럼 만약, 각각 서비스들이 외부 API로 처리될 경우에 결제가 실패할 경우에는 재고를 다시 늘려줘야하고, 결제가 성공했으나 결품일 경우에는 결제 취소를 해줘야할 것이다.</p>\n<p align=\"center\">\n    <img src=\"https://www.popit.kr/wp-content/uploads/2018/07/image2018-7-30_13-44-21-1024x661.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.popit.kr/rest-%EA%B8%B0%EB%B0%98%EC%9D%98-%EA%B0%84%EB%8B%A8%ED%95%9C-%EB%B6%84%EC%82%B0-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B5%AC%ED%98%84-3%ED%8E%B8-tcc-confirmeventual-consistency/\">REST 기반의 간단한 분산 트랜잭션 구현, 유영모, 2018</a></em>\n</p>\n<p>이때 카프카와 같은 메시지 브로커를 둬서 처리할 수가 있다. 최종적 일관성에 대한 내용도 본문에 존재하지만, 여기서도 간략하게 설명하자면 분산 시스템 환경에서는 일관성이 일시적으로 깨질 수 있는 상황들이 존재한다.</p>\n<p>단일 시스템 환경에서는 강력한 트랜잭션으로 묶어서 관리가 되기때문에 <strong>강한 일관성(Strong Consistency)</strong> 으로 묶일 수 있다.</p>\n<p>하지만, 분산 시스템에서는 이렇게 강한 일관성을 유지하려면 확장성과 성능의 문제가 생긴다.\n아래의 그림을 참고해보자.</p>\n<p align=\"center\">\n    <img src=\"https://cloud.google.com/datastore/docs/articles/images/balancing-strong-and-eventual-consistency-with-google-cloud-datastore/strong-consistency.png?hl=ko\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://cloud.google.com/datastore/docs/articles/balancing-strong-and-eventual-consistency-with-google-cloud-datastore?hl=ko\">Conceptual Depiction of Replication with Strong Consistency, Google Cloud</a></em>\n</p>\n<p>강한 일관성은 어떤 데이터를 최신 데이터로 복제를 수행할 때 항상 최신값을 유지하지만 복제가 완료될 동안에는 클라이언트가 접근을 할 수 없는 문제가 발생한다.</p>\n<p>그에 반해 최종적 일관성의 흐름은 아래와 같다.</p>\n<p align=\"center\">\n    <img src=\"https://cloud.google.com/datastore/docs/articles/images/balancing-strong-and-eventual-consistency-with-google-cloud-datastore/eventual-consistency.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://cloud.google.com/datastore/docs/articles/balancing-strong-and-eventual-consistency-with-google-cloud-datastore?hl=ko\">Conceptual Depiction of Replication with Eventual Consistency, Google Cloud</a></em>\n</p>\n<p>최신 값이 복제 중이지만 클라이언트는 오래된 값을 볼 수가 있다. 이렇게 함으로써 보다 유연한 확장이 가능하고, 성능도 어느정도 확보를 할 수 있다.</p>\n<p>위의 아티클에도 설명이 되어있지만, <strong>최종적 일관성은 몇 명이 좋아요를 눌렀는지?</strong> 와 같은데에서 사용할 수 있고, 강한 일관성은 <strong>게이머가 한 전투 세션에서 획득한 경험치</strong>와 같은 것으로 볼 수 있다.</p>\n<p>즉, 적절한 트레이드 오프가 필요하고 분산 환경에서는 성능과 확장성 때문에 이러한 최종적 일관성을 적절하게 수용하고 있다고 볼 수 있다.</p>\n<p><strong>결국 지금은 일관성이 깨졌지만, 언젠가는 일관성이 맞춰진다</strong>는 것이 최종적 일관성의 모토라고 볼 수 있을 것같다.</p>\n<p>이를 실제 비즈니스 세계에 대입을 하면 요즘날 구독 서비스라고 볼 수도 있을 것 같다.</p>\n<p>유영모님도 나와 비슷한 경험을 원문에 적어두었는데 내가 겪은 최종적 일관성의 경험은 스포티파이를 이용하면서 였다.</p>\n<p>원래 결제되던 카드의 만료기한이 다되었고 귀찮아서 변경을 안했는데 계속 결제 재시도와 이메일로 알림이 왔었다.</p>\n<p>하지만 서비스는 계속 되길래 그냥 썼었는데 어느 순간 재시도도 멈췄고 서비스 자체도 이용을 못하게 막았다.</p>\n<p>그 후에 내가 다시 새로운 카드로 결제를 해서 서비스를 이용할 수 있었다.</p>\n<p>즉, <strong>이 사용자가 결제가 제대로 이뤄지진 않았지만 언젠가 다시 결제를 하겠지</strong>라는 개념이라 볼 수 있고, 이것이 최종적 일관성이 아닐까 생각이 든다.</p>\n<p>아무튼, 위와 같이 카프카를 둬서 최종적 일관성을 유지할 수 있게끔 처리를 하였다고 볼 수 있다.</p>\n<p>하지만 기존 코드에서는 아쉽게도 서비스 단에서 잘못된 메시지가 발급될 경우에 대한 처리가 되어있지는 않았다. (현 재고보다 많은 수량의 주문이 요청이 오면 -로 재고가 잡혀버린다.)</p>\n<p>이 부분을 어떻게 처리할까 궁금했고, 사실 대부분의 코드는 비슷하고 이러한 처리 부분만 변경했다고 볼 수 있다고 생각한다.</p>\n<p>이제 이 부분에 대한 내용을 끝으로 이 포스팅을 마무리 지으려고 한다.</p>\n<h2 id=\"step-32-스프링-카프카-예외-처리-및-재시도-매커니즘\" style=\"position:relative;\"><a href=\"#step-32-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%B9%B4%ED%94%84%EC%B9%B4-%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC-%EB%B0%8F-%EC%9E%AC%EC%8B%9C%EB%8F%84-%EB%A7%A4%EC%BB%A4%EB%8B%88%EC%A6%98\" aria-label=\"step 32 스프링 카프카 예외 처리 및 재시도 매커니즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.2 스프링 카프카 예외 처리 및 재시도 매커니즘</h2>\n<p>카프카와 같은 메시지브로커에는 데드레터 큐<sup id=\"fnref-8\"><a href=\"#fn-8\" class=\"footnote-ref\">8</a></sup>라는 개념이 존재한다.</p>\n<p>이는 올바르게 처리되지 못한 메시지를 저장하기 위한 큐라고 볼 수 있다.</p>\n<p>즉, 올바르게 처리되지 못한 메시지를 데드레터라고 볼 수 있다.</p>\n<p>이를 테면, 우리 서비스에는 원래 적용되지 않았던 가용 재고보다 많은 재고의 요청 메시지가 제공된다면 이는 익셉션을 발생시킬 것이다. 이를 단순하게 커밋을 처리할 수 있지만, 이를 바로 커밋하기 보다는 데드레터 큐에 발급해서 로그를 남기는 용도로도 활용할 수 있을 것이다.</p>\n<p>또한, 네트워크 순단이나 기타 등의 문제로 올바른 메시지여도 처리를 못하는 케이스들이 존재할 것이다.</p>\n<p>이를 위해서 백오프를 둬서 재시도를 처리해야하고, 이때 처리가 안된다면 데드레터 큐로 옮기는 것이 올바를 것이다.</p>\n<p>정리를 하자면 아래와 같을 것이다.</p>\n<ol>\n<li>카프카에서 재고 차감 요청 발급</li>\n<li>네트워크 순단 혹은 잘못된 요청이 들어온 경우 익셉션이 발생</li>\n<li>백오프 처리</li>\n<li>백오프 처리까지 못한 경우 데드레터 큐에 발급</li>\n</ol>\n<p>참고로, <a href=\"https://daddyprogrammer.org/post/15087/kafka-consumer-retry-deadletter/\">Kafka Consumer retry 및 deadletter 처리 방법</a>와 같은 좋은 아티클이 존재하였지만, 스프링 카프카 버전이 올라감에 따라 <code class=\"language-text\">retryTemplate</code> 과 <code class=\"language-text\">recoveryRollback</code> 등의 기능들이 <em>deprecated</em> 되었다.</p>\n<p>이 예제의 버전 기준은 <code class=\"language-text\">spring-kafka 2.8.5</code> 라고 말씀드릴 수 있다.</p>\n<p>먼저, <code class=\"language-text\">KafkaListener</code>에 사용할 <code class=\"language-text\">ContainerFactory</code>의 설정이 필요하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> 중략 <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    <span class=\"token annotation punctuation\">@Bean</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">KafkaListenerContainerFactory</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ConcurrentMessageListenerContainer</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> <span class=\"token function\">kafkaListenerContainerFactory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">ConcurrentKafkaListenerContainerFactory</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> factory <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ConcurrentKafkaListenerContainerFactory</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        factory<span class=\"token punctuation\">.</span><span class=\"token function\">setConsumerFactory</span><span class=\"token punctuation\">(</span><span class=\"token function\">consumerFactory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        factory<span class=\"token punctuation\">.</span><span class=\"token function\">setCommonErrorHandler</span><span class=\"token punctuation\">(</span><span class=\"token function\">kafkaListenerErrorHandler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        factory<span class=\"token punctuation\">.</span><span class=\"token function\">getContainerProperties</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">setAckMode</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">AckMode</span><span class=\"token punctuation\">.</span>MANUAL_IMMEDIATE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> factory<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Bean</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">CommonErrorHandler</span> <span class=\"token function\">kafkaListenerErrorHandler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">DefaultErrorHandler</span> defaultErrorHandler <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DefaultErrorHandler</span><span class=\"token punctuation\">(</span>\n            <span class=\"token keyword\">new</span> <span class=\"token class-name\">DeadLetterPublishingRecoverer</span><span class=\"token punctuation\">(</span>template<span class=\"token punctuation\">,</span> DEAD_TOPIC_DESTINATION_RESOLVER<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            <span class=\"token keyword\">new</span> <span class=\"token class-name\">FixedBackOff</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        defaultErrorHandler<span class=\"token punctuation\">.</span><span class=\"token function\">setCommitRecovered</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        defaultErrorHandler<span class=\"token punctuation\">.</span><span class=\"token function\">setAckAfterHandle</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        defaultErrorHandler<span class=\"token punctuation\">.</span><span class=\"token function\">setResetStateOnRecoveryFailure</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">return</span> defaultErrorHandler<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">ConsumerFactory</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">consumerFactory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DefaultKafkaConsumerFactory</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">.</span><span class=\"token function\">buildConsumerProperties</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> 중략 <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre></div>\n<p>이 설정 부분에서 컨테이너 팩토리에 <code class=\"language-text\">CommonErrorHandler</code>와 <code class=\"language-text\">ConsumerFactory</code>를 주입해준 것을 볼 수 있다. 또한, <code class=\"language-text\">AckMode.MANUAL_IMMEDIATE</code>로 두었는데 이는 <a href=\"https://docs.spring.io/spring-kafka/reference/html/#committing-offsets\">committing-offsets</a> 부분에 자세히 나와있다.</p>\n<p>각 옵션의 값은 아래와 같다.</p>\n<ul>\n<li>Spring Kafka 수동 커밋 옵션 설명</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>구분</th>\n<th>내용</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>RECORD</td>\n<td>리스너가 오프셋 처리 후 반환 시 커밋</td>\n</tr>\n<tr>\n<td>BATCH</td>\n<td>poll()에 의해 반환된 모든 레코드가 처리되면 오프셋을 커밋 (enable.auto.commit = false 시 기본 값)</td>\n</tr>\n<tr>\n<td>TIME</td>\n<td>poll()에 의해 반환된 모든 레코드가 처리되고, 마지막 커밋 이후의 ackTime이 초과되면 오프셋을 커밋</td>\n</tr>\n<tr>\n<td>COUNT</td>\n<td>poll()에 의해 반환된 모든 레코드가 처리되고, 마지막 커밋 이후의 ackCount 레코드를 받으면 오프셋을 커밋</td>\n</tr>\n<tr>\n<td>COUNT_TIME</td>\n<td>TIME 및 COUNT와 유사하지만 두 조건 중 하나가 true인 경우 커밋</td>\n</tr>\n<tr>\n<td>MANUAL</td>\n<td>메시지 리스너에서 acknowledge()로 처리됨을 알리며, 그 후 BATCH와 동일한 의미가 적용. (poll() 처리 이후에 커밋이 된다.)</td>\n</tr>\n<tr>\n<td>MANUAL_IMMEDIATE</td>\n<td>리스너에서 Acknowledgement.acknowledge() 메서드를 호출하면 즉시 오프셋을 커밋. (poll()의 모든 레코드가 아니라 단일 레코드 커밋)</td>\n</tr>\n</tbody>\n</table>\n<p>따라서, 메시지가 요청이 들어올 때마다 <code class=\"language-text\">Acknowledgement.acknowledge()</code> 을 호출해서 직접 커밋을 수행한다.  <code class=\"language-text\">ConsumerFactory</code>는 빌드 설정값을 받아서 컨슈머 팩토리를 만드는 부분이다.</p>\n<p>예외 처리의 핵심은 <code class=\"language-text\">factory.setCommonErrorHandler(kafkaListenerErrorHandler());</code> 부분이다.</p>\n<p>이 메서드만 따로 때서 다시 봐보자.</p>\n<ul>\n<li>kafkaListenerErrorHandler()</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Bean</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">CommonErrorHandler</span> <span class=\"token function\">kafkaListenerErrorHandler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">DefaultErrorHandler</span> defaultErrorHandler <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DefaultErrorHandler</span><span class=\"token punctuation\">(</span>\n            <span class=\"token keyword\">new</span> <span class=\"token class-name\">DeadLetterPublishingRecoverer</span><span class=\"token punctuation\">(</span>template<span class=\"token punctuation\">,</span> DEAD_TOPIC_DESTINATION_RESOLVER<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            <span class=\"token keyword\">new</span> <span class=\"token class-name\">FixedBackOff</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        defaultErrorHandler<span class=\"token punctuation\">.</span><span class=\"token function\">setCommitRecovered</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        defaultErrorHandler<span class=\"token punctuation\">.</span><span class=\"token function\">setResetStateOnRecoveryFailure</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">return</span> defaultErrorHandler<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre></div>\n<p>여기서 <code class=\"language-text\">DefaultErrorHandler</code>를 만들 때, <code class=\"language-text\">DeadLetterPublishingRecoverer</code>와 <code class=\"language-text\">FixedBackOff</code>를 설정하는 것을 볼 수 있다.</p>\n<p>이 코드가 위에서 말한 예외처리의 핵심 코드이다.</p>\n<p><code class=\"language-text\">DeadLetterPublishingRecoverer</code>는 <code class=\"language-text\">KafkaTemplate</code>과 <code class=\"language-text\">BiFunction</code> 을 주입받을 수 있다.\n위에서 나온 코드의 <code class=\"language-text\">DEAD_TOPIC_DESTINATION_RESOLVER</code>는 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">BiFunction</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ConsumerRecord</span><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">?</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Exception</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">TopicPartition</span><span class=\"token punctuation\">></span></span>\n        DEAD_TOPIC_DESTINATION_RESOLVER <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>cr<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">{</span>\n            log<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"[Send to dead letter topic]: {} - [Exception message] : {}\"</span> <span class=\"token punctuation\">,</span> cr<span class=\"token punctuation\">.</span><span class=\"token function\">topic</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TopicPartition</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"dlt-\"</span> <span class=\"token operator\">+</span> cr<span class=\"token punctuation\">.</span><span class=\"token function\">topic</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> cr<span class=\"token punctuation\">.</span><span class=\"token function\">partition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">DeadLetterPublishingRecoverer</code>뒤에 인자가 없을 경우에는 기본 값으로 설정되서 아래의 값으로 세팅된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">BiFunction</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ConsumerRecord</span><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">?</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Exception</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">TopicPartition</span><span class=\"token punctuation\">></span></span>\n\t\tDEFAULT_DESTINATION_RESOLVER <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>cr<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TopicPartition</span><span class=\"token punctuation\">(</span>cr<span class=\"token punctuation\">.</span><span class=\"token function\">topic</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\".DLT\"</span><span class=\"token punctuation\">,</span> cr<span class=\"token punctuation\">.</span><span class=\"token function\">partition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>나는 여기서 로깅과 데드레터큐의 토픽네임을 변경하기 위해 커스텀했다고 보면 될 것 같다.\nDeadLetterPublishingRecoverer는 말 그대로 데드레터를 발급하는 리커버러(복구자)라고 볼 수 있을 것 같다.</p>\n<p>아마 스프링 카프카 도메인에서 <code class=\"language-text\">Recoverer</code>는 메시지를 처리하는 중에 어떠한 문제가 발생했을 때 복구하는 용도로 사용되는 것 같다.</p>\n<p>그리고 백오프를 볼 차례인데 <code class=\"language-text\">new FixedBackOff(1000, 3)</code> 와 같이 두었는데 <code class=\"language-text\">FixedBackOff</code>는 말 그대로 고정값 백오프를 처리하는 객체이다. 나는 1초마다 최대 3번의 재시도를 하게끔 두었다.</p>\n<p>백오프 중에서는 지수 백오프(Exponential Backoff)<sup id=\"fnref-9\"><a href=\"#fn-9\" class=\"footnote-ref\">9</a></sup>도 많이 사용하니 참고해보자.</p>\n<p>스프링 카프카에서는 지수 백오프를 <a href=\"https://docs.spring.io/spring-kafka/docs/current/api/org/springframework/kafka/support/ExponentialBackOffWithMaxRetries.html\">ExponentialBackOffWithMaxRetries</a> 객체를 활용하여 구현할 수 있다.</p>\n<p>그 후에 에러 핸들러의 옵션들에 대해서는 다음과 같다.</p>\n<ol>\n<li>defaultErrorHandler.setCommitRecovered(true)\n<ul>\n<li>리커버리가 되면 오프셋 커밋 처리</li>\n</ul>\n</li>\n<li>defaultErrorHandler.setResetStateOnRecoveryFailure(false)\n<ul>\n<li>복구 실패한 메시지에 대해서 다음 시도에 재시도할 건지?\n<ul>\n<li>(서비스 재부팅이 잦은 개발환경에서는 끄는게 마음이 편한듯)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p>자세한 코드는 <a href=\"https://github.com/brewagebear/blog-example/tree/main/tcc-pattern-example\">BrewageBear - tcc-pattern-example</a>을 확인해보고 실행을 해보자.</p>\n<p>먼저, 해당 프로젝트 폴더로 진입 후에 <code class=\"language-text\">cd infrastructure &amp;&amp; docker-compose up -d</code> 명령어를 치자\n그렇다면, 아래와 같이 제대로 카프카 클러스터가 뜨는 것을 확인할 수 있다.</p>\n<p>다음에는 <code class=\"language-text\">order-service</code> 와 <code class=\"language-text\">stock-service</code>를 실행한다.\n<code class=\"language-text\">stock-service</code>는 카프카 클러스터가 안뜬 상황이면 계속해서 에러로그를 내뿜을 것이다.</p>\n<p>그 이후에는 이제 <code class=\"language-text\">sample</code> 폴더로 들어가서 요청을 직접 수행해보자.\n실제 확정 처리는 아래와 같이 요청 값에 따라서 id를 주어서 처리할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">PUT http://localhost:8888/api/v1/stocks/{재고 확정 요청 id}\nContent-Type: application/json</code></pre></div>\n<ul>\n<li>정상적인 요청</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">POST http://localhost:8887/api/v1/orders\nContent-Type: application/json\n\n{\n  &quot;orderId&quot;: &quot;1&quot;,\n  &quot;productId&quot;: &quot;2&quot;,\n  &quot;qty&quot;: 1,\n  &quot;paymentAmt&quot;: 1\n}</code></pre></div>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 12.222222222222221%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAfklEQVQI1z3NSw6CMABFUfYjVNDE0o+NCRKEgUARagjufxnXUBMHZ/IG9yWFdJSmxtgGZepIqor8dEXklkOmyI6aVKi49WPATyv98GYYf559oO08j3YgcbcObRukusdYqWsuZRXtgT0ockMqNMXZ4V8rc9hYwod52f6meBL4AukDR2wJsx+RAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"valid stock confirm\" title=\"valid stock confirm\" src=\"/static/69b62d1e949043e9c670df3c7af8a6f3/37523/valid-stock-confirm.png\" srcset=\"/static/69b62d1e949043e9c670df3c7af8a6f3/e9ff0/valid-stock-confirm.png 180w,\n/static/69b62d1e949043e9c670df3c7af8a6f3/f21e7/valid-stock-confirm.png 360w,\n/static/69b62d1e949043e9c670df3c7af8a6f3/37523/valid-stock-confirm.png 720w,\n/static/69b62d1e949043e9c670df3c7af8a6f3/302a4/valid-stock-confirm.png 1080w,\n/static/69b62d1e949043e9c670df3c7af8a6f3/07a9c/valid-stock-confirm.png 1440w,\n/static/69b62d1e949043e9c670df3c7af8a6f3/742d3/valid-stock-confirm.png 2550w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em>그림 6. 재고 차감 확정이 정상적으로 처리 된 경우 - 카프카</em>\n</p>\n<p>위의 그림과 같이 <code class=\"language-text\">dlt-stock-adjustment</code> 토픽에는 메시지가 생성이 안됐고, 오프셋 커밋이 정상적으로 처리됨을 볼 수 있다.</p>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 55.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABxUlEQVQoz31RC2+bMBjk//+vVeqSpekaSmIeJoBJSA0GQga2SW6ySSpWVbN0+h7+fL6zHZZ4cF+f4HsrvK6esFn/wNZ9xu+XqVfzADUn36IsfPCjj1Pu2/wsIjh5FmO9crFcEPxaRnDfQmzfAywXHtYvMQ4sgSgpKh5/AUUYRAh8Cs9NQaMENQ/hXM4f2O8jBMEWuCkAV4yjBGN7G8dRQSsFrf+FUhKcF2iaCloP0FqiFTGcWhwRxxRBEEBKCa01hqFHmiYYhmEiUF9wJyw5R1lyO2fqtorhNOIIGkUgZAcpJwJDmCR7yDuhGZ7D9OTQo20b1KLC0PdQakBbUTh1dQCl5i18OzxqbYmMwscF3ykc7oRClHfCu8K2LhBTCt8nM0Jjef9fQrNn7Aqj8GHZvqFRGEXwCfm0+LD8uNkcnsP0+v6PtVtVpc2VnFmO49h+zPU6WigpkecZbtcrpnWbxSk3c5dLh7oWVsCo1aRQlDnCMIC72eB0OtlfNoSEEGRZ9ok0TcEYs8gZs7W1XFXous46swo/igje5ife357huQtc2hxdk4MXIQ7ZDke2Q5H7OGRbFDmx9ZFNsakStCJF1zCLs6D4CxlxPxfPXYTSAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"valid stock db\" title=\"valid stock db\" src=\"/static/7754543e16766f149765f51b37c4149f/37523/valid-stock-db.png\" srcset=\"/static/7754543e16766f149765f51b37c4149f/e9ff0/valid-stock-db.png 180w,\n/static/7754543e16766f149765f51b37c4149f/f21e7/valid-stock-db.png 360w,\n/static/7754543e16766f149765f51b37c4149f/37523/valid-stock-db.png 720w,\n/static/7754543e16766f149765f51b37c4149f/302a4/valid-stock-db.png 1080w,\n/static/7754543e16766f149765f51b37c4149f/62a6a/valid-stock-db.png 1122w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em>그림 7. 재고 차감 확정이 정상적으로 처리 된 경우 - 데이터베이스</em>\n</p>\n<p>또한, DB에도 정상적으로 재고 처리되었음을 확인할 수 있다.</p>\n<ul>\n<li>비정상적인 요청</li>\n</ul>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 15.555555555555555%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAsUlEQVQI1z2O3VKCUBhFeZySTEERYjAEc5LgcA4if1qavv87rIbPmS7WrH23tuX6MZ6fsvA2uMsYZ/HOdBYyeQl4mqwEexqgTEtVD2jTYape/JXX7LOKfWb4zIxsa5MWbHeaZKtIP0rxOs5YrhKJjDHPT2i6H87fd4bTL6fzjX640vUXqkNPqRsJaNNivYU7efY6j5i7a2ZOJDzb/v/D8W2hGkrdosqHHzQU6khe1OKRP3i0bC/9egw9AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"invalid stock confirm\" title=\"invalid stock confirm\" src=\"/static/2f962187bbfa0aa88f3cc448e435a5da/37523/invalid-stock-confirm.png\" srcset=\"/static/2f962187bbfa0aa88f3cc448e435a5da/e9ff0/invalid-stock-confirm.png 180w,\n/static/2f962187bbfa0aa88f3cc448e435a5da/f21e7/invalid-stock-confirm.png 360w,\n/static/2f962187bbfa0aa88f3cc448e435a5da/37523/invalid-stock-confirm.png 720w,\n/static/2f962187bbfa0aa88f3cc448e435a5da/302a4/invalid-stock-confirm.png 1080w,\n/static/2f962187bbfa0aa88f3cc448e435a5da/07a9c/invalid-stock-confirm.png 1440w,\n/static/2f962187bbfa0aa88f3cc448e435a5da/97808/invalid-stock-confirm.png 3022w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em>그림 8. 재고 차감 확정이 비정상적으로 처리 된 경우 - 데드레터 발급</em>\n</p>\n<p>위의 그림과 같이 <code class=\"language-text\">dlt-stock-adjustment</code> 토픽에 비정상적인 메시지가 생성됐고, 오프셋 커밋이 정상적으로 처리됨을 볼 수 있다.</p>\n<p>이때, 비정상적인 요청은 오프셋을 커밋을 하는 이유는 데드레터 큐에 이미 발급을 했기 때문에 커밋처리를 한다.</p>\n<p>자세한 매커니즘은 <code class=\"language-text\">SeekUtils.seekOrRecover()</code>의 내부 메서드의 흐름을 파악해보면 알 수 있을 것이다.\n이로써 간단하게 카프카 사용 시에 위와 같은 에러 처리 시에 데드레터로 처리하는 방법을 알아 보았다.</p>\n<h1 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h1>\n<p>동시성 문제의 발생원인부터 어떻게하면 이를 처리할 수 있는지에 대한 각각의 매커니즘과 분산 트랜잭션까지 알아보았다.</p>\n<p>그리고 분산 트랜잭션에서 카프카를 사용할 때 서비스레이어 단에서 익셉션이 발생한 경우에 데드레터까지 처리하는 방법을 알아보았다.</p>\n<p>추가로 이 예제를 좀 더 발전 시켜서 배치를 붙여볼까 생각중이다.</p>\n<p>포스팅이 언제가 될지 모르기 때문에 위와 관련된 내용이 궁금하신 분들은 아래의 아티클을 추천한다.</p>\n<p><a href=\"https://blog.devgenius.io/exceptions-and-retry-policy-in-kafka-6f0d3cf2c330\">Exceptions and Retry Policy in Kafka</a> 카프카 어플리케이션에서 발생할 수 있는 에러들의 정의와 데드레터 등 다양한 내용을 담고 있다.</p>\n<p>이 중에서 내가 다음에 배치를 붙여서 작업할 내용은</p>\n<p align=\"center\">\n    <img src=\"https://miro.medium.com/max/1400/1*CJTVh1_CQuR-r4_7RUHhtQ.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://blog.devgenius.io/exceptions-and-retry-policy-in-kafka-6f0d3cf2c330\">Exceptions and Retry Policy in Kafka, Victor Alekseev, 2021</a></em>\n</p>\n<p>위의 그림 중에 딜레이가 발생한 메시지나 실패한 메시지를 배치 처리를 통해서 재시도하는 처리를 해보려고 한다.</p>\n<p>긴 글 읽어주셔서 감사합니다.</p>\n<h1 id=\"레퍼런스\" style=\"position:relative;\"><a href=\"#%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4\" aria-label=\"레퍼런스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>레퍼런스</h1>\n<ol>\n<li><a href=\"http://jaynewho.com/post/44\">동시성 문제 - 비즈니스 애플리케이션 (Part 3)</a></li>\n<li><a href=\"https://servicecomb.apache.org/docs/distributed_saga_3/\">Eventual Data Consistency Solution in ServiceComb - part 3</a></li>\n<li><a href=\"https://daddyprogrammer.org/post/15087/kafka-consumer-retry-deadletter/\">Kafka Consumer retry 및 deadletter 처리 방법</a></li>\n<li><a href=\"https://blog.devgenius.io/exceptions-and-retry-policy-in-kafka-6f0d3cf2c330\">Exceptions and Retry Policy in Kafka</a></li>\n</ol>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\"><a href=\"https://en.wikipedia.org/wiki/Distributed_transaction\">Distributed transaction</a><a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\"><a href=\"https://en.wikipedia.org/wiki/Microservices\">Microservices</a><a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-3\"><a href=\"https://en.wikipedia.org/wiki/Concurrency_control\">Concurrency Control</a><a href=\"#fnref-3\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-4\"><a href=\"https://en.wikipedia.org/wiki/Optimistic_concurrency_control\">Optimistic Concurrency Control</a><a href=\"#fnref-4\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-5\"><a href=\"https://en.wikipedia.org/wiki/Lock_(computer_science)\">Database locks - Pessimistic locking</a><a href=\"#fnref-5\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-6\"><a href=\"https://en.wikipedia.org/wiki/Multiversion_concurrency_control\">Multiversion Concurrency Control</a><a href=\"#fnref-6\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-7\"><a href=\"https://en.wikipedia.org/wiki/Eventual_consistency\">Eventual Consistency</a><a href=\"#fnref-7\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-8\"><a href=\"https://en.wikipedia.org/wiki/Dead_letter_queue\">Dead Letter Queue</a><a href=\"#fnref-8\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-9\"><a href=\"https://en.wikipedia.org/wiki/Exponential_backoff\">Exponential Backoff</a><a href=\"#fnref-9\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>","excerpt":"STEP 1. 주문 <-> 재고 서비스에서의 동시성 문제 STEP 1.1 동시성 문제 해결 전략 STEP 1.1.1 낙관적 락(Optimistic Lock) STEP 1.1.2 비관적 락(Pessimitic Lock) STEP 1.1.3 단일 쓰레드 메시지 큐 도입 STEP 2. 분산 트랜잭션(Distributed Transaction)이란? STEP 3.1 최종적 일관성(Eventaul Consistency)란? STEP 3.2 스프링 카프카 예외 처리 및 재시도 매커니즘 개요 사실 분산트랜잭션과 아직 MSA에 대해서는 모르는 부분이 너무나 많다. 이 글을 쓰게된 이유는 주문 <-> 재고 서비스 간의 동시성 제어(Concurrency Control)관련해서 궁금한 점이 생겼고 실제로 이 상황에서 어떻게 처리할 수 있을지 궁금해져서 찾게 되었다. 그러다가 어쩌다 보니 분산 트랜잭션을 구현한 아티클을 보게 되었다. REST 기반의 간단한 분산 트랜잭션 구현라는 글이였고, 작성자인 유…","frontmatter":{"date":"June 11, 2022","title":"동시성 문제 해결 전략 - 스프링으로 구현한 TCC패턴","categories":"개발 인프라","author":"개발한입","emoji":"💻"},"fields":{"slug":"/concurrency-distributed-transaction-with-tcc/"}},"next":{"id":"a7a5771a-6d88-57ce-830a-83e7b19280ba","html":"<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#step-1-%EB%B0%94%EC%9D%B4%ED%8A%B8-%EC%BD%94%EB%93%9Cbytebuffer\">STEP 1. 바이트 코드(ByteBuffer)</a></p>\n</li>\n<li>\n<p><a href=\"#step-2-%EC%B1%84%EB%84%90channel\">STEP 2. 채널(Channel)</a></p>\n<ul>\n<li>\n<p><a href=\"#step-21-scatteringbytechannel-gatheringbytechannel\">STEP 2.1 ScatteringByteChannel, GatheringByteChannel</a></p>\n</li>\n<li>\n<p><a href=\"#step-22-%ED%8C%8C%EC%9D%BC%EC%B1%84%EB%84%90filechannel\">STEP 2.2 파일채널(FileChannel)</a></p>\n<ul>\n<li><a href=\"#step-221-%ED%8C%8C%EC%9D%BC%EC%B1%84%EB%84%90%EC%9D%98-%ED%8A%B9%EC%A7%95\">STEP 2.2.1 파일채널의 특징</a></li>\n<li><a href=\"#step-222-%ED%8C%8C%EC%9D%BC%EC%B1%84%EB%84%90%EC%9D%98-%EC%86%8D%EC%84%B1\">STEP 2.2.2 파일채널의 속성</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-23-%EC%86%8C%EC%BC%93%EC%B1%84%EB%84%90socketchannel\">STEP 2.3 소켓채널(SocketChannel)</a></p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-3-%EC%85%80%EB%A0%89%ED%84%B0selector\">STEP 3. 셀렉터(Selector)</a></p>\n<ul>\n<li>\n<p><a href=\"#step-31-%EA%B8%B0%EC%A1%B4%EC%9D%98-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%AA%A8%EB%8D%B8%EC%9D%98-%EB%8B%A8%EC%A0%90\">STEP 3.1 기존의 네트워크 프로그래밍 모델의 단점</a></p>\n</li>\n<li>\n<p><a href=\"#step-32-%EB%B9%84%EB%B8%94%EB%A1%9D%ED%82%B9-%EB%AA%A8%EB%8D%B8%EA%B3%BC-%EC%85%80%EB%A0%89%ED%84%B0-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC\">STEP 3.2 비블록킹 모델과 셀렉터 동작원리</a></p>\n<ul>\n<li><a href=\"#step-321-selectablechannel\">STEP 3.2.1 SelectableChannel</a></li>\n<li><a href=\"#step-322-selectionkey\">STEP 3.2.2 SelectionKey</a></li>\n<li><a href=\"#step-323-selector\">STEP 3.2.3 Selector</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-4-%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%B1%84%ED%8C%85-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%98%88%EC%A0%9C-%EB%B0%8F-io-%EB%AA%A8%EB%8D%B8\">STEP 4. 간단한 채팅 어플리케이션 예제 및 I/O 모델</a></p>\n<ul>\n<li><a href=\"#step-41-io-%EB%AA%A8%EB%8D%B8\">STEP 4.1 I/O 모델</a></li>\n<li><a href=\"#step-42-%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%B1%84%ED%8C%85-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-io--nio-%EC%98%88%EC%A0%9C\">STEP 4.2 간단한 채팅 어플리케이션 IO &#x26; NIO 예제</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h1 id=\"개요\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EC%9A%94\" aria-label=\"개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개요</h1>\n<p>이전 포스팅 <a href=\"https://brewagebear.github.io/java-syscall-and-io/\">시스템 콜과 자바에서의 시스템 콜 사용례</a> 에서는 시스템 콜이 어떤 것이고, 자바에서 시스템 콜이 주로 발생하는 IO 처리에 대해서 알아보았다.</p>\n<p>이번 시간에는 이전 포스팅에서 다뤘던 문제점들을 자바 NIO가 어떻게 해결하였고, 더 나아가 멀티플렉싱 I/O를 자바에서 어떻게 구현할 수 있는지 알아보고자 한다.</p>\n<p>그리고 결론으로 블록킹 I/O와 논블록킹 I/O를 만든 채팅 어플리케이션 샘플을 보면서 I/O 모델에 대해서 간략히 설명하고자 한다.</p>\n<p>이전 장에 내용을 간략히 복습하자면, 자바 I/O가 느린 고질적인 문제에 대해서 운영체제 수준의 기술(Native I/O)로 향상시킬 수 있다고 하였다. 그러한 기술들을 5가지로 분류하면 다음과 같았다.</p>\n<ol>\n<li>버퍼</li>\n<li>Scatter/Gather</li>\n<li>가상메모리</li>\n<li>메모리 맵 파일</li>\n<li>파일 락</li>\n</ol>\n<p>이렇게 볼 수가 있다. 이제 실제로 NIO에서 위의 기술들을 어떻게 활용하는지 알아보고자 한다.</p>\n<h1 id=\"자바-nio의-동작원리-및-io-모델\" style=\"position:relative;\"><a href=\"#%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1-nio%E1%84%8B%E1%85%B4-%E1%84%83%E1%85%A9%E1%86%BC%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5-%E1%84%86%E1%85%B5%E1%86%BE-io-%E1%84%86%E1%85%A9%E1%84%83%E1%85%A6%E1%86%AF\" aria-label=\"자바 nio의 동작원리 및 io 모델 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자바 NIO의 동작원리 및 IO 모델</h1>\n<ul>\n<li>STEP 1. 바이트 버퍼(ByteBuffer)</li>\n<li>STEP 2. 채널(Channel)\n<ul>\n<li>STEP 2.1 ScatteringByteChannel, GatheringByteChannel</li>\n<li>STEP 2.2 FileChannel</li>\n<li>STEP 2.3 SocketChannel</li>\n</ul>\n</li>\n<li>STEP 3. 셀렉터(Selector)\n<ul>\n<li>STEP 3.1 기존의 네트워크 프로그래밍 모델의 단점</li>\n<li>STEP 3.2 셀렉터의 구조와 동작원리\n<ul>\n<li>STEP 3.2.1 SelectableChannel(셀렉터블 채널)</li>\n<li>STEP 3.2.2 SelectionKey(셀렉션 키)</li>\n<li>STEP 3.2.3 Selector(셀렉터)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>STEP 4. I/O 모델 및 간단한 채팅 어플리케이션 예제</li>\n</ul>\n<h2 id=\"step-1-바이트-코드bytebuffer\" style=\"position:relative;\"><a href=\"#step-1-%EB%B0%94%EC%9D%B4%ED%8A%B8-%EC%BD%94%EB%93%9Cbytebuffer\" aria-label=\"step 1 바이트 코드bytebuffer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1. 바이트 코드(ByteBuffer)</h2>\n<p>Buffer에 대한 사용법은 많은 블로그나 인터넷 도처에 널려있으니 구글링을 통해서 학습을 추천한다. 그 중에서 볼만하다고 여겨지는 것은 <a href=\"http://tutorials.jenkov.com/java-nio/buffers.html\">Java NIO Buffer</a> 라는 아티클이다.</p>\n<p>여기서는 바이트버퍼( <code class=\"language-text\">ByteBuffer</code>)에 대해서만 설명하고자 한다.</p>\n<p><strong>왜 바이트버퍼만 다루려고하는 것인가?</strong></p>\n<blockquote>\n<p>바이트버퍼가 시스템 메모리를 직접 사용하는 다이렉트 버퍼를 만들 수 있는 버퍼 클래스이기 때문이다.</p>\n</blockquote>\n<p>그렇다면 <strong>왜? 바이트버퍼만 다이렉트 버퍼로 만들 수 있게 되었을까?</strong></p>\n<blockquote>\n<p>운영체제가 이용하는 가장 기본적인 데이터 단위가 바이트고, 시스템 메모리 또한 순차적인 바이트들의 집합이기 때문이다.</p>\n</blockquote>\n<p>우리는 해당 메서드를 통해서 기존 <code class=\"language-text\">allocate()</code>  통해서 버퍼를 생성하는 것과 같이 다이렉트 버퍼를 만들 수 있다.</p>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 22.77777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA2UlEQVQY022NWXLEIAwF5ybBgA1IYPDg2Sv3P1ZP2U4+snx0lVolvXcKITBNE9M47mzuvWcYBqy1DINhMGb3b8yXm3/2J1VFc6H0lfnc2TznjIjsc1nOlLbsN3m7Vf0R8icwpcRaC713pFQkJWIIxLgRkdrwSbDO46zFObc/GvPxC3ME1rmx9CuX54v+elJvd4IWkmRiEmKIpDCR4lHirD9wI85PB27Eb2XWcpplYZaV1hvXz4bWjMx3cnsg84VaOldNrEXIWahyZk4NLRe0PtD2REvnppElC28cI5LWrAF0pQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"1\" title=\"1\" src=\"/static/d7af4ccaa699a6d10dadc3d276f4d4aa/37523/1.png\" srcset=\"/static/d7af4ccaa699a6d10dadc3d276f4d4aa/e9ff0/1.png 180w,\n/static/d7af4ccaa699a6d10dadc3d276f4d4aa/f21e7/1.png 360w,\n/static/d7af4ccaa699a6d10dadc3d276f4d4aa/37523/1.png 720w,\n/static/d7af4ccaa699a6d10dadc3d276f4d4aa/00d43/1.png 1000w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em><a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/ByteBuffer.html#allocateDirect(int)\">JDK 11 API Docs, java.nio.ByteBuffer.allocateDirect(int capacity)</a></em>\n</p>\n<p>여기서, 이전 포스팅에서 오류가 있던 점을 알 수 있었는데 나는 자바에서의 시스템 콜 호출순서가 아래와 같다고 설명하였다.</p>\n<p><code class=\"language-text\">JVM -> JNI -> 시스템 콜 -> 커널 -> 디스크 컨트롤러 -> 커널 버퍼 복사 -> JVM 버퍼 복사</code></p>\n<p>하지만 그림으로 예시를 들었던 부분은 이러하였다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 58.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACa0lEQVQoz+WR3UtTAQDFz70um5kv9oGBQV8+REiYYFGCb5EUvgQRPUXRi5CEkCSVFCSBISUSGSlirEJByMByzK9RhOTSpjLzuo/rPu7U7U7nvPvSdWJW0kt/QQd+D+fAOS8H9hkrnbNTXJwbOd9JYtbSXuaQvtEuTXDGNqapYzfzaEBmzJSTGzcKucn3gNafh+D0c8SNOsT7sMmGJLtcKdldlR8sgezIwiScEz17ZXmu1in76iS7q9oSom7ZfBy012yNmw/uJAlGzeLUNSDaC6S6geCCS1SU+QxVVUWQPE3yElPxKiaTZ9KFNwrR/imANpMF6COCXRDTeUyAjvSmO/A8AiLvILIhPTgHt8eLUCgEyC459d05x8/WaVrt7kF2ICcydKCo2vC4AA+1vK7ukh2RwaPF62vRxqWg52kisdYS1VbONQJCciB7nzaYvysQ0k74/cpZVVVLwPBibdXwUi/qxuWCFxOtHEDFjLnoiK5Jfot6x+j1zvtXOF5coS6tcGjYTJttmsnYcttKO04lTPpjKUvp4UAgODE5OclwOPwRbs8UyFHAwCxcoEgTMjkG4DWz9C/XtwMtQmSV+sV5zw2fbL3t9vhuqWqwNLWmYbEG4EXA6/UecjgchW63ez9cpEA2C3hClLfegdaXkZUyQneyawRoI7CHoP0BpB8EAThtgwiGiXVSiLQBvAv4/QocDgd8igJovUBDTz3KnhkEfgGSRuhjRjGDBPKbR3GvoxzxV8Dq+NVtq+bC3V9JYcXbv3ESpy8jZGuCz+cTJEkSFUURkDBik/gv9AkjMv7Of7MlYUTuH/9P/X+DPwHRdNpqoyqCPAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"java-io-system-call\"\n        title=\"java-io-system-call\"\n        src=\"/static/7ab2cc18cc7299ab13feb259a7ee9a94/37523/2.png\"\n        srcset=\"/static/7ab2cc18cc7299ab13feb259a7ee9a94/e9ff0/2.png 180w,\n/static/7ab2cc18cc7299ab13feb259a7ee9a94/f21e7/2.png 360w,\n/static/7ab2cc18cc7299ab13feb259a7ee9a94/37523/2.png 720w,\n/static/7ab2cc18cc7299ab13feb259a7ee9a94/302a4/2.png 1080w,\n/static/7ab2cc18cc7299ab13feb259a7ee9a94/07a9c/2.png 1440w,\n/static/7ab2cc18cc7299ab13feb259a7ee9a94/772aa/2.png 2042w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>즉, NIO에서는 위의 플로우가 맞지만, Blocking I/O에서는 (NIO를 제외한 나머지가 모두 Blocking I/O이다.) 데이터가 커널영역에 있는 버퍼로 전송되고, 다시 또 이 버퍼의 값을 JVM의 버퍼로 옮기는 이중 작업이 발생하였다고 했다.</p>\n<p>따라서, 명확히하자면 아래와 같이 수정하는 것이 맞다고 본다.</p>\n<p><code class=\"language-text\">JVM -> 시스템 콜 -> 커널 -> 디스크 컨트롤러 -> 커널 버퍼 복사 -> JVM 버퍼 복사 </code></p>\n<p>NIO의 경우에서 <code class=\"language-text\">ByteBuffer</code> 를 <code class=\"language-text\">allocateDirect()</code> 메서드로 생성할 경우 아래와 같은 플로우로 진행된다.</p>\n<p><code class=\"language-text\">JVM -> 시스템 콜 -> JNI -> 디스크 컨트롤러 -> DMA -> 복사</code></p>\n<p>즉, 다이렉트로 시스템 메모리에 복사를 할 수 있다.\n그렇기 때문에 <strong>바이트버퍼가 중요한 것</strong>이다.</p>\n<p>위의 <code class=\"language-text\">allocateDirect()</code> 메서드를 살펴보면 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">ByteBuffer</span> <span class=\"token function\">allocateDirect</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> capacity<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DirectByteBuffer</span><span class=\"token punctuation\">(</span>capacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>즉 리턴 할 때 <code class=\"language-text\">DirectByteBuffer</code> 를 생성해주는데 이 녀석을 보면 아래와 같이 <code class=\"language-text\">MappedByteBuffer</code> 를 상속받는 놈임을 확인 할 수 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 321px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 103.8888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsTAAALEwEAmpwYAAACoUlEQVQ4y81Ta2/aQBDkj1D77nx+nDm/zrwCpEASUiyS0CQ0oKQvqrSV2qpS/7801Z0hkEJaqeqHfhjt3loaz+7OVjh3YVMGizJUCUXVJrAIheM4YIyBUvoIusY5N9/3oaJkiNNmil4aoWgrTNo5BiqGCAJIKVGv15HnObJMmRiGNUP6JKEUPg6zGCeNBJe9Ot6ddDBuZQh83xA2GzmUUlBZZghVlsB1HaOS8z2EoZAYtMc4G87Rb09x/DzD/LyJ66KBWVHH50UXy1kbr6ctfL3rYX7WwP1NF/2DCITutl8J/ABSRFBxHZnMIUMfKhFIowBZLJCnIRpZiDwVaOU1COEhiQKEwjMEpVIOZ6W24roclOmBE9jUgk1sWPYKxMazZ8TAsiiqVQJL5zaFZRFQwmBbFIToZTlmBBXXdcGdUnYY1JBKhURmSCOFOEzROEig6hFkLKAaETr9HHEaotXNkCqJdk8hyyP4gbdW6BrJhNo47hSYjd7g6uQOi2KJ4vAK48se7n+8xO2nAq/en+LtlzNc3Axx+7HAdD7E5LqP6eLI/IwSWhKuZ2F8x0gJSsAYBbH1OJj5plvTbeq3rrNVLFtmm5bXG1oPeD+cP9YeWn7KpH+DHUK9IL4d1z7j5RbXcRu/JdzF5sy0NR4iK+OvZ/iI0OXlxtdRw3O9sua5xho6930P3uotQh/ay5sZ6oQ5IJRg0BphOf2G6dHCxMV4iavRHYatMSazQ0znR7iYD3F+M8Dy+4WxzPzDC4wmHbN5TVrxhYAXCCM98AUSqYzBZRijJiSEH5p6IDwEwjeKdF6TgVHp+aXSh0tJmgdI2l1QYhvJpf+YOUftQ+awElszM5GuZreq84db9jzwLXPvhcP3bJdvtsx3lsIeFf+pD/87wp9IH3QRSyp7cQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"MappedByteBuffer\"\n        title=\"MappedByteBuffer\"\n        src=\"/static/1ad6d5f22b7e227de8b194dc850ded23/30592/3.png\"\n        srcset=\"/static/1ad6d5f22b7e227de8b194dc850ded23/e9ff0/3.png 180w,\n/static/1ad6d5f22b7e227de8b194dc850ded23/30592/3.png 321w\"\n        sizes=\"(max-width: 321px) 100vw, 321px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>따라서, <code class=\"language-text\">ByteBuffer</code> 를 사용하면 보다 빠르게 읽고 쓰기가 가능해진다.</p>\n<p>여기서 또 한가지 궁금증이 생길 수 있다.</p>\n<p>그렇다면 <strong>이 시스템 메모리를 어떻게 자바에서 사용가능한가</strong>이다.</p>\n<p>이것도 JNI를 사용해서 처리되는 것일까?</p>\n<p>그것은 아니다 JNI는 초기 시스템 메모리를 할당할때만 사용하고, JNI로 만들어진 시스템 메모리를 <strong>자바 객체로 래핑해서 사용</strong>한다.</p>\n<p>즉, 우리는 래핑된 이 객체를 이용해서 직접적으로 시스템 메모리를 제어할 수 있고, 이것을 실제로 시스템 메모리에 반영된다. 그리고, 이 객체 또한 GC의 관리 대상이기 때문에 GC가 발생하면 래핑하고 있는 주소의 시스템 메모리도 동시에 안전하게 해제되는 것이다.</p>\n<p>공부를 하면서 느낀 점인데 정말 자바는 <strong>추상화</strong> 가 아주 잘된 언어인 것 같다.</p>\n<p>또한, 이 <strong>다이렉트 버퍼가 중요한 점이 한 가지</strong>가 더 있다.\n바로, 뒤에서 볼 <strong>채널(Channel)의 타겟이 되는 것은 다이렉트 버퍼뿐</strong>이라는 것이다.</p>\n<p>논 다이렉트 버퍼를 채널의 타겟으로 설정하면 다음과 같은 일이 발생한다.</p>\n<ol>\n<li>논 다이렉트 버퍼를 채널에 전달</li>\n<li>임시로 사용할 다이렉트 버퍼를 생성</li>\n<li>논 다이렉트 버퍼에서 임시로 만든 다이렉트 버퍼로 데이터를 복사</li>\n<li>임시 버퍼를 사용해서 채널이 저수준 I/O를 수행</li>\n<li>임시 버퍼가 다 사용되면 GC한다.</li>\n</ol>\n<p>운영체제를 공부한 사람이라면 위의 문제가 어떤 문제를 발생하는 지 이해할 수 있을 것이다.</p>\n<p>일단 먼저 딱 봐도 <strong>기존 Blocking I/O와 비슷하게 작업되고 있을 뿐더러 실제 시스템 메모리를 임시로 만들고 해제하는 비용은 당연히 Heap 영역에 국한된 논 다이렉트 버퍼를 만드는 것보다 오버헤드가 상당히 발생</strong>할 것이다.</p>\n<p>그래서 내부적으로 채널의 타켓으로 논 다이렉트 버퍼를 사용하면 결국에는 다이렉트 버퍼를 임시로 만드는 오버헤드가 발생하고, 읽고 쓰기 또한 Blocking I/O와 똑같으므로 사용할 필요가 없으니 다이렉트 버퍼를 사용하는게 좋은 것이다.</p>\n<p>그렇다면 논 다이렉트 버퍼는 사용하지 않아야하는가?</p>\n<p>이건 또 아니다.  소프트웨어 쪽에서는 유명한 명언이 있다.</p>\n<blockquote>\n<p>No Silver Bullet - Essence and Accident in Software Engineering</p>\n</blockquote>\n<p><strong>은총알은 없다</strong>이다. 결국에는 트레이드오프인 것이다.</p>\n<p>하지만, 우리는 위에서 다이렉트 버퍼와 논 다이렉트 버퍼를 비교하면서 힌트를 얻었다.</p>\n<ol>\n<li><strong>다이렉트 버퍼(Direct Buffer)</strong>\n<ul>\n<li>장점 : 읽고 쓰기가 시스템 메모리를 사용하므로 매우 빠르다.</li>\n<li>단점 : 시스템 메모리를 사용하기 때문에 할당 / 해제 비용이 다소 비싸다.</li>\n</ul>\n</li>\n<li><strong>논 다이렉트 버퍼(Non-Direct Buffer)</strong>\n<ul>\n<li>장점 : 시스템 메모리가 아닌 Heap 영역에 생성되기 때문에 할당 / 해제 비용이 보다 저렴하다.</li>\n<li>단점 : 두 번의 버퍼를 거치기 때문에 읽고 쓰기가 느리다.</li>\n</ul>\n</li>\n</ol>\n<p>따라서, 일반적으로 성능에 민감하고 버퍼를 오랫동안 유지해서 사용할 필요가 있을 경우에는 다이렉트 버퍼를 사용하고, 그 외에는 논 다이렉트 버퍼를 사용한다.</p>\n<p>다이렉트 버퍼와 논 다이렉트 버퍼의 차이는 친절하게 자바 스펙에 나와있으니 참고해보자. <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/ByteBuffer.html\">ByteBuffer (Java SE 11 &#x26; JDK 11 )</a></p>\n<h2 id=\"step-2-채널channel\" style=\"position:relative;\"><a href=\"#step-2-%EC%B1%84%EB%84%90channel\" aria-label=\"step 2 채널channel permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2. 채널(Channel)</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 27.22222222222222%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAABOklEQVQY033KsUrDUBjF8WNpUXG0TvYhdHHpWFyddHIUt76Ajr6Fq4OIg4gIph3UEhUE6VBTpIkpubmJjSEVbJsYe3PvJx0EQXH4Lf9z4DgOGUabTNMk3/d3OOdgjOUrlQr+Y9t2njE2+VZN06JHo02ccwL3/CPHfjr1OKsHQW/N5S9QRAUiyn1jjOWCIMj9bFKqgt3l4J63ypznGusa569hdIzW3QHoCtNnDwT/ZhtE9ItlWXBd948tAbvcxH6DQBeYe24eArQLDGrF0khfKZ0AU/GwvyVE1hJCXGdZpidJoodhqEdRpKdpqk+aEKIxFqI5eu+tE4BBY7k0rC8s0gaATw1INcyM78vzZQAfo7c9KRVJmY2VUhTHMXU6HbIsi5IkIaWUklKKLJOUDKNqnwjp7VIx1TCbasAXMjYPhQ3eZdoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Channel\"\n        title=\"Channel\"\n        src=\"/static/d4763f82fca7edd5e8b681503d5174ce/37523/4.png\"\n        srcset=\"/static/d4763f82fca7edd5e8b681503d5174ce/e9ff0/4.png 180w,\n/static/d4763f82fca7edd5e8b681503d5174ce/f21e7/4.png 360w,\n/static/d4763f82fca7edd5e8b681503d5174ce/37523/4.png 720w,\n/static/d4763f82fca7edd5e8b681503d5174ce/302a4/4.png 1080w,\n/static/d4763f82fca7edd5e8b681503d5174ce/07a9c/4.png 1440w,\n/static/d4763f82fca7edd5e8b681503d5174ce/820f7/4.png 2126w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>채널은 스트림과 상당히 유사하지만 채널이 <strong>스트림의 확장이나 발전된 형태는 아니다.</strong> 일종의 게이트웨이라 볼 수 있는데 단지 기존의 파일이나 소켓 등에서 사용하던 스트림을 네이티브 IO 서비스를 이용할 수 있도록 도와주는 메서드를 제공한다.</p>\n<p>스트림과 차이점을 위주로 설명해보자면 (여기서 스트림은 자바 8의 스트림 API가 아닌 FileInputStream과 같은 스트림을 의미한다.)</p>\n<ol>\n<li>데이터를 받기 위한 타겟으로 바이트버퍼를 사용</li>\n<li>채널을 이용하면 운영체제 수준의 네이티브 IO 서비스들을 직간접적으로 사용할 수 있다.\n<ul>\n<li>MMIO<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup> / 파일 락킹<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup> 등</li>\n</ul>\n</li>\n<li>스트림과 달리 단방향 뿐만 아니라 양방향 통신도 가능하다.\n<ul>\n<li>항상 양방향 통신을 사용할 수는 있지 않다\n<ul>\n<li>소켓 채널은 양방향 통신을 지원하지만 파일 채널은 지원하지않는다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p>우리가 다룰 채널은 <strong>파일채널</strong>과 <strong>소켓채널</strong>이다.</p>\n<p>그 전에 이전 포스팅에서 봤던 <code class=\"language-text\">ScatteringByteChannel</code> 과 <code class=\"language-text\">GatheringByteChannel</code> 을 보고자 한다.</p>\n<p>채널의 대부분 클래스들은 인터페이스로 되어있는데 위의<code class=\"language-text\">ScatteringByteChannel</code> 과 <code class=\"language-text\">GatheringByteChannel</code> 도 마찬가지이다.</p>\n<p>이렇게 인터페이스로 사용되는 이유는 확장성이 뛰어나고 유연한 시스템 구조를 갖게되는 점도 있지만, 무엇보다 자바의 핵심 원리인 <strong>WORA(Write Once, Run Anywhere)</strong> 를 이루기 위함이다.</p>\n<p>즉, 운영체제마다 I/O에 관련된 시스템 콜 명령어와 처리 루틴이 다르기 때문에 세부적인 구현은 각 운영체제에 맞춰서 구현하도록 한 것이다.</p>\n<p>그러면 채널과 스트림의 차이와 인터페이스로 구현되어있는 이유를 알아봤으니 다음으로 네이티브 I/O 서비스를 사용하는 <code class=\"language-text\">ScatteringByteChannel</code> 과 <code class=\"language-text\">GatheringByteChannel</code> 를 알아보자.</p>\n<h3 id=\"step-21-scatteringbytechannel-gatheringbytechannel\" style=\"position:relative;\"><a href=\"#step-21-scatteringbytechannel-gatheringbytechannel\" aria-label=\"step 21 scatteringbytechannel gatheringbytechannel permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.1 ScatteringByteChannel, GatheringByteChannel</h3>\n<p>이전 포스트에서 운영체제에서 지원하는 MMIO라는 기술을 알아보았다.</p>\n<p>NIO의 채널에서는 효율적인 입출력을 위해 운영체제가 지원하는 네이티브 IO 서비스인 <strong>Scatter/Gather</strong><sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup>를 사용할 수 있도록 위의 인터페이스를 제공해주고 있다.</p>\n<p>이 인터페이스를 사용함으로써 시스템 콜과 커널 영역에서 프로세스 영역으로 버퍼 복사를 줄여주거나 또는 완전히 없애줄 수 있다.</p>\n<p>실제 코드는 <a href=\"https://github.com/brewagebear/blog-example/blob/main/nio-example/src/main/java/GatheringWriteWithBuffer.java\">blog-example/GatheringWriteWithBuffer.java</a> 와 <a href=\"https://github.com/brewagebear/blog-example/blob/main/nio-example/src/main/java/ScatterBuffer.java\">blog-example/ScatterBuffer</a>를 참고해보자.</p>\n<h3 id=\"step-22-파일채널filechannel\" style=\"position:relative;\"><a href=\"#step-22-%ED%8C%8C%EC%9D%BC%EC%B1%84%EB%84%90filechannel\" aria-label=\"step 22 파일채널filechannel permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.2 파일채널(FileChannel)</h3>\n<p>파일채널을 파일의 관련된 작업들을 지원하는 채널들로 아래의 특징을 갖고 있다.</p>\n<ol>\n<li>\n<p><code class=\"language-text\">ByteChannel</code> 인터페이스를 구현한다.</p>\n<ul>\n<li>이 인터페이스를 구현하므로 양방향성을 가질 수 있으나 항상 그런 것은 아니다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">AbstactInterruptibleChannel</code> 추상 클래스를 구현하고 있다.</p>\n<ul>\n<li>따라서, 비동기적인 방식으로 채널을 닫을 수 있게 되어 스레드와 채널 간의 상태불일치가 발생하지 않도록 보장해준다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">ScatteringByteChannel, GatheringByteChannel</code> 을 구현한다.</p>\n<ul>\n<li>따라서, 보다 빠른 I/O 수행이 가능하다.</li>\n</ul>\n</li>\n</ol>\n<p>위는 구현에 관련된 특징이라면, 실제로 파일채널들이 갖는 특징은 다음과 같다.</p>\n<ol>\n<li><strong>파일채널은 항상 블록킹 모드이며, 비블록킹 모드로 설정할 수 없다.</strong></li>\n<li><strong>파일채널 객체는 직접 만들 수 없다.</strong></li>\n<li><strong>대부분의 채널처럼 파일채널도 가능하면 네이티브 I/O 서비스를 사용하려한다.</strong></li>\n<li><strong>파일채널 객체는 스레드에 안전하다. (thread-safe)</strong></li>\n</ol>\n<h4 id=\"step-221-파일채널의-특징\" style=\"position:relative;\"><a href=\"#step-221-%ED%8C%8C%EC%9D%BC%EC%B1%84%EB%84%90%EC%9D%98-%ED%8A%B9%EC%A7%95\" aria-label=\"step 221 파일채널의 특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.2.1 파일채널의 특징</h4>\n<ol>\n<li><strong>파일채널은 항상 블록킹 모드이며, 비블록킹 모드로 설정할 수 없다.</strong></li>\n</ol>\n<p>이 이유는 운영체제의 기능과 연관이 있는데 현대의 운영체제들은 강력한 캐싱과 프리패치 알고리즘으로 디스크의 I/O를 사용하지만, 비블록킹 모드를 사용할 경우 처리 루틴이 달라져서 이러한 기능들을 사용하는데 제한되기 때문이다.</p>\n<p>그렇다면, 항상 파일채널은 블록킹 I/O로만 써야하는가?</p>\n<blockquote>\n<p>그렇지는 않다. 비동기 I/O로 처리할 수가 있다.</p>\n</blockquote>\n<p>비동기 I/O 모델은 포스팅 결론부에서 다룰 예정이니 일단 이런 방식이 있구나정도로 넘어가자.</p>\n<ol start=\"2\">\n<li><strong>파일채널 객체는 직접 만들 수 없다.</strong></li>\n</ol>\n<p>파일채널 객체는 이미 열려있는 파일 객체의 팩토리 메서드(<code class=\"language-text\">getChannel()</code>)를 호출해서 생성된다. 따라서, <code class=\"language-text\">FileIntputStream</code> 으로 생성된 채널은 <strong>읽기</strong>만, <code class=\"language-text\">FileOutputStream</code> 으로 생성된 채널은 <strong>쓰기</strong>만 가능하다.</p>\n<ol start=\"3\">\n<li><strong>대부분의 채널처럼 파일채널도 가능하면 네이티브 I/O 서비스를 사용하려한다.</strong></li>\n</ol>\n<p>이는 위에서 상속과 구현관련 특징에서도 있는데 <code class=\"language-text\">ScatteringByteChannel</code> 을 통해서 MMIO<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>가 가능하고 운영체제 네이티브 I/O인 파일락킹<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup> 등을 지원한다는 뜻이다.</p>\n<ol start=\"4\">\n<li><strong>파일채널 객체는 스레드에 안전하다. (thread-safe)</strong></li>\n</ol>\n<p>같은 파일채널 인스턴스에 대해 여러 쓰레드들이 동시에 메서드를 호출해도 동기화 문제가 발생하지 않는다.</p>\n<p>이게 가능한 이유는 여러 쓰레드가 접근했을 때 만약 한 쓰레드가 파일 크기 또는 파일채널의 포지션을 변경하는 부분을 수행하는 메서드를 호출하면 다른 쓰레드들은 해당 작업을 마무리할 때까지 기다렸다가 수행하기 때문이다.</p>\n<p>이 부분은 자바 공식문서에도 친절하게 설명되어있다.  <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/channels/FileChannel.html\">FileChannel (Java SE 11 &#x26; JDK 11 )</a></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 4.444444444444445%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAMElEQVQI103Iuw0AMAxCwew/KLjxZwMsp3BSPJ3gkBQAjTczubsyc4ux6u2Itb5/at9ES3DFDkLlAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"FileChannel-Thread\"\n        title=\"FileChannel-Thread\"\n        src=\"/static/0c858989bbb20c74a1232c7a42ed088e/37523/5.png\"\n        srcset=\"/static/0c858989bbb20c74a1232c7a42ed088e/e9ff0/5.png 180w,\n/static/0c858989bbb20c74a1232c7a42ed088e/f21e7/5.png 360w,\n/static/0c858989bbb20c74a1232c7a42ed088e/37523/5.png 720w,\n/static/0c858989bbb20c74a1232c7a42ed088e/302a4/5.png 1080w,\n/static/0c858989bbb20c74a1232c7a42ed088e/07a9c/5.png 1440w,\n/static/0c858989bbb20c74a1232c7a42ed088e/2093e/5.png 1858w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>이제 파일채널의 중요한 속성들을 알아보고자 한다.</p>\n<h4 id=\"step-222-파일채널의-속성\" style=\"position:relative;\"><a href=\"#step-222-%ED%8C%8C%EC%9D%BC%EC%B1%84%EB%84%90%EC%9D%98-%EC%86%8D%EC%84%B1\" aria-label=\"step 222 파일채널의 속성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.2.2 파일채널의 속성</h4>\n<ol>\n<li><strong>파일 락킹(File Locking)</strong></li>\n</ol>\n<p>이전 포스팅에서 말한 바와 같이 공유 락(Shared-Lock, S-Lock)과 배타 락(Exclusive-Lock, X-Lock)이 있는데, 이 책에 나온 것으로 보면 일부 운영체제는 공유 락을 지원안한다고 하는데 이 책이 쓰인 게 벌써 18년이 지난 얘기로 그냥 뇌피셜로 공유 락은 요즘 다 지원하지 않을까? 생각은 해본다.</p>\n<p>어쨋든 자세한 내용은 이전 포스팅에 달아뒀으니 중요한 특징만 살펴보겠다.</p>\n<ul>\n<li>파일 락킹은 채널이 아닌 파일을 대상으로 하는 것이다.</li>\n<li>동일한 JVM 내부의 여러 스레드 사이가 아닌 외부 프로세스 사이에서 파일의 접근을 제어하기 위함이다.</li>\n</ul>\n<p>파일 락킹의 경우에는 채널에 락이 걸렸을 경우에 <code class=\"language-text\">FlieLock</code> 객체가 리턴이 되며, 이 객체 내부의 메서드들을 통해서 공유 락인지 아닌지(<code class=\"language-text\">isShared()</code>) 락을 해제할 것인지 (<code class=\"language-text\">release()</code>) 등을 처리할 수 있다.</p>\n<p>자세한 사용법은 <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/channels/FileLock.html\">FileLock (Java SE 11 &#x26; JDK 11 )</a> 을 참고해보자.</p>\n<p>그렇다면 예시 코드를 한번 살펴보자.</p>\n<ul>\n<li>파일 락킹 예시</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">FileLocking</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">File</span> file <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/Users/liquid.bear/Downloads/test.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">FileChannel</span> channel <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RandomAccessFile</span><span class=\"token punctuation\">(</span>file<span class=\"token punctuation\">,</span> <span class=\"token string\">\"rw\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getChannel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">FileLock</span> lock <span class=\"token operator\">=</span> channel<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Long</span><span class=\"token punctuation\">.</span>MAX_VALUE<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">boolean</span> isShared <span class=\"token operator\">=</span> lock<span class=\"token punctuation\">.</span><span class=\"token function\">isShared</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Is Shared Lock? : \"</span> <span class=\"token operator\">+</span> isShared<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위의 코드를 보면 <code class=\"language-text\">try-resource</code> 문으로 처리하여 <code class=\"language-text\">release()</code> 를 명시적으로 선언안해줘도 알아서 <code class=\"language-text\">release()</code> 가 된다. 이 부분이 궁금하면 실제 클래스를 까보기를 바란다.</p>\n<p>코드 자체는 채널을 가져오고 락을 걸어서 공유락이지 판단하고 릴리즈까지 하는 일련의 예시 코드라고 볼 수 있다.</p>\n<ol start=\"2\">\n<li>메모리 매핑</li>\n</ol>\n<p><a href=\"https://brewagebear.github.io/java-syscall-and-io/#step-214-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%A7%B5-%ED%8C%8C%EC%9D%BC-memory-mapped-io\">MMIO</a>를 이전 포스팅에서 설명했었다. 파일 채널은 이를 지원을 한다.\n추상 메서드인 <code class=\"language-text\">map()</code> 을 통해서 처리가 된다.</p>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 692px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 24.444444444444443%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA6klEQVQY04WPy3KDMAxF8ytYYGzeNuaZBDqTLNJ9//9XTgeTtssujjSS7lxJl+ADvQ+EfmAII947yspSlCZiC0NuLLawVEWGNRqTa7IsQ0QhqSCSkqZp7F32+UnoRq7DzuQ2pnXg/hzZHifL3dGGlf3jwdfnymvreU2e0NYYU1JZS2UNmdbR9HKEpuyoixrfGlxj8K3F5DlKnduPS2xesPiNq2u4uZq+qZj8jdUFVt+ijT0NtdYM3czkF9ahYlsa7nNN3ZTI+42DQ6wkIRGJqMhRKxIlfy//CJVK4iBJJGYReRtlv+L/OC78BrKjlmBXiowrAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"6\" title=\"6\" src=\"/static/5db2e37b531a25bf722d4f2513dd2390/91e7e/6.png\" srcset=\"/static/5db2e37b531a25bf722d4f2513dd2390/e9ff0/6.png 180w,\n/static/5db2e37b531a25bf722d4f2513dd2390/f21e7/6.png 360w,\n/static/5db2e37b531a25bf722d4f2513dd2390/91e7e/6.png 692w\" sizes=\"(max-width: 692px) 100vw, 692px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em><a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/channels/FileChannel.html#map(java.nio.channels.FileChannel.MapMode,long,long)\">JDK 11 API Docs, java.nio.channels.Filechannel.map()</a></em>\n</p>\n<p>이때 인자를 보면 <code class=\"language-text\">MapMode</code> 객체를 받는 것을 확인할 수 있는데 이 객체는 세가지 상수 값을 갖는다.</p>\n<ol>\n<li><code class=\"language-text\">READ_ONLY</code> : 버퍼에서 읽기만 가능한 모드</li>\n<li><code class=\"language-text\">READ_WRITE</code> : 버퍼에서 읽기와 쓰기 모두 가능한 모드</li>\n<li><code class=\"language-text\">PRIVATE</code> : 읽기와 쓰기 둘다 가능하지만 쓰기를 할 경우 복사본을 만들어 변경 내역을 별도로 보관하여 원본 파일에는 적용되지 않는다.</li>\n</ol>\n<p>이렇게 <code class=\"language-text\">map()</code>  메서드를 통해서 MMIO를 구현할 수 있다. 하지만, 주의할 점은 위에서 파일 락킹 같은 경우에는 <code class=\"language-text\">release()</code> 를 통해서 해제되지만, 매모리 매핑은 해제를 할 수 없고, 한번 생성되면 GC가 발생할 때까지 남아있게 된다.</p>\n<p>이렇게 설계 된 이유는 보안문제와 성능문제 때문이라고 한다.</p>\n<p>메모리 매핑의 예시 코드는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">initFileBuffer</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> size<span class=\"token punctuation\">,</span> <span class=\"token class-name\">File</span> file<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">FileNotFoundException</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> bufferCount <span class=\"token operator\">=</span> size <span class=\"token operator\">/</span> FILE_BLOCK_SIZE<span class=\"token punctuation\">;</span>\n    size <span class=\"token operator\">=</span> bufferCount <span class=\"token operator\">*</span> FILE_BLOCK_SIZE<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">RandomAccessFile</span> fileData <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RandomAccessFile</span><span class=\"token punctuation\">(</span>file<span class=\"token punctuation\">,</span> <span class=\"token string\">\"rw\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        fileData<span class=\"token punctuation\">.</span><span class=\"token function\">setLength</span><span class=\"token punctuation\">(</span>size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">ByteBuffer</span> fileBuffer <span class=\"token operator\">=</span> fileData<span class=\"token punctuation\">.</span><span class=\"token function\">getChannel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MapMode</span><span class=\"token punctuation\">.</span>READ_WRITE<span class=\"token punctuation\">,</span> <span class=\"token number\">0L</span><span class=\"token punctuation\">,</span> size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token function\">divideBuffer</span><span class=\"token punctuation\">(</span>fileBuffer<span class=\"token punctuation\">,</span> FILE_BLOCK_SIZE<span class=\"token punctuation\">,</span> fileQueue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre></div>\n<p>어떤 파일의 버퍼를 만드는데 이때 빠른 I/O 처리를 하기 위해서 사용할 수 있다.</p>\n<p>이 예시는 단순한 버퍼 풀을 만든 예제인데 전체 코드는 <a href=\"https://github.com/brewagebear/blog-example/blob/main/nio-example/src/main/java/ByteBufferPool.java\">blog-example/ByteBufferPool</a> 를 참고해보자.</p>\n<ol start=\"3\">\n<li>채널 간 직접 전송</li>\n</ol>\n<p>채널은 버퍼를 거쳐서 처리할 수도 있지만 <strong>채널 사이에서 다이렉트로 데이터를 전송할 수도 있다.</strong></p>\n<p>이런 기능은 <code class=\"language-text\">transTo()</code> 메서드와 <code class=\"language-text\">transFrom()</code> 메서드를 통해서 가능하다.</p>\n<p>그렇다면 속도는 얼마나 빠를지 궁금하다.</p>\n<p>이전 포스팅과 마찬가지로 다양한 버퍼 복사 방식과 채널 직접 전송과의 차이를 비교해보자.</p>\n<ul>\n<li>파일의 크기와 같은 버퍼 사용 시 파일 복사 속도</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 391px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 17.22222222222222%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAjklEQVQI102NWwqDQAxF3YuOdh7+Val13gpiHXD/q7klaQU/Drk3hJPqISWew4B123ha75HXFWlZGBcCnPcIKXF/WwutNZRSEEJAGwMpJeemaVCZvmfJpxRY5zD/2fYdr2li+TCOPGdr+UHMGftxsLScJ3yM6LruJyQzUdc1Q7ltW1x7ynRI3G+vfs8k/AJBRV7tuSw6HAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"7\"\n        title=\"7\"\n        src=\"/static/59a9f0cd4b32008b91a5ae60a216d3ce/14e0c/7.png\"\n        srcset=\"/static/59a9f0cd4b32008b91a5ae60a216d3ce/e9ff0/7.png 180w,\n/static/59a9f0cd4b32008b91a5ae60a216d3ce/f21e7/7.png 360w,\n/static/59a9f0cd4b32008b91a5ae60a216d3ce/14e0c/7.png 391w\"\n        sizes=\"(max-width: 391px) 100vw, 391px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>메모리 매핑 사용 시 파일 복사 속도</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 346px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 23.333333333333332%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA7UlEQVQY022QaW6DQAyFuUhmYVMRMFN2EhCBUESoQKRK7n+VV42rVFHVH5Ytz/j5fbbeggBZnqMoS0RxjLbrcGpbpFmGoqqQFwWCIIDruvA8D77vU/5bP98tpRROTYPtdsN7kuDr8cCyrpjmGeu+Ux2GIThjkFJSdhyHgjEG27apfopaWmv0lwu6vsfHPGOcJnI5jCP1y7pGfTz+OG8aTNcrYqWgtKZlhiyMol9RK0lTGt7vd/rwuW00NC8LzsNAgmVV0RnMaUzfiJkwBsxJoldBY1lwDnY4EIIJzjmhCSEI05YSUgjCe0Xm/yB/AwJXnH+VxiLnAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"8\"\n        title=\"8\"\n        src=\"/static/93bdb191867502bcc4e2a1e9abdc11d7/8f77f/8.png\"\n        srcset=\"/static/93bdb191867502bcc4e2a1e9abdc11d7/e9ff0/8.png 180w,\n/static/93bdb191867502bcc4e2a1e9abdc11d7/8f77f/8.png 346w\"\n        sizes=\"(max-width: 346px) 100vw, 346px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>논 다이렉트 바이트 버퍼 사용 시 파일 복사 속도</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 395px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 18.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAyUlEQVQY02WP246DMAxE+RcICrmU0oVWkIRw27AgVlWl/v+vTBX3ZVd9GFkaj4/tpCxLdNaiulRouw6dMXDeox8GWOfgxxHGObTG4Na21P+qazDGkGXZh5JzVWGYJtRNg957AvzsO5YQMC0LyfY9LZlDIMVsBDL2hvyFJ8ZabMeBZV0Rto2AcTh6+++B434nr7leMc4z9b7XFUopPJ5P+kSfTkjTlMAJ55wMqRSklFSFENBak5TWEFIg5oqioBq9PM8hpAQv+L8LX6+NgRtOsRWsAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"9\"\n        title=\"9\"\n        src=\"/static/b872e5bf2d2cb4e63e9604910c4ce7ca/2cb6c/9.png\"\n        srcset=\"/static/b872e5bf2d2cb4e63e9604910c4ce7ca/e9ff0/9.png 180w,\n/static/b872e5bf2d2cb4e63e9604910c4ce7ca/f21e7/9.png 360w,\n/static/b872e5bf2d2cb4e63e9604910c4ce7ca/2cb6c/9.png 395w\"\n        sizes=\"(max-width: 395px) 100vw, 395px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>다이렉트 바이트 버퍼 사용 시 파일 복사 속도</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 355px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA5ElEQVQY002Q746CMBDEfZTSFkj4Qj3wPP7qHYoF9C4Q4/u/yVx2IsYPk3S33d92ZmOthTUGgVLQWiMIAiilKOm91+pZv2vtCScMQ2yiKILbbuHHEWVd47vrMF6vGETThK7vMd5u1O88885PE86XC35OJ/bb4xFxHBNKYJqmqJsGH1lGaFlVaA4HKt/tULctzzKY5Tmcc6zl7ed+j9Q5CIdAIX8VBfph4Obl8cDfsmC+37ldYKKiLHH2Hr33HBZHRVUhSRLaFru0zAytZQ6S4ao1I2MMjNaUfr6RwVduUfSCyQ//AbUTnbsyh+LmAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"10\"\n        title=\"10\"\n        src=\"/static/4e2442aa327297ed3184b555dbd1b7f4/526ee/10.png\"\n        srcset=\"/static/4e2442aa327297ed3184b555dbd1b7f4/e9ff0/10.png 180w,\n/static/4e2442aa327297ed3184b555dbd1b7f4/526ee/10.png 355w\"\n        sizes=\"(max-width: 355px) 100vw, 355px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>채널 직접 전송 시 파일 복사 속도</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 331px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 20%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAu0lEQVQY012P2w6CMBBE+RegISRyUasIPshFLSo3AR/8//8YMxtJjA+bzuy2Z6eWUgrxeo1H1+Fa1zikKZ7zLL4dBund2xb9OOLeNMjLUjznZ2PA97Ztw3EcuK4Ly1UKvu9jqzX2SYIwDEVnxyP0boeN1ki/mn0uT7NMfBRFWAUBPM8TMKEWDUG3pkE/TbKdKbmdKVgXYwTKO5wx+akoBPR6v5FXFaI4lqQWqaQz7nKyt3zhVy9+0f/FhB+/bII6CkZxYgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"11\"\n        title=\"11\"\n        src=\"/static/c244095cfee3daa7ca33e5d22ffe98e2/62452/11.png\"\n        srcset=\"/static/c244095cfee3daa7ca33e5d22ffe98e2/e9ff0/11.png 180w,\n/static/c244095cfee3daa7ca33e5d22ffe98e2/62452/11.png 331w\"\n        sizes=\"(max-width: 331px) 100vw, 331px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>이를 통해서 채널 직접 전송 시 파일 복사 속도는 메모리 매핑을 사용하는 것보다 조금 나은 성능을 갖는다고 알 수 있다.</p>\n<p>500MB 파일을 복사하는 것으로 예제 코드를 짰으며, 전체 코드는 <a href=\"https://github.com/brewagebear/blog-example/tree/main/nio-example/src/main/java/nio_copy\">blog-example/nio-example - nio_copy</a>  이곳을 참고해보자.</p>\n<h3 id=\"step-23-소켓채널socketchannel\" style=\"position:relative;\"><a href=\"#step-23-%EC%86%8C%EC%BC%93%EC%B1%84%EB%84%90socketchannel\" aria-label=\"step 23 소켓채널socketchannel permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.3 소켓채널(SocketChannel)</h3>\n<p>이전에는 파일채널에 대해서 알아보았다. 이제 채널의 양대산맥 중에 하나인 소켓채널에 대해서 알아보고자 한다.</p>\n<p>소켓채널은 파일채널과 비교하여 몇 가지 다른 특징이 존재한다.</p>\n<ol>\n<li><strong>비블록킹 모드 지원</strong></li>\n<li><strong>SelectableChannel을 상속해서 Selector와 함께 멀티플렉스 I/O(=I/O 멀티플렉스)가 가능</strong></li>\n</ol>\n<p>기존 소켓이나 I/O를 통한 네트워크 프로그래밍의 가장 큰 문제는 <strong>블록킹이 된다</strong>는 점이었다.</p>\n<p><strong>이 때문에, 멀티쓰레드 모델을 사용하게 되었지만, 이 모델은 클라이언트당 쓰레드 한 개를 사용해야 하므로 자원을 비효율적으로 사용하게 되었다. 하지만, 많은 클라이언트들이 접속해서 사용해야 될 쓰레드의 개수가 많아지면서 쓰레드 컨텍스트 스위칭 오버헤드가 많아지면서 성능 저하를 가져왔다.</strong> (그래서 현대에서는 쓰레드풀 모델을 사용한다.)</p>\n<p>하지만, 논블록킹 소켓채널이 도입됨에 따라 멀티플렉스 I/O를 지원하는 셀렉터가 도입되어서 기존의 문제가 해결되었다.</p>\n<p>참고로, 소켓 채널은 별다른 설정을 하지 않으면 기본적으로 <strong>블록킹 모드로 설정</strong>된다.\n따라서 아래와 같이 논블록킹 모드로 바꿔줘야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">SocketChannel</span> socketChannel <span class=\"token operator\">=</span> <span class=\"token class-name\">SocketChannel</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">open</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">InetSocketAddress</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"host ip\"</span><span class=\"token punctuation\">,</span> port<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nsocketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">configureBlocking</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>소켓 채널을 실제 사용해서 간단한 논블록킹 채팅프로그램을 만들었는데 이는 셀렉터를 본 다음 결론에 넣을 예정이니 그때 같이 참고하면 될 것같다.</p>\n<p>이제 대망의 셀렉터를 볼 차례이다.</p>\n<h2 id=\"step-3-셀렉터selector\" style=\"position:relative;\"><a href=\"#step-3-%EC%85%80%EB%A0%89%ED%84%B0selector\" aria-label=\"step 3 셀렉터selector permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3. 셀렉터(Selector)</h2>\n<p>셀렉터는 리액터(Reactor) 패턴<sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup>  중에서 리액터의 역할을 하는 놈이다.</p>\n<p>리액터 패턴의 상세한 부분은 주석을 달아놓은 링크를 참고하고, 여기서는 간략하게 설명하고자 한다.</p>\n<p>요즘 날 네트워크 프로그래밍을 하다보면 나오는 개념 중에 하나가 바로 이벤트 주도 아키텍처(Event-driven Architecture)<sup id=\"fnref-5\"><a href=\"#fn-5\" class=\"footnote-ref\">5</a></sup>일 것이다. 리액터 패턴도 그 아키텍처의 구성요소 중에 하나인데, 이 패턴은 이벤트 중심의 어플리케이션이 하나 이상의 클라이언트로부터 하나의 어플리케이션으로 동시에 전달되는 서비스 요청들을 나눠 각 요청에 상응하는 서비스 제공자에게 구별해서 보내준다.</p>\n<p>좀 더 깊게 설명하면, 클라이언트들의 모든 요청을 앞단의 큐에 저장하고 큐를 모니터링하는 스레드에 이벤트를 보낸다. 그러면 큐를 모니터링하는 스레드는 큐에 저장된 요청을 적절한 로직으로 보내서 해당 요청을 처리하게 한다.</p>\n<p>어? 이거 어디서 본 방식 같은데라고 생각할 수 있다. 이러한 방식을 채택해서 개발자에게 제일 친숙한 것이 바로 <strong>Node.js의 이벤트 루프(Event Loop)</strong><sup id=\"fnref-6\"><a href=\"#fn-6\" class=\"footnote-ref\">6</a></sup> 이다.</p>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 69.44444444444444%; position: relative; bottom: 0; left: 0; background-image: url('data:image/webp;base64,UklGRlIAAABXRUJQVlA4IEYAAADQAwCdASoUAA4APtFUo0uoJKMhsAgBABoJaQAAXGU1AL3KJ4iU3AAA/vYPcBdu2cRzcPuSL7jJS8hwClhOvNsdMVUsAAAA'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"eventloop\" title=\"eventloop\" src=\"/static/95ba89d455553b0c3201f80fac7a2670/bc514/eventloop.webp\" srcset=\"/static/95ba89d455553b0c3201f80fac7a2670/59d6e/eventloop.webp 180w,\n/static/95ba89d455553b0c3201f80fac7a2670/a3012/eventloop.webp 360w,\n/static/95ba89d455553b0c3201f80fac7a2670/bc514/eventloop.webp 720w,\n/static/95ba89d455553b0c3201f80fac7a2670/d00b9/eventloop.webp 800w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em><a href=\"https://medium.com/@nicomf1982/reactor-pattern-en-node-js-4f25ee703299&quot;\">Nicolas Fernandez, Reactor pattern en Node.js</a></em>\n</p>\n<p>이 또한, 따로 찾아보기를 권장하며 (범위를 벗어나기에) 우리가 중점으로 두어야할 내용은 이벤트 주도 아키텍처에서 리액터 패턴이라는 것이 존재하고, 셀렉터는 바로 이 리액터 패턴을 구성하는 요소 중에 리액터를 담당하는 놈이라고 이해하면된다.</p>\n<p>즉, <strong>여러 채널의 셀렉션키를 자신에게 등록하게 하고 등록된 채널의 이벤트 요청들을 나눠서 적절한 서비스 제공자에게 보내 처리하는 것</strong>이다.</p>\n<p>이것을 통해 바로 <strong>I/O 멀티플렉싱</strong><sup id=\"fnref-7\"><a href=\"#fn-7\" class=\"footnote-ref\">7</a></sup>를 가능하게 해준다.</p>\n<p>이제, 기존의 네트워크 프로그래밍 모델의 단점과 셀렉터의 동작원리에 대해서 알아보고자 한다.</p>\n<h3 id=\"step-31-기존의-네트워크-프로그래밍-모델의-단점\" style=\"position:relative;\"><a href=\"#step-31-%EA%B8%B0%EC%A1%B4%EC%9D%98-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%AA%A8%EB%8D%B8%EC%9D%98-%EB%8B%A8%EC%A0%90\" aria-label=\"step 31 기존의 네트워크 프로그래밍 모델의 단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.1 기존의 네트워크 프로그래밍 모델의 단점</h3>\n<p>여기서 말하는 기존 네트워크 프로그래밍 모델은 멀티 쓰레드 모델이다.\n그러나, 쓰레드 풀을 사용하는 모델은 아님을 알고 봐줬으면 좋겠다.</p>\n<p>과거 <code class=\"language-text\">CGI</code> 를 사용하던 시절에는 멀티 쓰레드가 아닌 멀티 프로세스 모델로 각각 프로세스들이 띄워졌었다. 그러나, 프로세스는 쓰레드에 비해 컨텍스트 스위칭 비용이 훨씬 비쌌다. 그래서 자바를 통한 멀티 쓰레드 모델은 각광을 받았었다.</p>\n<p>허나, 이러한 멀티쓰레드 모델도 다음과 같은 문제점을 지녔다.</p>\n<ol>\n<li>\n<p>많은 쓰레드 생성에 따른 스레드 컨텍스트 스위치 부하</p>\n<ul>\n<li>당연히 프로세스보다 쓰레드의 컨텍스트 스위치 비용이 싸긴 하지만 수많은 쓰레드가 쌓였을 경우에는 무시를 못한다.</li>\n</ul>\n</li>\n<li>\n<p>쓰레드 자체가 CPU와 고유 스택을 갖는 데 따른 컴퓨터 리소스 부하</p>\n<ul>\n<li>쓰레드가 프로세스의 문맥자체를 공유하긴 하지만 스택은 별도로 존재하기 때문에 많은 쓰레드가 생길 경우 이 문제도 무시를 못한다.</li>\n</ul>\n</li>\n<li>\n<p>클라이언트의 빈번한 접속과 종료에 따른 많은 가비지 생성 문제</p>\n<ul>\n<li>서버를 통해 주고받는 데이터는 대부분 일회성이다. 이전 포스팅에서 본 내용처럼 두번의 버퍼를 나눠쓰기 때문에 이 과정에서 많은 가비지가 생성이 된다. 그리고 접속이 빈번하면 쓰레드의 생성과 소멸에 따른 가비지도 많을 것이다.</li>\n</ul>\n</li>\n<li>\n<p>클라이언트가 접속할 때마다 매번 쓰레드를 생성하는 부담</p>\n<ul>\n<li>요즘은 쓰레드 풀 모델을 사용해서 이런 문제가 좀 완화되었다고 하지만, 우리가 중점으로 볼 내용은 멀티 쓰레드 모델이므로 1번 요청당 1번 쓰레드가 생성한다 생각하면 많은 부담이 될 수 있다고 느껴진다.</li>\n</ul>\n</li>\n<li>\n<p>서버의 OOM(OutOfMemoryException) 발생 문제</p>\n<ul>\n<li>당연히 수많은 쓰레드가 생기면 OOM이 발생할 수 있다. 그렇기 때문에 <strong>쓰레드 풀 모델이 각광 받은 것</strong>이다. 즉, 1번의 문제(쓰레드 컨텍스트 스위칭)과 5번의 문제(OOM) 때문에 요즘날 쓰레드 풀 모델을 사용한다 생각하면 된다.  그러나, 쓰레드 풀 모델을 사용한다해도 <strong>확장성 문제</strong>는 어쩔 수 없다.</li>\n</ul>\n</li>\n</ol>\n<p>이러한 문제 때문에 I/O 멀티플렉싱 모델이 주목받기 시작한 것이다.</p>\n<h3 id=\"step-32-비블록킹-모델과-셀렉터-동작원리\" style=\"position:relative;\"><a href=\"#step-32-%EB%B9%84%EB%B8%94%EB%A1%9D%ED%82%B9-%EB%AA%A8%EB%8D%B8%EA%B3%BC-%EC%85%80%EB%A0%89%ED%84%B0-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC\" aria-label=\"step 32 비블록킹 모델과 셀렉터 동작원리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.2 비블록킹 모델과 셀렉터 동작원리</h3>\n<p>위에서 왜 I/O 멀티플렉싱 모델이 탄생했는지 알아보았다.\n이러한 모델을 만들기위한 핵심적인 기능들은 크게 세가지로 볼 수 있다.</p>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 51.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABcSAAAXEgFnn9JSAAABYElEQVQoz42R24rCQAyG5/0fzasiCBUPtcUDta09Wq06yfJlGZHFiw2EdDLpf8i4y+Wi6/Val8ulLhYLTZJE27bV/8T1etUsy3S73WpZlvp4PNTVda23203v97s1pmnSpml0HEfrkXwzRw2zfd/r6XTSzWajURTZPQQOhvl8bkx5nuv5fNb9fm8qAWBoGAY7A/R6vfT5fBp5lmZaVZX1mIPEAZKmqclerVYmHTaG/kZRFAYaQkTsTB8S7706mgRWyBAMoJr9QsYqgl3IUIiDrusMkMo/b0AssbsQ2OTBqCjGGqA4CPboxXGss9lMj8fj7w5hAgglWAYA6Shhl6wjDEMeHg5V9AGGGAyI3TRNUhSFtG0rwzBIVVVS17V953kucRzbnfceK+8kuq6z7PtemqaRcRzF4Xu321nCwi7C4lHK/ecjfOa3cN776HA4REmSWJZlGYlIpKrv5Bx6n/Vb/gARJf1j8usPxQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"68747470733a2f2f77736f322e636f6d2f66696c65732f4553425f322e706e67\" title=\"68747470733a2f2f77736f322e636f6d2f66696c65732f4553425f322e706e67\" src=\"/static/79186cf8d8dfac4223e4bb8e4995dbed/0b533/68747470733a2f2f77736f322e636f6d2f66696c65732f4553425f322e706e67.png\" srcset=\"/static/79186cf8d8dfac4223e4bb8e4995dbed/e9ff0/68747470733a2f2f77736f322e636f6d2f66696c65732f4553425f322e706e67.png 180w,\n/static/79186cf8d8dfac4223e4bb8e4995dbed/f21e7/68747470733a2f2f77736f322e636f6d2f66696c65732f4553425f322e706e67.png 360w,\n/static/79186cf8d8dfac4223e4bb8e4995dbed/0b533/68747470733a2f2f77736f322e636f6d2f66696c65732f4553425f322e706e67.png 500w\" sizes=\"(max-width: 500px) 100vw, 500px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em><a href=\"https://github.com/kasun04/nio-reactor\">kasun04 - github, Java NIO - Reactor</a></em>\n</p>\n<ol>\n<li>\n<p>셀렉터(Selector)  : 리액터 패턴에서 리액터 역할을 해주는 객체</p>\n<ul>\n<li>셀렉션키(SelectionKey) 에 등록된 채널들이 발생시킨 이벤트에 대해 적절한 핸들러로 요청을 분기시키는 역할을 한다.</li>\n</ul>\n</li>\n<li>\n<p>셀렉터블채널(SelectableChannel) : 셀렉터에 등록할 수 있는 채널들은 이 클래스를 상속받는다. 우리가 볼 예제는 소켓채널 클래스이므로, 셀렉터에 등록할 수 있다.</p>\n</li>\n<li>\n<p>셀렉션키(SelectionKey) : 특정 채널과 셀렉터 사이에서 해당 이벤트에 대한 내용에 대한 정보를 들고 있는다. 이 값을 토대로 이벤트 요청을 처리한다.</p>\n</li>\n</ol>\n<p>위의 내용을 토대로 전체적인 흐름을 보자면</p>\n<ol>\n<li>\n<p>채널을 셀렉터에 등록하면 이 등록에 관련된 채널과 셀렉터와 연관 정보를 갖고 있는 셀렉션키가 셀렉터에 저장되고, 리턴된다.</p>\n</li>\n<li>\n<p>위의 셀렉션키를 토대로 어떤 채널이 자신이 등록한 모드에 대해 동작할 준비가 되면 셀렉션키는 그 준비상태를 내부적으로 저장한다.</p>\n</li>\n<li>\n<p>소켓 서버의 예시를 들자면 클라이언트를 <code class=\"language-text\">accept</code>할 준비가 되면 셀렉션키는 <strong>준비상태</strong>가 된 것이고, 이 때 셀렉터가 <code class=\"language-text\">select()</code> 메서드를 호출해서 자신에게 등록된 모든 셀렉션키를 검사하여 준비상태이면, 하나씩 순서대로 꺼내서 요청한 이벤트에 대해 적절하게 처리한다.</p>\n</li>\n</ol>\n<p>이제 이 동작원리를 토대로 하나씩 살펴보자.</p>\n<h4 id=\"step-321-selectablechannel\" style=\"position:relative;\"><a href=\"#step-321-selectablechannel\" aria-label=\"step 321 selectablechannel permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.2.1 SelectableChannel</h4>\n<p>앞에서 말한 바와 같이 이 <strong>클래스를 상속받은 클래스</strong>만이 셀렉터에 등록이 될 수 있다하였다.</p>\n<p>우리가 살펴 볼  <code class=\"language-text\">SelectableChannel</code> 의 기능은 2가지인데 <strong>첫 번째는 소켓채널에서 본 논블록킹 모드 활성화 기능</strong>이고 <strong>두 번째는 어떻게 셀렉터에 등록하는 기능</strong>이다.</p>\n<p>첫 번째의 경우에는 소켓채널에서 알려줬으니 두 번째 기능을 알아보고자 한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 11.666666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAYklEQVQI12XJ0QrCMBBE0f5JFpLZTROrYqG2//9hV5IXBR8Oc2GWbX3w2nbOo3G9G8d+p/eKe0alEHW0EzE2kITcJ4+YZsuJkllcosaNaE+6i6rMGo2SCymlP/bbZt/PBuMDXkQ5ZcUZn2UAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"12\"\n        title=\"12\"\n        src=\"/static/7ff2a48197addffe3bdf32c69ec437b1/37523/12.png\"\n        srcset=\"/static/7ff2a48197addffe3bdf32c69ec437b1/e9ff0/12.png 180w,\n/static/7ff2a48197addffe3bdf32c69ec437b1/f21e7/12.png 360w,\n/static/7ff2a48197addffe3bdf32c69ec437b1/37523/12.png 720w,\n/static/7ff2a48197addffe3bdf32c69ec437b1/302a4/12.png 1080w,\n/static/7ff2a48197addffe3bdf32c69ec437b1/ee515/12.png 1269w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 5.555555555555555%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAQElEQVQI1z3DQQqAMAxFQe+i1eSnJWChCvX+13ruOjBbqjPyYb6Nb1Z6v1ET8gO5UNTVzDF3FLGaCZ0XGQUrOz/DEB47YriwwgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"13\"\n        title=\"13\"\n        src=\"/static/7255d8edf94db20e7c6611b147f63006/37523/13.png\"\n        srcset=\"/static/7255d8edf94db20e7c6611b147f63006/e9ff0/13.png 180w,\n/static/7255d8edf94db20e7c6611b147f63006/f21e7/13.png 360w,\n/static/7255d8edf94db20e7c6611b147f63006/37523/13.png 720w,\n/static/7255d8edf94db20e7c6611b147f63006/302a4/13.png 1080w,\n/static/7255d8edf94db20e7c6611b147f63006/bed7a/13.png 1437w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>위 두개의 <code class=\"language-text\">register()</code> 메서드를 통해서 채널을 셀렉터에 등록을 할 수 있다.\n세번째 인자인 <code class=\"language-text\">Object att</code> 는 셀렉션키를 다룰 때 설명하고자 한다.</p>\n<p>여기서 <code class=\"language-text\">ops</code> 는 이벤트의 모드라고 볼 수 있다. 셀렉터에 등록할 수 있는 이벤트 모드들은 4가지가 있다.</p>\n<ol>\n<li><strong>OP_READ</strong> : 서버가 클라이언트의 요청을 <code class=\"language-text\">read</code> 할 수 있을 때 발생하는 이벤트</li>\n<li><strong>OP_WRITE</strong> : 서버가 클라이언트의 응답을 <code class=\"language-text\">write</code> 할 수 있을 때 발생하는 이벤트</li>\n<li><strong>OP_CONNECT</strong> : 서버가 클라이언트의 접속을 허락했을 때 발생하는 이벤트</li>\n<li><strong>OP_ACCEPT</strong> : 클라이언트가 서버에 접속했을 때 발생하는 이벤트</li>\n</ol>\n<p>위의 이벤트들은 셀렉션키에 상수로 등록되어있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 649px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 116.1111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAYAAAALHW+jAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC/0lEQVQ4y31U23LbOAz1jzSSSEmkeNXNsmwnzibT7vQ2ndmH/v+nnC0gUSOnTR/OgBApEMTBwUGpGlopqLpGXVVslVLQWjOapkFZliiKYoMQxZ2fkOc5DjZEtKczbNvB9SPDWMuBCMYYthSc1vuL0ndCVVVLwDAcMT49o51mjI/P6M+PcM4jhIC2bdnGGNnuQd/2+845zvJQ1yW0qqA1Pb2GaTSUVgx+Wp5DCoGqrvnphJrKs4IyI0gplwzHMCPYDq0b0Llxg1MBx2nG66ePmOYzSimXJ9cVHrKMf87zZBdwhqHp0NQWRjmGrgys8lBVgxAipnlG7DrOjGqlaqrVX0gRskApBaQsIEUBKQWEFChLyWs+mGXIsgwPDw9s91ndZ5jj4GKL7ngCWdf28F3PpFhrGd4v68RyYjcxnNZUT87QdQO66w1+nNBenhBPFxhj+ecUlEA+Mbn/Tr61ZruQa0iN3fBNGtY0aLTasknY9+Q+U6orsZvAAR+HV/RuwjGcGYOfMcUrWjPg9vyC/37+xL/fvrGarPfw1qIoxLt1PAgh3mWM9v60/14wDkjapYamdqirki1lQ09Sq00+PTdd8Pai5B9c16O/PMEPR4TpjDDNsNZt9UvFp4CJHFq/JYhYXgN26C9X+GFEN58RpxOcd4gx8EEmYw1ALUTatcyu3S5Ng2EZDk2AVRZWW5ja8NqbCKMtum7A6Tzj8XZDiJFLQAGoM+jnfZNTU3NjH8MFvmkRzcAgKbZ2ZPkdpxOeX1/x5ft3+BB5VlKPqrWJfyczx6EQ+TJVxDI4l3XO8qMDLLkPH5aiC/FGfhljn+mBhqkPgW9ujL0jZCu+NQzyq93ISqjX0cakkOTGl4+I8wX90z9orzc40q8xTEIiw+z8pPEE2tuUopud6M3Saxu7q9T2AyHpljJLA/eusZ31PMK985CSDlSoygqlLLfnKK1RrlN5P533g5UVRKRc+xfQ1J7iBYM7bbomtm+3F3z68hlff/zgOlNgspWUyO5YXoP/Cvg/T0+lb6LIPdkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"14\"\n        title=\"14\"\n        src=\"/static/8607adf991b7d6f8d4211a59d3a1bdae/7762d/14.png\"\n        srcset=\"/static/8607adf991b7d6f8d4211a59d3a1bdae/e9ff0/14.png 180w,\n/static/8607adf991b7d6f8d4211a59d3a1bdae/f21e7/14.png 360w,\n/static/8607adf991b7d6f8d4211a59d3a1bdae/7762d/14.png 649w\"\n        sizes=\"(max-width: 649px) 100vw, 649px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>그래서 아래와 같은 코드로 채널을 셀렉터에 등록할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// 셀렉터 생성</span>\n<span class=\"token class-name\">Selector</span> selector <span class=\"token operator\">=</span> <span class=\"token class-name\">Selector</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">open</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 서버소켓 채널 생성</span>\n<span class=\"token class-name\">ServerSocketChannel</span> server <span class=\"token operator\">=</span> <span class=\"token class-name\">ServerSocketChannel</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">open</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nserver<span class=\"token punctuation\">.</span><span class=\"token function\">configureBlocking</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 논블록킹 모드 활성화</span>\n\n<span class=\"token class-name\">ServerSocket</span> socket <span class=\"token operator\">=</span> server<span class=\"token punctuation\">.</span><span class=\"token function\">socket</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">SocketAddress</span> addr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">InetSocketAddress</span><span class=\"token punctuation\">(</span>port<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nsocket<span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>addr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 소켓 생성 후 해당 주소에 바인드</span>\n\n<span class=\"token comment\">// 셀렉터에 생성된 ServerSocketChannel과 ACCEPT 이벤트 등록</span>\nserver<span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span>selector<span class=\"token punctuation\">,</span> <span class=\"token class-name\">SelectionKey</span><span class=\"token punctuation\">.</span>OP_ACCEPT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </code></pre></div>\n<p>각 채널 구현체마다 등록될 수 있는 이벤트는 다른데 아래와 같다.</p>\n<table>\n<thead>\n<tr>\n<th>채널 구현체</th>\n<th>등록할 수 있는 이벤트</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ServerSocketChannel</td>\n<td>OP_ACCEPT</td>\n</tr>\n<tr>\n<td>SocketChannel</td>\n<td>OP_CONNECT, OP_READ, OP_WRITE</td>\n</tr>\n<tr>\n<td>DatagramChannel</td>\n<td>OP_READ, OP_WRITE</td>\n</tr>\n<tr>\n<td>Pipe.SourceChannel</td>\n<td>OP_READ</td>\n</tr>\n<tr>\n<td>Pipe.SinkChannel</td>\n<td>OP_WRITE</td>\n</tr>\n</tbody>\n</table>\n<p>여러 개의 이벤트를 등록할 수 있는 채널은 아래와 같이 여러개의 이벤트도 등록할 수 있으며, 하나의 셀렉터의 여러개의 채널도 등록할 수 있다.</p>\n<ul>\n<li>하나의 셀렉터에 여러 이벤트와 채널 등록</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Selector</span> selector <span class=\"token operator\">=</span> <span class=\"token class-name\">Selector</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">open</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">SocketChannel</span> channel1 <span class=\"token operator\">=</span> <span class=\"token class-name\">SocketChannel</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">open</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nchannel1<span class=\"token punctuation\">.</span><span class=\"token function\">configureBlocking</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">SocketChannel</span> channel2 <span class=\"token operator\">=</span> <span class=\"token class-name\">SocketChannel</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">open</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nchannel2<span class=\"token punctuation\">.</span><span class=\"token function\">configureBlocking</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">ServerSocketChannel</span> server <span class=\"token operator\">=</span> <span class=\"token class-name\">ServerSocketChannel</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">open</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nserver<span class=\"token punctuation\">.</span><span class=\"token function\">configureBlocking</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nserver<span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span>selector<span class=\"token punctuation\">,</span> <span class=\"token class-name\">SelectionKey</span><span class=\"token punctuation\">.</span>OP_ACCEPT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nchannel1<span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span>selector<span class=\"token punctuation\">,</span> <span class=\"token class-name\">SelectionKey</span><span class=\"token punctuation\">.</span>OP_READ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nchannel2<span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span>selector<span class=\"token punctuation\">,</span> <span class=\"token class-name\">SelectionKey</span><span class=\"token punctuation\">.</span>OP_READ <span class=\"token operator\">|</span> <span class=\"token class-name\">SelectionKey</span><span class=\"token punctuation\">.</span>OP_WRITE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">Set</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">SelectionKey</span><span class=\"token punctuation\">></span></span> keys <span class=\"token operator\">=</span> selector<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">SelectionKey</span> key <span class=\"token operator\">:</span> keys<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">.</span><span class=\"token function\">channel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">+</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">interestOps</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>결과를 살펴보면 아래와 같다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 381px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 23.333333333333332%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA20lEQVQY002Q2Q6CMBRE+RDCkoiGF9la9hbKIur//8+YuRHjw6SdtD0zt96y76jbFm3fiwZjxHfDgMk5mGmCW1fM64r9+QTv03N9vF4YrEU/jkjTFGEYwhutRVGWKKtKpJtGvKprAVdaywOKnoEM5p7KigL3LMMlSRBFETwmNV0nl9iKD05v5xlu26TpdhywzmFaFhzvN+55jjiO4fs+giAQGL1HQKmUNFFaS0M25Z5gnvfGCOxsyoAsz3G93X4gShryj/6BMqZSMvLZWppbKwEE2i8w+Y55AtnwAzrUomxaz2oZAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"15\"\n        title=\"15\"\n        src=\"/static/888e1099081d525df6440c2e8fc5e7cc/2add2/15.png\"\n        srcset=\"/static/888e1099081d525df6440c2e8fc5e7cc/e9ff0/15.png 180w,\n/static/888e1099081d525df6440c2e8fc5e7cc/f21e7/15.png 360w,\n/static/888e1099081d525df6440c2e8fc5e7cc/2add2/15.png 381w\"\n        sizes=\"(max-width: 381px) 100vw, 381px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>그림으로 보면 다음과 같을 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 90.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEkUlEQVQ4y22QW0yTBxTH/18/Lo7rB4o30IECcZssQxDY9EFf5tRlMVmyRLMte1m2F+MWp25Gl20aMzNflrmLVGjZQMFWBqWXry29QFNwlgkWAWltC0qkrVgstLWlLWehncRke/jlf87//E9OchBWA5Ek+RE1NkT4RM0AQJgHluZhHmsTJOtn+SWywjxeCfPYnsjyYEAaJLivQoGbRwl1J3pmszQdpEWCKRUKH6pQ+Cw7wwMBPqGcm0fZLI/ykDp5HB5ZKkjBgizpK8iUzkn+BC51glnVAjR3gtF3AHTjhSwyp2VPdgHGDoahPgFIx4CMTCb1pq0kHVNEagFIyQJ/m8C0a4CPr+HA8ev4Ep8iFT8DBU1gcAogAo5IcfgzCT4kSzqI0nFOCsH1DkAjxabP23HurBT7DslScFoFBiWSbGxqy91dJefoDWU+benIr6/QFmEbvyZ1S9cqlLdz39Yq8qhGwVG5dOXBUlk+dvdnsk8IqJZx+teVHNXI82ZfbllTvLktH6jo4LBVyn1Qq36RdurKqbprrfH9gd3Y21uZuktbitc6C67s7C6jWk0xVXYUfFXDr8X+QCWz+hDStinW3d+hK6ft/AaqaF1Z/ZIkC8j7ZSOyT+xnSyXMxTIpTOua07ZmtwJFV8FyV4D1v2dsLJWCL5OgJffXvKzMJhbFrSy7UQKUXE3ZUy7FrZI25niJGSizAHjgbWdNBoD6d60gXfGqU3Kgz3oyhYgYw63TKd+rAOqpyCHjlpwrKmBk4sfETHRDzOIqQIbC9biw9GtCjJyCRGFsPQFSIYMMWD0s+QJhooTvnA7B0noUMTk4MiBvsPNkwl/CZh/DmNKO+XYU3ZsgOEfMCR+BQEAxbrMbJ5w20z3bcP+4za7z+/29fr//O6/X0z0+btNPumxmh33E7HA4jf4nT7pCodB5j8djcjqd+odT9huTky6D2+3ui0Qi9ZiamiKlUkkGQw8ZjSbSaNRktVopHo/3uFwuUsjlpNcbyWDsJZlMRjMzMxQMBi1ms5m0Wi3p9Mak6rppenr6AVwuV7vVOsyP3hnsdtitxtu3hxVDQ0Oaubm5016vVzE4dFs5MjygHx8b0t+0DPC+x4+lbrf7rM1m07pcLqX97mDP3bFR1ejoqH5iYuInEIXgVR8GXUPGXCsK5gyfwPfXzeVfPZR/hMVOcE/bwNmvvbfsz9/sBE32Y0GGwjt3CA9UF0DxRwBOLqK2sQ3kQAZZsPpt8UXgDAFf3weOEd5qFoNugaNBcHubG4EjBJzxAD+EgPMBUB+KUEnARQdwyg9w9Z4aXFqs3tGkf/PAH23v4DeqyhU+qssU+mpzLj+uQwNV7WlW7tvTrNiHeqrKEc7UZQpna59xsEX87oYGx470+vm63EueV5HSGA4x4vgiI47F/iW+jGghzgiDcaYhEmMaF2KJXvTcPMnSTpQRxym1MWyFQByLoonoP/xOBGGIcExLOKoknNATvhlI+k3/j0AUHUVq41O3QBSdZUULviUEy0STKgz6WGHAx9bP+wSXgz6BOPpcJrnDihZmBKJoMK0hZP4HU2b1/tLbBAEAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"AC194916 DA9B 4690 9652 92D95746040D\"\n        title=\"AC194916 DA9B 4690 9652 92D95746040D\"\n        src=\"/static/d0e3a9782bf655ff5db7c6dd692a237d/37523/AC194916-DA9B-4690-9652-92D95746040D.png\"\n        srcset=\"/static/d0e3a9782bf655ff5db7c6dd692a237d/e9ff0/AC194916-DA9B-4690-9652-92D95746040D.png 180w,\n/static/d0e3a9782bf655ff5db7c6dd692a237d/f21e7/AC194916-DA9B-4690-9652-92D95746040D.png 360w,\n/static/d0e3a9782bf655ff5db7c6dd692a237d/37523/AC194916-DA9B-4690-9652-92D95746040D.png 720w,\n/static/d0e3a9782bf655ff5db7c6dd692a237d/302a4/AC194916-DA9B-4690-9652-92D95746040D.png 1080w,\n/static/d0e3a9782bf655ff5db7c6dd692a237d/78612/AC194916-DA9B-4690-9652-92D95746040D.png 1260w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>셀렉터는 이렇게 이벤트가 발생한 채널들만 선택해서 각 이벤트에 맞는 동작을 하도록 모든 이벤트들에 대한 컨트롤러 역할을 한다.</p>\n<h4 id=\"step-322-selectionkey\" style=\"position:relative;\"><a href=\"#step-322-selectionkey\" aria-label=\"step 322 selectionkey permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.2.2 SelectionKey</h4>\n<p><strong>어떤 채널이 어떤 셀렉터에, 어떤 이벤트 모드로 등록됐는지, 그 등록한 이벤트를 수행할 준비가 되어있는지에 대한 정보들을 담고 있는 객체</strong>이다.</p>\n<p>즉, 이벤트 처리에 대해서 셀렉터와 채널 사이에서 도와주는 역할을 하는 객체이다.</p>\n<p>셀렉션키에는 크게 두가지 집합이 존재한다.</p>\n<ol>\n<li><strong>interest set</strong></li>\n<li><strong>ready set</strong></li>\n</ol>\n<p><strong>interest set</strong>은 위에서 여러 채널과 이벤트를 등록하는 예시 코드를 보여줬는데 이 코드에서 <code class=\"language-text\">key.interestOps()</code> 라는 호출부가 존재한다.</p>\n<p>코드를 보면 알겠지만 이 정보들은 <code class=\"language-text\">register</code> 할 때 등록했던 상수들 값이다. 따라서 <strong>interest set</strong>은 <strong>셀렉터에 등록한 이벤트 정보를 담는 집합</strong>이라고 알고 있으면 된다.</p>\n<p><strong>ready set</strong>은 <strong>채널에서 이벤트가 발생하면 그 이벤트들을 저장하는 집합</strong>이다.</p>\n<p>즉, 셀렉션키는 <strong>interest set</strong> 과 <strong>ready set</strong>을 활용하여 이벤트 핸들링을 도와주는 역할을 한다.</p>\n<p>채널의 <code class=\"language-text\">register()</code> 부분에서 세번째 인자인 <code class=\"language-text\">att</code>\n는 본 챕터에서 설명을 한다고 하였다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 5.555555555555555%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAQElEQVQI1z3DQQqAMAxFQe+i1eSnJWChCvX+13ruOjBbqjPyYb6Nb1Z6v1ET8gO5UNTVzDF3FLGaCZ0XGQUrOz/DEB47YriwwgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"16\"\n        title=\"16\"\n        src=\"/static/7255d8edf94db20e7c6611b147f63006/37523/16.png\"\n        srcset=\"/static/7255d8edf94db20e7c6611b147f63006/e9ff0/16.png 180w,\n/static/7255d8edf94db20e7c6611b147f63006/f21e7/16.png 360w,\n/static/7255d8edf94db20e7c6611b147f63006/37523/16.png 720w,\n/static/7255d8edf94db20e7c6611b147f63006/302a4/16.png 1080w,\n/static/7255d8edf94db20e7c6611b147f63006/bed7a/16.png 1437w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>이 인자는 셀렉션키에 참조할 객체를 추가하는 메서드고 해당 키에 참조할 객체가 있으면 그 객체를 리턴하고, 없으면 null을 리턴한다.</p>\n<p>이 인자는 <code class=\"language-text\">attachement()</code> 메서드로 가져올 수 있으며, <code class=\"language-text\">register()</code> 로 등록이 가능하지만 <code class=\"language-text\">attach()</code> 메서드로도 등록할 수 있다.</p>\n<p>이 메서드의 사용 이유는 클라이언트마다 특정 세션 값 부여 및 접속을 오래 유지하지 않은 클라이언트에 그 처리를 담당하는 핸들러를 붙여서 사용하는 등의 용도로 사용된다고 한다.</p>\n<p>그러나, <code class=\"language-text\">attach()</code> 메서드로 첨부된 객체는 GC의 대상이 아니므로, 셀렉션키가 삭제될 때 같이 삭제해줘야 메모리 누수가 발생안한다.</p>\n<h4 id=\"step-323-selector\" style=\"position:relative;\"><a href=\"#step-323-selector\" aria-label=\"step 323 selector permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3.2.3 Selector</h4>\n<p>셀렉터는 위에서 언급한 바와 같이 <strong>등록된 채널들이 발생시킨 이벤트에 대해 적절한 처리 핸들러로 요청을 분기해주는 컨트롤러 역할</strong>을 한다.</p>\n<p>위에서 셀렉터에 대한 내용은 많이 언급했으니 중요한 특징만 설명하고자 한다.</p>\n<p>셀렉터 또한 등록된 이벤트를 처리하기 위해서는 자신에게 등록된 채널과 연관된 셀렉션키에 대해서 알고 있어야할 것이다.</p>\n<p>그러므로 셀렉터 내부에는 셀렉션키에 대한 집합을 가지고 있다.\n이 집합은 크게 세 가지이며, 셀렉터 내부에서는 아래의 집합들을 관리한다.</p>\n<ol>\n<li><strong>등록된 키 집합(Registered Key Set)</strong>\n<ul>\n<li>셀렉터에 등록된 모든 셀렉션키의 집합이다. 하지만 이 집합에 있는 모든 키가 유효하지는 않다.</li>\n<li>메서드 : <code class=\"language-text\">Selector.keys()</code></li>\n</ul>\n</li>\n<li><strong>선택된 키 집합(Selected Key Set)</strong>\n<ul>\n<li>선택된 키 집합 ⊂ 등록된 키 집합</li>\n<li>셀렉션키가 수행 준비상태가 되서 <strong>ready set</strong>이 비어있지 않은 키들이 <code class=\"language-text\">Selector.select()</code> 메서드에 호출되서 선택됐을 때 이 집합에 추가된다.</li>\n</ul>\n</li>\n<li><strong>취소된 키 집합(Cancelled Key Set)</strong>\n<ul>\n<li>취소된 키 집합 ⊂ 등록된 키 집합</li>\n<li>등록을 해제하고 싶을 때 <code class=\"language-text\">SelectionKey.cancel()</code> 메서드로 등록을 취소할 수 있는데 이 키는 바로 유효하지 않은 키로 설정되고 취소된 키 집합에 추가된다.</li>\n</ul>\n</li>\n</ol>\n<p>주의사항으로는 셀렉터는 쓰레드 세이프하지만, 세 가지 키 집합은 쓰레드 세이프하지 않으므로, 멀티쓰레드 환경에서 이 키에 접근하고자 하면 반드시 <strong>동기화 처리</strong>를 해줘야한다.</p>\n<p>이제 셀렉터의 동작 원리에 대해서 살펴보고자 한다.\n셀렉터는 <code class=\"language-text\">select()</code> , <code class=\"language-text\">poll()</code> 과 같은 시스템 콜을 래핑한 것이다.</p>\n<p>실제 사용 방식은 <code class=\"language-text\">select()</code> 메서드를 호출하면서 사용되는데 다음과 같은 방식으로 동작한다.</p>\n<ul>\n<li><strong>셀렉터 동작 방식</strong></li>\n<li><strong>취소된 키 집합을 체크한다. ··· ①</strong>\n<ul>\n<li>만약 집합이 비어 있지 않다면\n<ul>\n<li>이 집합에 저장된 각각의 키들은 셀렉터가 관리하는 세가지 집합에서 모두 삭제되어 각 키와 연관된 채널이 셀렉터에서 등록이 해제된다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>등록된 키 집합을 체크한다. ··· ②</strong>\n<ul>\n<li>만약 <strong>ready set</strong>이 비어있지 않은 셀렉션키가 존재한다면\n<ul>\n<li>등록된 키 집합에 넣는다. (이미 존재한다면 그 키를 업데이트 처리만 한다.)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>셀렉터가</strong> <code class=\"language-text\">selectedKeys()</code> <strong>메서드를 호출한다. ··· ③</strong>\n<ul>\n<li>저장된 선택된 키 집합을 가져오고, 그 안에 저장된 셀렉션키의 이벤트 형식에 따라 적절한 핸들러에게 처리를 넘긴다.</li>\n</ul>\n</li>\n</ul>\n<p>① ~ ③의 동작과정을 반복하면서 진행하는데 그 실행 시점과 블록킹 여부 차이만 있다.</p>\n<p>셀렉터가 제공하는 <code class=\"language-text\">select</code> 함수는 총 세가지이다.</p>\n<ol>\n<li>\n<p><code class=\"language-text\">select()</code></p>\n<ul>\n<li>블록킹되는 메서드이며, 선택된 키 집합이 비어있다면 키가 추가될 때까지 블록킹 된다. 그러다가 사용할 수 있는 키가 추가되면 ① ~ ③을 실행한다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">select(long timeout)</code></p>\n<ul>\n<li>밀리세컨드마다 <code class=\"language-text\">select()</code> 함수와 동일하게 처리된다.  따라서, 해당 시간마다 블록킹이 된다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">selectNow()</code></p>\n<ul>\n<li>논블록킹 메서드이다. 따라서 이용 가능한 채널이 없으면 0을 리턴하고, 아니면 마찬가지로 등록된 키 집합안에 들어있는 셀렉션키의 개수를 리턴한다.</li>\n</ul>\n</li>\n</ol>\n<p>그리고 추가로, <code class=\"language-text\">wakeup()</code> 메서드는 쓰레드가 블록킹 되어있는 경우 이 블록킹된 쓰레드를 깨우는데 사용한다.</p>\n<p>이제 실제 간단한 채팅프로그램 예시를 통해 기존 네트워크 모델과 어떻게 다른지 더 나아가 I/O 모델이 무엇인지 정리 후에 이 포스팅을 마치고자 한다.</p>\n<h2 id=\"step-4-간단한-채팅-어플리케이션-예제-및-io-모델\" style=\"position:relative;\"><a href=\"#step-4-%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%B1%84%ED%8C%85-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%98%88%EC%A0%9C-%EB%B0%8F-io-%EB%AA%A8%EB%8D%B8\" aria-label=\"step 4 간단한 채팅 어플리케이션 예제 및 io 모델 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 4. 간단한 채팅 어플리케이션 예제 및 I/O 모델</h2>\n<h3 id=\"step-41-io-모델\" style=\"position:relative;\"><a href=\"#step-41-io-%EB%AA%A8%EB%8D%B8\" aria-label=\"step 41 io 모델 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 4.1 I/O 모델</h3>\n<p>자 이제 어떻게 보면 이 포스팅의 핵심 주제로 왔다.\nIO / NIO를 다루면서 자주 했던 말은 블록킹과 논블록킹이었다.</p>\n<p>이것들은 I/O 모델이라는 개념에 속해있다.\n이번 포스팅에서는 4가지 I/O 모델을 다루려고한다.</p>\n<ol>\n<li><strong>블록킹(Blocking) I/O 및 동기(Synchronous) I/O 모델</strong></li>\n<li><strong>논블록킹(Non-Blocking) I/O 모델</strong></li>\n<li><strong>비동기(Asynchronous) I/O 모델</strong></li>\n<li><strong>I/O 다중화(Multiplexing) 모델</strong></li>\n</ol>\n<ul>\n<li><strong>블록킹(Blocking) I/O 및 동기(Synchronous) I/O 모델</strong></li>\n</ul>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 609px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 60.55555555555555%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABX0lEQVQoz41T2XKDMAzk/z+vD32gkEI4CiZcJgFsY29HSmBImjbVjAZLltertfCccyAnu1wuSJIExziGlAPn1v3VjTGQUiKKItR1jWVZ7uq8PaBzFn0vUZ1qWGvxmyml0HUdf6luf6G3FlFgnUOYCMRpxbmu65n1+XzGMAzsFJNppX5cxIBEmQ5YY9CNE96jFPWp4VyW5RBCoCxLFEXBTjHtfRwS7qZpajRNg3EcGdSjBRUCDn4UI8wLuJsuvxkxqU4ts6Xz0zRtWjJgmqYMWLY9wrxktq8AjdH8JVByrfUVkAJmaC3krPFZCLjlCtj3PXzfRxiGCIIAWZZtj3WIc7Rty+2SE0sGpFvmeWZWclZ4C46I4wxaKx4L0o90q6qK16QfdZXlYpuOu0d5bOdLNDhm4mXL8zw9nVNvH5AZrTf6j8V7X1/1JSCJq24z9gxozf8bkERfhf+L4eMvtwJ+A8ZcqTwnVeLpAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"17\" title=\"17\" src=\"/static/edf3e49aa1dc74c52ca1571e4257b2d8/d0d8c/17.png\" srcset=\"/static/edf3e49aa1dc74c52ca1571e4257b2d8/e9ff0/17.png 180w,\n/static/edf3e49aa1dc74c52ca1571e4257b2d8/f21e7/17.png 360w,\n/static/edf3e49aa1dc74c52ca1571e4257b2d8/d0d8c/17.png 609w\" sizes=\"(max-width: 609px) 100vw, 609px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em><a href=\"https://grip.news/archives/1304\">그립뉴스, 논-블로킹 I/O, 비동기 I/O 차이 이해하기</a></em>\n</p>\n<p>위의 그림을 보면 알겠지만 어플리케이션은 커널의 응답이 올 때까지 <strong>블록킹</strong> 된다. (다른 작업을 하지 못한다.)</p>\n<p>이전 포스팅에서 말한 시스템 콜의 예시로 들면 <strong>사용자 모드에서 커널 모드로 전환 후에 작업을 처리하여 다시 사용자 모드로 돌아올 때 까지 작업이 차단</strong>되는 것이다.</p>\n<p>당연히, 우리 똑똑한 어르신들은 이러한 응답을 대기하는 유휴시간이 발생하기 때문에 이 시간을 줄일 수 없을까? 고민을 하게 되었고 그렇게 나온 I/O 모델이 논블록킹 I/O 모델이다.</p>\n<ul>\n<li><strong>논블록킹(Non-Blocking) I/O 모델</strong></li>\n</ul>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 505px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 71.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB6ElEQVQ4y31TibKaQBD0/39OS0utBAGVQ45FlpvlsFM9ebz4EvK2aiyhZrtnupvNOI7IsgxRFCFJEpRlidfrtVrzPKOua6RpijiOpZf3eZaeDZvKooDrOALa9z2+O8YYPB4PuK4r4NM0fSHd8KcdBvywA6RKo+86XK9XhGEoU/i+jyAIpDzPE5CmaTBN4z9kn4C6qhFGCbQuZAKublkW7vc7HMeBbdvyTNBxHOAHMSzHR9c2shWJ8zxfVp5wTRQsN4TnRxiMQdu20lAUhZTWWp45nTE9nk+NhwygUVU1qqr6lGoDvFA0DYJHirbtRRNOopQSs8i+mEDthmEQWda0lgnZQGPIQhCyctXdbofz+Yz9fo/D4YDtdovL5YKqKnFxbrg4/jog3bXjFCfLQxAmeM2TTNF9TPFefM8NyrISvRmbxTRuIIDiWt8jThSMGYSJE7+zst7f50WD49lB17afZDRTANngqyfsWwitS7RNIxlbgk52RoiTUApezrIcKsv/HxsJd1mKu7zA/9TtdDrheDxKkYT5Y2xo4E/7t4bzX1+TADa9QaKeUFmGvu/EHIabIAwzi3nMtcYwGESxws2LvkjyB3Ce4UYJdqcbouT57We3aMksstYBP5rCSKGq29Wm9+Kh2zRhDfAXZ5Qz+MZHlI0AAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"18\" title=\"18\" src=\"/static/8191748b02ba47363bbbaf9b729e3bc1/c0cb9/18.png\" srcset=\"/static/8191748b02ba47363bbbaf9b729e3bc1/e9ff0/18.png 180w,\n/static/8191748b02ba47363bbbaf9b729e3bc1/f21e7/18.png 360w,\n/static/8191748b02ba47363bbbaf9b729e3bc1/c0cb9/18.png 505w\" sizes=\"(max-width: 505px) 100vw, 505px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em><a href=\"https://grip.news/archives/1304\">그립뉴스, 논-블로킹 I/O, 비동기 I/O 차이 이해하기</a></em>\n</p>\n<p>논 블록킹은 위에서 보는 바와 같이 시스템 콜이 발생된 뒤에 이 응답이 끝날때 까지 기다리는 것이 아니라 제어권이 다시 어플리케이션에게 전달되는 것을 확인할 수 있다.\n이때 주기적으로 I/O의 처리 가능한 상태를 판단하면서 다른 일을 수행한다.</p>\n<p>풀링<sup id=\"fnref-8\"><a href=\"#fn-8\" class=\"footnote-ref\">8</a></sup> 통신 방식과 흡사하다고 생각하면 된다.</p>\n<p>그렇다면, 비동기 I/O 모델이랑은 어떻게 다른 것일까?</p>\n<ul>\n<li><strong>비동기(Asynchronous) I/O 모델</strong></li>\n</ul>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 516px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 70.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABnUlEQVQ4y41Ti46CMBDk/3/OM/FOwPNUXuVZQFoKos5ll8DpaaKbbEqaZTo7s2sBwPl8hlINqqrC8XhE13V0jev1epdTrdYaUkqu7U/9Xa01FUVRBMdxcDgcoJTiosvl8gDY9z3quobruhBCoG3bR8CxFIjTAqbr8U4YYx4eZECiH4YhpCzwsdqhrDXOw4A8z1kCYkPt0XdRFHxStK2eWd+GRZfUMkUQJZDlCBIEAeI45iQ56KSH6SS9v5wdlG5RSoksy5gAyWHd6uMFCZQ2b7XshynSLEdZlmiahg0ahmEEnGJle5DVc0P+m2NM+/QhNmWk28H+DlHW6unI/AdUSrNU493f4xbZ7robRFGIT8djU5jhK0CtuYunpkxFn64/A76KzrQMSDM75azhBGhvfMiqQRwLbLdbLJdL2LaN9XrNuVgsePBpfPa+QJpm7HCappy0YfOmUOwOApFIWE8qpDGhbaARSpIEnuexqzSDzrcPYx6XwDqdTtjt9xAiwmL1g/rYvtmyuTNjNoXYkTFEVyT5vHqvXKZ/JlNuAX8BiAQ/dzjble0AAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"19\" title=\"19\" src=\"/static/4ee8784ac6c6e5189576794c1e002fe3/75dcb/19.png\" srcset=\"/static/4ee8784ac6c6e5189576794c1e002fe3/e9ff0/19.png 180w,\n/static/4ee8784ac6c6e5189576794c1e002fe3/f21e7/19.png 360w,\n/static/4ee8784ac6c6e5189576794c1e002fe3/75dcb/19.png 516w\" sizes=\"(max-width: 516px) 100vw, 516px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em><a href=\"https://grip.news/archives/1304\">그립뉴스, 논-블로킹 I/O, 비동기 I/O 차이 이해하기</a></em>\n</p>\n<p>가장 큰 차이점은 논블록킹 I/O 모델처럼 주기적으로 처리 여부를 응답하는 것이 아니라 커널에 시스템 콜을 한 뒤에 어플리케이션은 계속 다른 일을 하다가 커널이 <strong>콜백</strong> 으로 완료여부를 알려준다. 즉, <strong>I/O 처리가 완료가 된 타이밍에 결과를 회신하는 모델</strong>이다.</p>\n<p>차이점을 정리하자면 비동기 I/O 모델은 완료를 했을 때 통지를 하지만 논블록킹 I/O 모델은 처리가 가능한 상태를 판단하면서 처리한다.</p>\n<p>이제 I/O 다중화 모델만 남아있는데 이를 더 잘 이해하기 위해서는 논블록킹 I/O의 단점을 살펴보는 것이 좋다.</p>\n<p>위에서 말한 것과 같이 이는 풀링 방식과 매우 흡사하다고 하였다. 즉, <strong>시스템 콜이 계속해서 요청될 수 있는 단점이 존재하는 것</strong>이다.</p>\n<p>그래서 옛 성인들께서는 이를 필요할 때만 호출하게끔 하면 더 좋은 성능을 얻을 수 있게 될 것이라고 판단하였다.</p>\n<p>위의 단점이 안 와닿을 수 있기에 스타벅스 사이렌 오더를 만든다 가정해보자.</p>\n<p>이를 논블록킹 서버로 만들었다면, 우리에게 계속 귀찮게 <strong>“야 너 주문할 커피 있어?”</strong> 라고 알림이 올 것이다.</p>\n<p>하지만, 이를 필요한 시점에만 물어보게끔 할 수 있다면?\n즉, 이벤트를 등록해두는 것이다.</p>\n<p><strong>“사용자 커피 주문 요청”</strong> 이라는 이벤트를 등록해두고 없으면 호출을 안하다가 내가 사이렌 오더를 통해서 주문 요청을 하면 이 이벤트가 등록이 될 것이고, 이 때 처리를 하면 될 것이다.</p>\n<p>이게 바로 <strong>I/O 다중화 모델</strong> 이다.</p>\n<ul>\n<li><strong>I/O 다중화 모델</strong></li>\n</ul>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 56.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABXUlEQVQoz3WS6aoCMQyF+/6vpTD/3BUFFXHfV2bGbTzyBVqq15uhMG2Sk3OSOEVWFIW63a4qlYoGg4GyLNNut9NqtdLpdNL1erUzmUzMn+e55b1er3DcZrMx536/twcSZrNZCFiv11osFgaYpqnm87nG47GB9vt93W63QMgAR6ORSqWSlsulns/nh5Pvl/liGIAQoBjmhsOhqtWqVb3f70G6T/gPzPuR3el01Gw2rUUOCbVazQAfj0dI8sDn81mXy0Xb7TawiIvBkDvqiHf0jj4eDofAkAAPRkva7bYajYaOx6O9cW+1WqHXsbn4AqCfNKwwhkF/KQhDmDIMZEKEHEixDQzUEdjr9Ww1viV/V4/vfoAA0bJ6vW7b4qhYLpc1nU4/hkEC/zClmGdM45HO2vBPPoCw5v2PZHYuSRIxfRqOAt4IRgGFOfTWLzdxnrGL14CDk8B4J39J/r1Shd5HwE1KrFHWgQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"20\" title=\"20\" src=\"/static/8d4e71078f49ceea5b931bace38519ff/37523/20.png\" srcset=\"/static/8d4e71078f49ceea5b931bace38519ff/e9ff0/20.png 180w,\n/static/8d4e71078f49ceea5b931bace38519ff/f21e7/20.png 360w,\n/static/8d4e71078f49ceea5b931bace38519ff/37523/20.png 720w,\n/static/8d4e71078f49ceea5b931bace38519ff/c946b/20.png 805w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.cs.toronto.edu/~krueger/csc209h/f05/lectures/Week11-Select.pdf\">University of Toronto, I/O Multiplexing</a></em>\n</p>\n<p>우리가 봤던 셀렉터와 셀렉션키 등의 개념을 기억하면서 위의 그래프를 살펴보자.  <strong>select</strong> 시스템 콜은 <code class=\"language-text\">Selector.select()</code> 라고 볼 수 있을 것이며 <strong>data ready</strong> 부분은 셀렉션키의 <strong>ready set</strong> 이 존재하는 경우일 것이다.</p>\n<p>즉, 우리가 공부한 NIO는 <strong>I/O 다중화 모델</strong>을 구현할 수 있는 객체들이다.\n이러한 개념들을 출발하여 오늘날 I/O 모델의 중심이라 볼 수 있는 이벤트 주도 아키텍처(Event-Driven Architecture)<sup id=\"fnref-5\"><a href=\"#fn-5\" class=\"footnote-ref\">5</a></sup>나 사가 패턴(Saga Pattern)<sup id=\"fnref-9\"><a href=\"#fn-9\" class=\"footnote-ref\">9</a></sup>등이 탄생하였다고 볼 수 있다.</p>\n<h3 id=\"step-42-간단한-채팅-어플리케이션-io--nio-예제\" style=\"position:relative;\"><a href=\"#step-42-%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%B1%84%ED%8C%85-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-io--nio-%EC%98%88%EC%A0%9C\" aria-label=\"step 42 간단한 채팅 어플리케이션 io  nio 예제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 4.2 간단한 채팅 어플리케이션 IO &#x26; NIO 예제</h3>\n<p>코드는 너무 길다보니 링크로 대체하고 설명을 해보고자한다.</p>\n<ol>\n<li><a href=\"https://github.com/brewagebear/blog-example/tree/main/nio-example/src/main/java/simple_chatting_example/io\">멀티쓰레드 I/O - 채팅프로그램 예제</a></li>\n<li><a href=\"https://github.com/brewagebear/blog-example/tree/main/nio-example/src/main/java/simple_chatting_example/nio\">멀티플렉스 I/O - 채팅프로그램 예제</a></li>\n</ol>\n<p>멀티쓰레드 I/O를 먼저 보면 <code class=\"language-text\">ChatThread</code> 를 통해서 클라이언트와 통신한다.\n클라이언트 쪽을 보면 <code class=\"language-text\">InputThread</code> 와 <code class=\"language-text\">Client</code> 를 분리해뒀는데 이렇게 분리한 이유는 메인 쓰레드가 키보드로부터 입력을 받을 때 블록킹이 발생하므로 <code class=\"language-text\">InputThread</code> 로 입력처리를 나눈 것이다.</p>\n<p>멀티플렉스 I/O를 보면 여기서는 <code class=\"language-text\">ChatThread</code> 하나만 존재한다.\n이는 단순하게 쓰기 작업을 위한 쓰레드이다. 블록킹이 발생하지 않으므로 <code class=\"language-text\">InputThread</code> 는 존재하지 않는다.</p>\n<p>이게 가장 큰 차이라고도 볼 수 있다.</p>\n<p>클라이언트가 입력을 처리하는 부분의 코드 블록만 가져와서 차이를 보자.</p>\n<ul>\n<li>InputThread.java (IO 예제)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">InputThread</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Thread</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Socket</span> socket <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">BufferedReader</span> reader <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">InputThread</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Socket</span> socket<span class=\"token punctuation\">,</span> <span class=\"token class-name\">BufferedReader</span> reader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>socket <span class=\"token operator\">=</span> socket<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>reader <span class=\"token operator\">=</span> reader<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token class-name\">String</span> line <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>line <span class=\"token operator\">=</span> reader<span class=\"token punctuation\">.</span><span class=\"token function\">readLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>line<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> ignored<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>reader <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    reader<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> ignored<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>socket <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    socket<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> ignored<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>Client.java (NIO 예제)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">startReader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Reader is started..\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\">// 셀렉터의 select() 메서드로 준비된 이벤트가 있는지 확인한다.</span>\n                selector<span class=\"token punctuation\">.</span><span class=\"token function\">select</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token class-name\">Iterator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">SelectionKey</span><span class=\"token punctuation\">></span></span> iterator <span class=\"token operator\">=</span> selector<span class=\"token punctuation\">.</span><span class=\"token function\">selectedKeys</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">iterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n                <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">hasNext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token class-name\">SelectionKey</span> key <span class=\"token operator\">=</span> iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">.</span><span class=\"token function\">isReadable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token function\">read</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                    iterator<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            log<span class=\"token punctuation\">.</span><span class=\"token function\">warn</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"start()\"</span><span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre></div>\n<p>원래 기존에 블록킹이 되기 때문에 별도의 쓰레드를 둬서 처리한 부분을 셀렉터로 처리하여 블록킹이 발생하지 않게 처리가 가능함을 볼 수 있다.</p>\n<h1 id=\"step-5-정리-및-결론\" style=\"position:relative;\"><a href=\"#step-5-%EC%A0%95%EB%A6%AC-%EB%B0%8F-%EA%B2%B0%EB%A1%A0\" aria-label=\"step 5 정리 및 결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 5. 정리 및 결론</h1>\n<p>이 포스팅을 시작했을 때는 단순하게 시스템 콜의 실제 사용례를 자바에서 알고 싶어서 시작하였고, 그러다보니 I/O 쪽에서 많이 쓰인다는 것을 알게되었다.</p>\n<p>이전 포스팅에서는 왜 기존 자바 I/O가 느린 이유와 NIO가 대두되게된 원인들을 설명하였으며, 이번 포스팅에서는 이전 포스팅에서 기존 I/O들이 지원하지 않았던 네이티브 I/O 서비스들을 NIO가 지원하면서 I/O 성능을 끌어올렸음을 알 수 있었다.</p>\n<p>하지만, 거기서 끝나지 않고 네트워크 프로그래밍과 결합하여 I/O 모델들이 다양한데 기존 I/O 방식은 블록킹이 되다보니 논블록킹 I/O 모델의 채널과 I/O 멀티플렉싱을 위한 멀티플렉서인 셀렉터를 토대로 I/O 멀티플렉싱 모델까지 알아보았다.</p>\n<p>요즘날에는 스프링 웹 플럭스나 네티에 대해서 많은 개발자들이 관심을 갖고 있다.</p>\n<p>이번 기회에 I/O 멀티플렉싱과 논블록킹 I/O가 어떤 것이고, 어떻게 만들 수 있는지에 대해서 정리가 되서 좀 더 이해가 수월하지 않을까 생각이 든다.</p>\n<p>긴 포스팅을 읽어주셔서 감사합니다.</p>\n<h1 id=\"reference-및-읽을거리\" style=\"position:relative;\"><a href=\"#reference-%EB%B0%8F-%EC%9D%BD%EC%9D%84%EA%B1%B0%EB%A6%AC\" aria-label=\"reference 및 읽을거리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference 및 읽을거리</h1>\n<ol>\n<li><a href=\"https://homoefficio.github.io/2019/02/27/Java-NIO-Direct-Buffer%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%B4%EC%84%9C-%EB%8C%80%EC%9A%A9%EB%9F%89-%ED%8C%8C%EC%9D%BC-%ED%96%89-%EA%B8%B0%EC%A4%80%EC%9C%BC%EB%A1%9C-%EC%AA%BC%EA%B0%9C%EA%B8%B0/\">Java NIO Direct Buffer를 이용해서 대용량 파일 행 기준으로 쪼개기 - 뒤태지존의 끄적거림</a></li>\n<li><a href=\"http://tutorials.jenkov.com/java-nio/buffers.html\">Java NIO Buffer</a></li>\n<li><a href=\"https://jongmin92.github.io/2019/03/05/Java/java-reactor-pattern/\">번역 Java Reactor Pattern - 92Hz</a></li>\n<li><a href=\"http://i5on9i.blogspot.com/2013/11/reactor-pattern.html\">쿠…sal: 컴 Reactor Pattern 에 대해 알아보자.</a></li>\n<li><a href=\"https://jeremyko.blogspot.com/2012/05/proactor-design-pattern.html\">쭌안아빠: proactor design pattern (번역)</a></li>\n<li><a href=\"https://riverandeye.tistory.com/entry/1-Reactor-Pattern\">1 Reactor Pattern</a></li>\n<li><a href=\"https://kksuny.tistory.com/19\">Proactor pattern</a></li>\n<li><a href=\"https://sjh836.tistory.com/184\">Reactor Pattern 과 I/O Multiplexing (반응자 패턴, 입출력 다중화, select, epoll, 혼동 포인트, ProjectReactor)</a></li>\n<li><a href=\"https://brunch.co.kr/@myner/42\">리액터패턴 / 프로액터패턴</a></li>\n<li><a href=\"https://github.com/kasun04/nio-reactor\">GitHub - kasun04/nio-reactor: A reference implementation of the Reactor Pattern with Java NIO.</a></li>\n<li><a href=\"http://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf\">Reactor - An Object Behavioral Pattern for Demultiplexing and Dispatching Handles for Synchronous Event</a></li>\n</ol>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\"><a href=\"https://en.wikipedia.org/wiki/Memory-mapped_I/O\">Memory-mapped I/O - Wikipedia</a><a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\"><a href=\"https://en.wikipedia.org/wiki/File_locking\">File locking - Wikipedia</a><a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-3\"><a href=\"https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)\">https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)</a><a href=\"#fnref-3\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-4\"><a href=\"https://github.com/kasun04/nio-reactor\">GitHub - kasun04/nio-reactor: A reference implementation of the Reactor Pattern with Java NIO.</a><a href=\"#fnref-4\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-5\"><a href=\"https://en.wikipedia.org/wiki/Event-driven_architecture\">Event-driven architecture - Wikipedia</a><a href=\"#fnref-5\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-6\"><a href=\"https://dev.to/_staticvoid/node-js-under-the-hood-3-deep-dive-into-the-event-loop-135d\">Node.js Under The Hood #3 - Deep Dive Into the Event Loop - DEV Community</a><a href=\"#fnref-6\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-7\"><a href=\"https://phruse.com/iomt/\">I/O Multiplexing : 간단한 이론 - Phruse</a><a href=\"#fnref-7\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-8\"><a href=\"https://en.wikipedia.org/wiki/Polling_(computer_science)\">Polling(computer scinence)</a><a href=\"#fnref-8\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-9\"><a href=\"https://microservices.io/patterns/data/saga.html\">Saga Pattern</a><a href=\"#fnref-9\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>","frontmatter":{"date":"April 05, 2022","title":"자바 NIO의 동작원리 및 IO 모델","categories":"개발","author":"개발한입","emoji":"💻"},"fields":{"slug":"/fundamental-nio-and-io-models/"}},"prev":{"id":"485157c8-d131-526c-b6b1-d59105dae6b1","html":"<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#step-1-aws-lightsail%EB%9E%80\">STEP 1. AWS Lightsail란?</a></p>\n</li>\n<li>\n<p><a href=\"#step-2-aws-lightsail%EA%B3%BC-github%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-cicd-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8-%EA%B5%AC%EC%B6%95-%EC%98%88%EC%8B%9C\">STEP 2. AWS Lightsail과 Github를 이용한 CI/CD 파이프라인 구축 예시</a></p>\n<ul>\n<li><a href=\"#step-21-spring-boot-application-dockerize\">STEP 2.1. Spring Boot Application Dockerize</a></li>\n<li><a href=\"#step-211-docker-buildkit\">STEP 2.1.1. Docker Buildkit</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-22-lightsail-%EB%B0%B0%ED%8F%AC-%EC%A0%84-%EC%82%AC%EC%A0%84-%EC%9E%91%EC%97%85\">STEP 2.2 Lightsail 배포 전 사전 작업</a></p>\n</li>\n<li>\n<p><a href=\"#step-3-%EC%A0%95%EB%A6%AC\">STEP 3. 정리</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%B6%94%EC%8B%A0\">추신</a></p>\n</li>\n<li>\n<p><a href=\"#step-4-reference\">STEP 4. REFERENCE</a></p>\n</li>\n</ul>\n</div>\n<h1 id=\"개요\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EC%9A%94\" aria-label=\"개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개요</h1>\n<p>이직을 한 후에 너무 바쁘다보니 블로그 포스팅을 신경을 쓰지 못하였다.\n아직도 바쁘긴하지만, 그래도 여유가 조금씩 생기고 있어서 틈틈히 썼던 초안을 다듬어서 올려보려고 노력해보겠다.</p>\n<p>이번 포스팅의 내용은 AWS Lightsail와 Github를 통한 CI/CD 구축 예시이다.</p>\n<h1 id=\"aws-lightsail과-github를-이용한-cicd-파이프라인-구축-예시\" style=\"position:relative;\"><a href=\"#aws-lightsail%EA%B3%BC-github%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-cicd-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8-%EA%B5%AC%EC%B6%95-%EC%98%88%EC%8B%9C\" aria-label=\"aws lightsail과 github를 이용한 cicd 파이프라인 구축 예시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>AWS Lightsail과 Github를 이용한 CI/CD 파이프라인 구축 예시</h1>\n<ul>\n<li>STEP 1. AWS Lightsail란?</li>\n<li>STEP 2. AWS Lightsail과 Github를 이용한 CI/CD 파이프라인 구축 예시\n<ul>\n<li>STEP 2.1. Spring Boot Application Dockerize\n<ul>\n<li>STEP 2.1.1. Docker Buildkit</li>\n</ul>\n</li>\n<li>STEP 2.2 Lightsail 배포 전 사전 작업\n<ul>\n<li>STEP 2.2.1 IAM 계정 생성</li>\n<li>STEP 2.2.2 Github Secret을 통한 보안 작업</li>\n</ul>\n</li>\n<li>STEP 2.3 Github Deploy.yml 파일 작성</li>\n</ul>\n</li>\n<li>STEP 3. 정리</li>\n<li>STEP 4. REFERENCE</li>\n</ul>\n<h2 id=\"step-1-aws-lightsail란\" style=\"position:relative;\"><a href=\"#step-1-aws-lightsail%EB%9E%80\" aria-label=\"step 1 aws lightsail란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1. AWS Lightsail란?</h2>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 63.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAABfUlEQVQ4y41SbW7bMAz1OXeOnWVH6CV2g/3egBYYNgwD7Dpp7MaSFYkfeoVoK3WaBBuBB1CS+fj46EaPfxBPAeQGxNnhOE0Yx1eICHLOUNUFJWfCqXzLjFNMSPMEpRPYHQxKEU1WtgIg42OoZiN9x0J+Ppe8NBOBqljeVJqirO932O9f8PzcYxiGGw0URIS0Aa+T1GjqIcYI5xz8HDA5bygKWRSi2UCiIBazo6Iqxqr6TBhCQN/3CJwxk8IlRSDBGAhzEvjImCIjSTZ7Lq1YOC4I6wKql8UPJrL7wmFgXpZVfEszJIzIxbu13ggrWY1spAAzY7c/YNe16H49ov39hK7rcBjGxc/kofOILIQtx7tCTtDoltyIxXL38xv+fvmE9uEzkjusXdeNR29KsVV4Jiy/TxhB/ZN1LwUlfCQc/YxXHxBZcTXRxjJTeHGpgvD4Fan9cVV4j+BjvlnK0l38C1L7/WKMW9vcvt9VqCkYqn+3FP4rmuuOene0/yF8A62v/nFTa1H1AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"lightsail dashboard\" title=\"lightsail dashboard\" src=\"/static/5756058d14442a00a9fb6291add4f3e0/37523/lightsail-dashboard.png\" srcset=\"/static/5756058d14442a00a9fb6291add4f3e0/e9ff0/lightsail-dashboard.png 180w,\n/static/5756058d14442a00a9fb6291add4f3e0/f21e7/lightsail-dashboard.png 360w,\n/static/5756058d14442a00a9fb6291add4f3e0/37523/lightsail-dashboard.png 720w,\n/static/5756058d14442a00a9fb6291add4f3e0/302a4/lightsail-dashboard.png 1080w,\n/static/5756058d14442a00a9fb6291add4f3e0/203d3/lightsail-dashboard.png 1322w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n   <em>그림 1. 라이트세일 웹 콘솔</em>\n</p>\n<p>Lightsail(이하, 라이트세일)은 AWS에서 2016년에 공표한 서버 호스팅 서비스이다.</p>\n<p>기존 AWS 서비스 중에 하나지만 SQS나 RDS 등과 달리 Lightsail은 아예 독립적인 페이지를 갖고 있는 것을 볼 수가 있다.</p>\n<p>이렇게 구성된 이유는 기존 AWS가 너무 복잡하기 때문인데 실제로, 많이 사용하는 EC2 서비스의 경우에도 네트워크부터 스토리지까지 매우 다양한 옵션들이 존재하며, EC2를 실무에서 써본 분이라고 알겠지만 별도의 VPC와 같은 가상 네트워크가 필수가 되면서 점점 복잡도는 높아지고 있다.</p>\n<p>이러한 복잡도를 낮추고 저렴하게 사용할 수 있는 서비스가 바로 라이트세일이라 볼 수 있다.\n저렴한 가격으로 큰 서버로 옮기게 될 경우에도 익숙한 환경에서 적응할 수 있는 엔트리 모델의 서비스라고 볼 수 있다.</p>\n<p>실제로, 라이트세일은 나중에 EC2로 마이그레이션해주는 도구들과 고정 IP 및 저희가 뒤에 쓸 서비스 내용인 Lightsail container 서비스도 제공해준다.</p>\n<p>글 작성 시점 기준으로 Lightsail은 아래의 기능을 제공해준다.</p>\n<ol>\n<li>인스턴스 (기존 EC2와 비슷)</li>\n<li>컨테이너 (기존 ECS과 비슷)</li>\n<li>데이터베이스 (기존 RDS와 비슷)</li>\n<li>네트워크 (고정 IP 할당 및 DNS 서비스 등)</li>\n<li>스토리지 (기존 S3와 비슷)</li>\n</ol>\n<p>여기서 저희는 1번을 사용하는 것이 아닌 2번을 활용하여 Spring Boot Application을 Dockerize하여 배포파이프라인을 만들고 배포를 진행하는 식으로 진행해 볼 예정이다.</p>\n<p>사용을 해봤을 때 느낀점은 ECS 보다 매우 편리하고 관리하기도 매우 쉬웠다.\n또한, Github Actions API와 궁합도 잘맞아서 앞으로 사이드 프로젝트를 진행할 때 라이트세일 컨테이너를 쓰지않을까 생각해본다.</p>\n<p>좀 더 라이트세일에 대해서 궁금하시면 아래의 링크를 확인해주시면 좋을 것 같다.</p>\n<ol>\n<li><a href=\"https://www.44bits.io/ko/keyword/amazon-lightsail\">아마존 라이트세일(Amazon Lightsail)이란?</a></li>\n<li><a href=\"https://wooncloud.tistory.com/96\">AWS Lightsail - 라이트세일을 소개합니다., 운클라우드</a></li>\n<li><a href=\"https://swiftcoding.org/all-about-amazon-lightsail-billing\">아마존 라이트세일 요금의 모든 것과 비용 관리 방법 (서버 및 리소스 가격 책정 방법) - 스위프트코딩</a></li>\n</ol>\n<p>저희는 라이트 세일 가격정책이나 서비스 내용이 중심이 아니기에 이 부분은 생략을 하고 배포 파이프라인 구축 및 빌드 관련된 이야기를 나눠보고자 한다.</p>\n<h2 id=\"step-2-aws-lightsail과-github를-이용한-cicd-파이프라인-구축-예시\" style=\"position:relative;\"><a href=\"#step-2-aws-lightsail%EA%B3%BC-github%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-cicd-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8-%EA%B5%AC%EC%B6%95-%EC%98%88%EC%8B%9C\" aria-label=\"step 2 aws lightsail과 github를 이용한 cicd 파이프라인 구축 예시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2. AWS Lightsail과 Github를 이용한 CI/CD 파이프라인 구축 예시</h2>\n<p>위에서 잠깐 언급한 내용처럼 저희는 라이트세일 컨테이너 서비스와 Github Action을 활용하여 CI/CD 파이프라인을 구축한다.</p>\n<p>대상이 될 어플리케이션은 간단한 스프링부트 어플리케이션을 활용할 예정이다.</p>\n<p>상세한 프로젝트 코드는 아래를 참고하자.</p>\n<ul>\n<li><a href=\"https://github.com/brewagebear/blog-example/tree/main/ligthsail-example\">brewagebear/blog-example/lightsail-example</a></li>\n</ul>\n<h3 id=\"step-21-spring-boot-application-dockerize\" style=\"position:relative;\"><a href=\"#step-21-spring-boot-application-dockerize\" aria-label=\"step 21 spring boot application dockerize permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.1. Spring Boot Application Dockerize</h3>\n<p>우선, 라이트세일 컨테이너 서비스에 배포를 하기 위해서는 기존 스프링 부트 어플리케이션을 도커라이징해야한다.</p>\n<p>예제 샘플(Dockerfile)은 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\"># syntax=docker/dockerfile:experimental\nFROM openjdk:11-jdk AS build-stage\nWORKDIR /workspace/app\n\nCOPY src /workspace/app/src\nCOPY gradle /workspace/app/gradle\nCOPY gradlew settings.gradle build.gradle /workspace/app/\n\nRUN --mount=type=cache,target=/root/.gradle ./gradlew clean build -x test\nRUN mkdir -p build/dependencies &amp;&amp; (cd build/dependencies; jar -xf ../libs/ligthsail-example-1.0-SNAPSHOT.jar)\n\nFROM openjdk:11-jre-slim\nWORKDIR /tmp\nARG DEPENDENCY=/workspace/app/build/dependencies\n\nCOPY --from=build-stage ${DEPENDENCY}/BOOT-INF/lib ./app/lib\nCOPY --from=build-stage ${DEPENDENCY}/META-INF ./app/META-INF\nCOPY --from=build-stage ${DEPENDENCY}/BOOT-INF/classes ./app/\n\nENTRYPOINT [&quot;java&quot;,&quot;-cp&quot;,&quot;app:app/lib/*&quot;,&quot;io.github.brewagebear.LigthsailApp&quot;]</code></pre></div>\n<p>어려워 보일 수 있으나 한가지씩 뜯어보면 그렇게 어렵지 않다.</p>\n<h3 id=\"step-211-docker-buildkit\" style=\"position:relative;\"><a href=\"#step-211-docker-buildkit\" aria-label=\"step 211 docker buildkit permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.1.1. Docker Buildkit</h3>\n<p>우선 첫 줄에 아래와 같은 명령어가 적힌 것을 볼 수 있다.\n<code class=\"language-text\"># syntax=docker/dockerfile:experimental</code></p>\n<p>이 부분은 <a href=\"https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/reference.md#syntax\">moby/buildkit - syntax</a>에서 내용을 확인할 수 있다.\n즉, 위의 주석은 Buildkit을 활용하여 도커를 빌드할 때 실험적 기능을 키기 위한 옵션 주석이라고 볼 수 있다.</p>\n<p>그렇다면, <strong>BuildKit은 무엇일까?</strong>\nDocker 18.09버전부터 지원되기 시작한 백엔드 도구라고 한다.</p>\n<p>도커의 백엔드와 프론트엔드까지 다루기에는 양이 방대해져서 이 내용은 생략하고, 대략적으로 BuildKit에 장점에 대해서 기존까지의 도커 빌드 히스토리를 추적하여 설명하고자 한다.</p>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 52.222222222222214%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAACAUlEQVQoz2WRWW+bQBSF/f//RR/bt6qpkkhVH9pUSRPH2PFuFhsYVrMEMJjF5qvAUaOqV/p0z8xIZ+6ZGaxVHc2wUHeCDx9v8cOIbz+H3Hx/wPF8NF0gbBc4Ay0tp/84c+LUNpzaEwN3HxAlCfWpxnQ8jnWFabsohiDKD0Rp0pPkGXGWcKiOFE1FUb9T1mVv3HSG9NX2t3TlZweWqs7KECxsj5G2RdJ2Pc+qhhKEOMcSuzhiFwVWXqAIiyiO+/kHl1Gb3rBpa7LyiO3vsfw9ThAg9j6m3+HhvcZ4yeuFN53WFW4YImyH6lS/G3b5zzQEec56JxhrW55ljWdl2zPcqNzPV/xebnrdnY21HU5RYHg+86WMH4b/GnY9KI9sk4SprjPeGYx1k5lweVIFE9Nn48foSYaeHjCzAyLLyJvq7eFaBue3X+ppG7K6JExS3DjCjgKcKOx7F73rUZFzODd91KSuSJuatMhJspTkkDGompKyPvZ02oki1psdSyHYuC5Ly2JumMx0nZWwWJkC2fPQ4xiRJmxcn8fJgl8PI+6HEwZhHNARxAHxa8jdbMW1NOfz44ir0QvXL3O+SlO+dHpy0VfSlNvZipvZkk93Q34MJ0iTKaOXOQPd3PEXY8tMVZAUGWm95mmxQJI3TFSFsdIhM1aVy1qWkWS531P0LcI2MCyDP2sx5lbbyFmmAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"single build\" title=\"single build\" src=\"/static/c10694cb441f39a1580bf64dc7e5df5d/37523/single-build.png\" srcset=\"/static/c10694cb441f39a1580bf64dc7e5df5d/e9ff0/single-build.png 180w,\n/static/c10694cb441f39a1580bf64dc7e5df5d/f21e7/single-build.png 360w,\n/static/c10694cb441f39a1580bf64dc7e5df5d/37523/single-build.png 720w,\n/static/c10694cb441f39a1580bf64dc7e5df5d/302a4/single-build.png 1080w,\n/static/c10694cb441f39a1580bf64dc7e5df5d/07a9c/single-build.png 1440w,\n/static/c10694cb441f39a1580bf64dc7e5df5d/f6a84/single-build.png 1629w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em>그림 1. 싱글 빌드 형태의 Dockerfile</em>\n</p>\n<p>초기에 도커 빌드를 할 때 위와 같은 Dockerfile을 생성하여 빌드를 하곤 하였다.\n그런데 이런 구조의 문제점은 옆에 하드 디스크 같이 보이는 아이콘의 갯수를 보면 이해할 수 있는데 명령행이 시작되면서 갈수록 레이어가 무거워진다는 단점이 존재하였다.</p>\n<p>실제로 이러한 빌드형태로 이미지를 생성하게 되면 상당히 많은 용량을 차지하는 것을 볼 수 있다.</p>\n<p>그렇다면, 이러한 방식을 개선한 점이 없을까?</p>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 56.111111111111114%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAACKklEQVQoz1WRWW/aQBSF+f+/o29tFeWlagtpk6ZtCE2hARvjfbwAXjDglbCEr7JJUDvSp7kaac45997WQFKZRzGa7fHmfZu0KPh83ePy4y1RkuDPg4btfsuRA4fjnucaDv9Rv9e0NMtllaXEqxUPwwnFpmJiOox1m2WaEi2XJOsVm+2G3fOO3WF3vmuT7eHEq3CL5hxfgFVVMo8W+MkCb51hhiEiitBnMyaejxWG+Os1syxltduSbJ+Iy/pPdEq4f96d49bOy7xA12wedQPJshrGQmAGAeZ8jhWETV2beElCkBfEZYUznZ0ED8eXubzMIcxyxoagp6p0FY3uRKenGnQVnTtZbbif6PzSTO4VDS2KCaoKRbfIirwW3J8F67TJ0wYvy5CEw9B2ebQ9ZD/gwfQZ2HOkaYyXFQ1+VjArSqKyPAdqNcU/m1qVJf4sZOK66L7ftKl6HqrjIKKQpCwJspSoyEk2FYuqYlGWrNL0tJTXhDX7455lniNsj6FhNEKK6yLbAtkSqJ6P7nho/pTpet0so04XFQWOP2s6bBVVzit5lTGNYzRT8EfXmbgOiuOclmPWmIwMA9m20adTLH+KIhzsMMB2XbIipRVEc/5FFYL+o0RvJPMgjxnoOr8nKn1Na0z6qspA05CEaNKPaxwHyxGEcUDLtA3OCIMvdz06t12uftxz0b7i4us179od3rY7XN7c8uHnHZ1+n5vhiG+S1PB9JPHp6hpZkfkLW24tN1CYtRIAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"multi staging build\" title=\"multi staging build\" src=\"/static/246fd6be8945ca88fc48efa526b16851/37523/multi-staging-build.png\" srcset=\"/static/246fd6be8945ca88fc48efa526b16851/e9ff0/multi-staging-build.png 180w,\n/static/246fd6be8945ca88fc48efa526b16851/f21e7/multi-staging-build.png 360w,\n/static/246fd6be8945ca88fc48efa526b16851/37523/multi-staging-build.png 720w,\n/static/246fd6be8945ca88fc48efa526b16851/302a4/multi-staging-build.png 1080w,\n/static/246fd6be8945ca88fc48efa526b16851/07a9c/multi-staging-build.png 1440w,\n/static/246fd6be8945ca88fc48efa526b16851/cd7c1/multi-staging-build.png 1547w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em>그림 2. 멀티 스테이징 빌드 형태의 Dockerfile</em>\n</p>\n<p>위와 같은 방식으로 멀티 스테이징 빌드 방식으로 빌드를 할 경우에 좀 더 경량화된 이미지를 갖게된다.</p>\n<p>멀티 스테이징 빌드 방식은 이미지를 만드는 동안 빌드 등에서는 필요한 의존성이 존재하지만, 최종 컨테이너 이미지에는 필요 없는 환경을 제거할 수 있도록 단계를 나누어 이미지를 만드는 기법이다.</p>\n<p>따라서, 위와 같이 경량화된 도커파일을 얻을 수 있다.\n이렇게 되면서 빌드타임에 이점을 가져갈 수 있다.</p>\n<p>이 멀티스테이징 빌드는 많은 사람들에게 각광을 받았고 나온 후에 많은 사람들이 이용하는 빌드 방식이 되었다.</p>\n<p>그러나, 오늘날 빌드파일은 점차 계속해서 복잡해지고 있다.\n이를테면, 최종 이미지에 의존성이 A서비스의 의존성과 B 서비스의 의존성을 갖을 수 있는식으로 말이다.</p>\n<p>최종 이미지에는 두가지 모두 필요하지만, 사용자 입장에서 빌드타임을 더 단축시키기위해 만약, 다른 스테이지지만 최종에 모두 필요한 의존성이라면 병렬로 빌드할 수 있을 것이다.</p>\n<p>그래서 나온 것이 바로 BuildKit이다.</p>\n<p align=\"center\">\n    <img src=\"https://blukat.me/assets/2021/07/buildkit-slide.png\">\n</p>\n<p align=\"center\">\n    <a href=\"https://blukat.me/2021/07/docker-buildkit-speedup/\"><em>그림 3. Buildkit 병렬 빌드 - blukat29, 2021</em></a>\n</p>\n<p>당연히 BuildKit이 이 역할만 하는 애는 아니다.\n따라서, BuildKit이 해당 기능을 위해서만 나온건 아니고, 전반적인 빌드 속도나 기타 편의기능들을 추가한 도구라고 보면될 것 같다.</p>\n<p><a href=\"https://github.com/moby/buildkit#quick-start\">공식 레포지토리</a>를 보면 아래와 같은 핵심 기능을 설명하고 있다.</p>\n<p>Key features:</p>\n<ol>\n<li>Automatic garbage collection</li>\n<li>Extendable frontend formats</li>\n<li>Concurrent dependency resolution</li>\n<li>Efficient instruction caching</li>\n<li>Build cache import/export</li>\n<li>Nested build job invocations</li>\n<li>Distributable workers</li>\n<li>Multiple output formats</li>\n<li>Pluggable architecture</li>\n<li>Execution without root privileges</li>\n</ol>\n<p>여기서, 우리가 사용하는 Key feature는 5번(<strong>Build cache import/export</strong>)에 해당한다고 보면된다.</p>\n<p>사실 우리의 <code class=\"language-text\">Dockerfile</code>은 parallel multi staging build 기능이 필요없는 <code class=\"language-text\">Dockerfile</code>이기 때문이다.</p>\n<p>명령어를 키고 위의 <code class=\"language-text\">Dockerfile</code>을 아래와 같이 바꿔주자.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">... 중략 ...\n\n# AS-IS\nRUN --mount=type=cache,target=/root/.gradle ./gradlew clean build -x test\n\n# TO-BE\nRUN --mount=type=cache,target=/root/.gradle ls -alh /root/.gradle; ./gradlew clean build -x test; ls -alh /root/.gradle\n... 중략 ...</code></pre></div>\n<p>그 후에 아래의 명령어를 활용하여 빌드를 수행해보자.\n<code class=\"language-text\">DOCKER_BUILDKIT=1 docker build -t test/test:1.0.0 . --no-cache --progress=plain</code></p>\n<p>참고로, 여기서 <code class=\"language-text\">DOCKER_BUILDKIT=1</code> 은 Buildkit을 백엔드로 활성화한다는 의미이다.</p>\n<p>명령어를 통해서 초기 빌드 시에 대략 내 노트북 기준 35초 정도 걸리는 것을 확인하였다.\n참고로 TO-BE 부분은 아래의 내용을 확인하기 위해서 작성했다.</p>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 22.22222222222222%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAArElEQVQY032PWQrDMAxEcxOHWPKWxWsWQqH3P9UUixZKP/oxzENCw2iIKSGXgpQzOpdahXOtwn23rCvCPMOHgHlZEEKA8x7WOfE+01pjHEcM133j8Xyi7jtSKSitifcQa60cETOUUnLwV0phOK8L7TiQc0KLG86ScOSIPW5YDCF6i9UZBGugiUBvdWZmafbtQ3+p1+7yzsEwg6ZJnIlgjQEzCX+CRFpL8+kn8AWO93YrQgJ4QgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"nocache\" title=\"nocache\" src=\"/static/07ee0b85ccac6a6c9f96aaf3448a7fa2/37523/nocache.png\" srcset=\"/static/07ee0b85ccac6a6c9f96aaf3448a7fa2/e9ff0/nocache.png 180w,\n/static/07ee0b85ccac6a6c9f96aaf3448a7fa2/f21e7/nocache.png 360w,\n/static/07ee0b85ccac6a6c9f96aaf3448a7fa2/37523/nocache.png 720w,\n/static/07ee0b85ccac6a6c9f96aaf3448a7fa2/302a4/nocache.png 1080w,\n/static/07ee0b85ccac6a6c9f96aaf3448a7fa2/07a9c/nocache.png 1440w,\n/static/07ee0b85ccac6a6c9f96aaf3448a7fa2/c02c7/nocache.png 2472w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em>그림 4. 초기 ls -alh로 검색 시 아무런 캐시 데이터가 없는 것이 확인된다.</em>\n</p>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 56.111111111111114%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABAUlEQVQoz42S6Y7CMAyEeZNeqGjplcRJD9CK93+qWY2boKKlVX9YzmF9mYl96YcBfhxhnYN4DwkBPgSUVYU8z1EUheayLHXNnCLdMae4bIEEhWkCz7q+13M+wLtxntcHvYcVwWCtQo+BzCKorhV+7nfd+x3gWnf9cPEPKBuFbdcdAgdjtLa+3ZBl2Rv6FcjipmkUtqvQOUzLonlr+7tCY9C27b5C5+C8x+/rpftzwCPLzmkszyfqun5b3u/yGaCIWqaI3S4fKZwIDGEdIxE4Ea0ldH48YKyNTYndsrGASvhIwz9MgDhSLjaDM2iiZQI/xoZKeEgQP5qg7RiciWSXCv8AAJdSDK7VaVkAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"init cache\" title=\"init cache\" src=\"/static/2032bf4e54083178a1a262a4f5b58c39/37523/init-cache.png\" srcset=\"/static/2032bf4e54083178a1a262a4f5b58c39/e9ff0/init-cache.png 180w,\n/static/2032bf4e54083178a1a262a4f5b58c39/f21e7/init-cache.png 360w,\n/static/2032bf4e54083178a1a262a4f5b58c39/37523/init-cache.png 720w,\n/static/2032bf4e54083178a1a262a4f5b58c39/302a4/init-cache.png 1080w,\n/static/2032bf4e54083178a1a262a4f5b58c39/b94e3/init-cache.png 1126w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em>그림 5. Gradle Task가 끝난 후 ls -alh 명령 시 아래와 같이 캐시가 적재된다.</em>\n</p>\n<p>우리는 캐시가 적재되었음을 눈으로 확인하였다.\n그렇다면, 아래의 명령어를 통해서 빌드를 수행해보자.</p>\n<p><code class=\"language-text\">DOCKER_BUILDKIT=1 docker build -t test/test:1.0.0 . --progress=plain</code></p>\n<p>총 시간이 대략 1.9초 걸린것을 확인할 수 있다.</p>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 9.444444444444445%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAWElEQVQI11WNUQrAIAxDPUsFp9XV+jW8/8EyUmSwj0eSQpM03UFsztC5Fvxg7qG3GfoYUNUgfO+oreGqNZS5qSI9e8cDYSlLItOfEeZSCkQEOecPISK/+wscQzwA0qosrAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"buildkit cached\" title=\"buildkit cached\" src=\"/static/8772d07d493be68b048c1310a2d0ddc4/37523/buildkit-cached.png\" srcset=\"/static/8772d07d493be68b048c1310a2d0ddc4/e9ff0/buildkit-cached.png 180w,\n/static/8772d07d493be68b048c1310a2d0ddc4/f21e7/buildkit-cached.png 360w,\n/static/8772d07d493be68b048c1310a2d0ddc4/37523/buildkit-cached.png 720w,\n/static/8772d07d493be68b048c1310a2d0ddc4/302a4/buildkit-cached.png 1080w,\n/static/8772d07d493be68b048c1310a2d0ddc4/07a9c/buildkit-cached.png 1440w,\n/static/8772d07d493be68b048c1310a2d0ddc4/bf668/buildkit-cached.png 2328w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em>그림 6. 캐시가 적용되었음을 확인할 수 있다.</em>\n</p>\n<p>즉, BuildKit 캐시를 이용하면 Gradle에 등록된 의존성을 빌드할 때마다 새로 받는 것이 아니라 이미 캐시가 있으면 캐시를 활용하고, 변경된 부분만 사용한다고 볼 수 있다.</p>\n<p>실제로 build.gradle에 lombok만 추가해서 다시 빌드한 결과는 아래와 같다.</p>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 49.44444444444444%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABC0lEQVQoz5WSWY6DMBBEfZKw2gbM6g1I7n+ujqqFZwJRNJOPkhd1P6raCB8CrftO++NBzntat43itv3cYUXNNM/UGUOm76kfBjLGUNt11LYtr8M4Ul3XJBbnGIAGFCehuaoqFgrzPKcsyz7rduMaYZ2jECMDrPfkQmBH2EuluAgqiuJfEhxz39kh4ABCcI0zvv4X5PWDDNzud5qXhZ35GFlhXRmMyICy0yPedf8KFfYALtayKyg5BHScJtJak9KaV0hKyeemaagsy7PDNDc0IyIeJDXgMZRSLMyT75Xi+7R/iwwg3IUjai3lb6wjWn49X/anyIBhfgBinul/+uZlTw4TEDDExEyuRd/oCcU4JO01zlEHAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"add new gradle dependency\" title=\"add new gradle dependency\" src=\"/static/24bb7ac33c0f6d61e2bea6a597eb8040/37523/add-new-gradle-dependency.png\" srcset=\"/static/24bb7ac33c0f6d61e2bea6a597eb8040/e9ff0/add-new-gradle-dependency.png 180w,\n/static/24bb7ac33c0f6d61e2bea6a597eb8040/f21e7/add-new-gradle-dependency.png 360w,\n/static/24bb7ac33c0f6d61e2bea6a597eb8040/37523/add-new-gradle-dependency.png 720w,\n/static/24bb7ac33c0f6d61e2bea6a597eb8040/302a4/add-new-gradle-dependency.png 1080w,\n/static/24bb7ac33c0f6d61e2bea6a597eb8040/07a9c/add-new-gradle-dependency.png 1440w,\n/static/24bb7ac33c0f6d61e2bea6a597eb8040/42b11/add-new-gradle-dependency.png 2364w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em>그림 8. 의존성 추가 시 기존 값은 캐시를 쓰고, 새 의존성은 리빌드 </em>\n</p>\n<p>즉, Buildkit을 활용하면 빌드타임이 빠르게 단축될 수 있다.</p>\n<p>BuildKit에 대해서는 더 할 말이 많은데, 포스팅의 길이가 길어질 것 같아서 우리가 사용하는 기능에 대해서만 다루고 다음으로 넘어가고자 한다.</p>\n<h2 id=\"step-22-lightsail-배포-전-사전-작업\" style=\"position:relative;\"><a href=\"#step-22-lightsail-%EB%B0%B0%ED%8F%AC-%EC%A0%84-%EC%82%AC%EC%A0%84-%EC%9E%91%EC%97%85\" aria-label=\"step 22 lightsail 배포 전 사전 작업 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.2 Lightsail 배포 전 사전 작업</h2>\n<p>일단, 위에서 <code class=\"language-text\">Dockerfile</code>을 Buildkit의 캐시기능을 활용한 멀티스테이징 빌드기법으로 만들었다.</p>\n<p>저걸로 이제 우리는 Spring Application의 이미지를 말 수가 있는데, 이제 남은건 배포 스크립트 설정만 남아있다.</p>\n<p>그 전에 사전작업 몇 가지를 진행하고자한다.</p>\n<ol>\n<li>Lightsail IAM 계정 설정</li>\n</ol>\n<p>이 부분은 보안 상 이점을 가져가기 위해서 ROOT 계정이 아닌 서비스용 IAM 계정을 발급하는 내용이다.</p>\n<p>이 부분은 기존의 AWS Web Console을 통해서 작업할 수 있다.</p>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 27.22222222222222%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAyUlEQVQY052P2QrCMBRE8/eCoIJgP8Sliv0SoVZf3LBqtU2b7d6RpEXwwRcHBk4muUtEfrsjv15xKRqM4xSj+QZRssdkvUOU7DBeZRgsthjGGYbxtvM3j5YZ+rMUvWkKoesKRASvWhYoixz/iyBeZQlmBjHjVj9xOJ5wPl9QVhKN0rCOgh3RD+Zgz8Y6CCnlZ0PPWutwNsbAWtsOI4JzFNjbNyTq2LnwzkspBfEonp+gqhsorQOHIub2I8Rheqt2G+7ufG66ep+9AaW6fAS0RXzFAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"iam setting\" title=\"iam setting\" src=\"/static/32ffa6a8e388cd16c0f3980fd06d55fe/37523/iam-setting.png\" srcset=\"/static/32ffa6a8e388cd16c0f3980fd06d55fe/e9ff0/iam-setting.png 180w,\n/static/32ffa6a8e388cd16c0f3980fd06d55fe/f21e7/iam-setting.png 360w,\n/static/32ffa6a8e388cd16c0f3980fd06d55fe/37523/iam-setting.png 720w,\n/static/32ffa6a8e388cd16c0f3980fd06d55fe/302a4/iam-setting.png 1080w,\n/static/32ffa6a8e388cd16c0f3980fd06d55fe/07a9c/iam-setting.png 1440w,\n/static/32ffa6a8e388cd16c0f3980fd06d55fe/b0c25/iam-setting.png 1935w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em>그림 9. AWS 웹콘솔 - IAM </em>\n</p>\n<p>참고로, 위 두개에 초록색 활성화 버튼이 보이는데 저것은 권장사항보다는 필수사항이라고 생각이 든다. 생각보다 AWS 해킹사태가 빈번하게 발생해서 해커가 인스턴스를 채굴용으로 만들어서 몇 천만원 과금이 발생한 사례가 존재하기도 하였다.</p>\n<ol>\n<li><a href=\"https://velog.io/@gmtmoney2357/aws-%EC%A0%80%EC%97%90%EA%B2%90-2174%EB%A7%8C%EC%9B%90%EC%9D%B4-%EC%97%86%EC%8A%B5%EB%8B%88%EB%8B%A4.-%ED%95%B4%ED%82%B9%EA%B3%BC%EA%B8%88\">aws - 저에겐 2174만원이 없습니다.(해킹과금)</a></li>\n<li><a href=\"https://m.ruliweb.com/best/board/300143/read/56010593?\">aws 해킹때메 2천만원 요금 청구 왔었네</a></li>\n</ol>\n<p>이거말고도 더 많은 사례를 보았고, 심지어 아마존에서는 요즘은 모든 피해사례를 무료로 해주기보다는 일정 금액 손해배상을 요청한다하니 다른건 몰라도 ROOT 계정의 MFA는 필수로 설정하자.</p>\n<p>IAM 계정을 설정하는 이유도 동일하다.\n만약, 해킹을 당하더라도 IAM 계정이 권한이 좁게 주어지면, 해커가 인스턴스 생성이나 그런 행위는 못할 것이기 때문이다.</p>\n<p>귀찮더라도 작업을 진행해보자.</p>\n<p>순서는 아래와 같다.</p>\n<ol>\n<li>IAM 사용자 그룹 생성 (생략 가능)</li>\n<li>IAM 사용자 생성</li>\n<li>IAM 사용자 Accesskey &#x26; Private Key csv 다운로드</li>\n</ol>\n<p>1번은 해도 되고, 안해도 되는 부분이니 2번 부터 수행하고자한다.\nAWS Web Console IAM 대시보드 우측에 액세스 관리 > 사용자를 클릭하여 사용자 추가를 할 수 있다.</p>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 41.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABT0lEQVQoz4WS7c6bMAyFuf/72jWsrJu2Nx8F0tBRoBA7CWeyebWpvxbp0YmdYydS3JRcMD9nrMuKzBm6jv9Ta0XOGURSU/GlfcA/EhquGY80Yc4rUiWk4x90MJLwludTP3N7TaCa0M0LXkRo9pLQ73dcbz/ggsNH9wE7OPi7h+mtxrfo4QaranujSKz7waKLHabtAT4YDVXCVjdN2t5qUx+kgYPpDUy4wY4RP0OAiXeYGGDHU391pz9MAUteIY9rqDCm9MTvbcIzzVhoxcIr1vxSlrxhzrvy5JOZz5ycqUf85QWq8kIieOvgrAMlQi1VP4eJwcyfSmAiZGaUnFFLUdUzIvVJH/moRoIu9Lh+v8IYA+cchmHAOI6IMf5F4rZtcblc1Oe9h7UWX9tvGIaAMUaklNDICKRM2NOOfT+RcdDpOY435HIpEo+ojk6pb54/rYxmtaf2KlAAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"create iam user\" title=\"create iam user\" src=\"/static/7b9fe636dd028f82f2f850ec38aec8c2/37523/create-iam-user.png\" srcset=\"/static/7b9fe636dd028f82f2f850ec38aec8c2/e9ff0/create-iam-user.png 180w,\n/static/7b9fe636dd028f82f2f850ec38aec8c2/f21e7/create-iam-user.png 360w,\n/static/7b9fe636dd028f82f2f850ec38aec8c2/37523/create-iam-user.png 720w,\n/static/7b9fe636dd028f82f2f850ec38aec8c2/e3189/create-iam-user.png 1035w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em>그림 10. AWS 웹콘솔 - IAM 사용자 추가 </em>\n</p>\n<p>나는 ‘lightsail-container-service’ 라는 계정을 생성하였다.\n이후 정책을 추가하면 된다.\n물론, 만들면서 정책을 추가해도 상관없다.</p>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 107.77777777777777%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAWCAYAAADAQbwGAAAACXBIWXMAAAsTAAALEwEAmpwYAAADC0lEQVQ4y42VSY7zNhCF+/jJLshBcogsAgQJsku324M8aJ5JzSJFvqCKkuzGv+gIqIU5PH6vqki/SdmgLEtkaYqiKDiGYYC1FsaYb8Nag37SqLoZddPhrRtmFCSY5Wi7HvM8Qyn9rdDrtxiLWRvMSuGNBtI0hXcPkFcSUgoopXghUf6fWPgQy8IsSDbDMILoJkzT9APBd9+gDJpRoxlWwlFbpKLDIxeci04DrbJoZ4tMdEiqxo2rbdwglz2Pp3WLpJKo+xmDXglpgRcXuMYF0mZCPVnUE1CPBl6U43CPcEsqVJOFUEA1LriEOT4fMS5RDi8qkHUacl4Fu9mw2DlIEVUdxAwXk8E1ynHyE1zCjOeKXqMeF3hhxmP8mw6aATkbvFkSVJZPPD5itp13ahekjZ/3iOcoorrncRLj9ZlAXPdMvxO2TFgyyTlwp+6EGzltGg2kcqkgQUpTIkcUvXoS7jlcrd2z+osgEV6TkoUa7VJBlukQInSHuVTIaRV0ljO2TZto86vgKUg5FUHRoBwWHichSgXFh+cjKBs0ardscYsLnPwYiRhQdMpRTo58s5bT9aIOGJ+OtoJRdzRfcpgKnGLpaDKBsGohxpXQT3C4hUjksOZw+UJI89RWgi1bi1YD3uWAjz9+w/H2QFC2zvZqmQhiMXBRthxuVaagw6gX1xxaiAk4P/7B4f1XXMIAOTWpelb5shZmayfuwxfLJEb53QXrETg+/sS/559xTULE9YhY9HsDb7aKF8HN8sc1YLsMsROOwMn/G++nX3Dy7zjcYvi5gJhc9Ylyuw2uKAsuQbrS5Sz+yOVWFIuiB47+X/g4/8SCt1S4Zp0srlHBlramdoQut7e04jYqB42S5ueVsBqAz8cRXvg74loyxVZNInj3fJz9FH4uXR+OhotBhHxD1oPYsrVAry38vEUiLTe2e20oDIsQoV80+0NAQcQUz7V43pRx1sjKCt0wQFtAGQttwDHpBaPS/MTTHI2pdW6L7bdaLBFafvKncYRd/3Reg/oU23P/Om/MD+vNsuA/xmOSsKXQc9wAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"create iam policy\" title=\"create iam policy\" src=\"/static/2c3587eb14c6406d505a9cb69fdd7f0d/37523/create-iam-policy.png\" srcset=\"/static/2c3587eb14c6406d505a9cb69fdd7f0d/e9ff0/create-iam-policy.png 180w,\n/static/2c3587eb14c6406d505a9cb69fdd7f0d/f21e7/create-iam-policy.png 360w,\n/static/2c3587eb14c6406d505a9cb69fdd7f0d/37523/create-iam-policy.png 720w,\n/static/2c3587eb14c6406d505a9cb69fdd7f0d/36c33/create-iam-policy.png 946w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em>그림 11. AWS 웹콘솔 - IAM 사용자 정책 추가 </em>\n</p>\n<p>읽기, 쓰기 모두 ContainerService에 해당하는 권한을 추가하였다.\n단, 쓰기에서 CreateContainerService는 권한을 제거하였다. (루트 계정으로 생성하기 때문)</p>\n<p>따라서, 쓰기에는 ECR과 같은 솔루션을 쓸지는 모르겠지만</p>\n<ol>\n<li>CreateContainerServiceDeployment</li>\n<li>CreateContainserServiceRegistryLogin</li>\n<li>RegisterContainerImage</li>\n<li>UpdateContainerService</li>\n</ol>\n<p>정도면 될 것 같다.</p>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 594px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 87.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsTAAALEwEAmpwYAAAC0UlEQVQ4y42UW4scRRiGZ2+M4CGg/hBzk/WXeBEELzxHEP0hRjQJiUgg3nujUQkbwVtxMZPNssxmd5KZnZme6XNXT58PVY9UzfRkICyk4aGrv/rq/Q5VXb39/X0ODw/p9/uMRiNc12WxWGDb9kvjOA6WZTGdTukdHx8TRRG+7xPHMXmeG7IsM6Rpuhlr9Ny2TY81SZIghKA3Ho+NIRaCNEkIAt9EDIJgE0SPNZ7nGbS/TkLb9PxyuTQopegNh0PsxQLLFYydhKfziIUvTCZFUVBVlYmuRfQiLaBtXRXap/M1gl3fHM/H9gLmtovjeiaDMAyN2Ms+ClaCk7MzhqcnW5wynUx48GCPS5fe5b3dXXYvX2Zvb484FsznFp7rUtcVUkpk29K2rRn39M60QFE1pHlBZihppOLJySlfXP2Sjz/9nI8++YyHjx7TKBDLhCTLqRpp/JpWGqRU9M6mFguR82zuE5UQ1yA0FSRyVYoOWEvwRYIXxuRVS1Y2ZFWLKJVZp9E+K8EoYzhziUq1dniOn7eULcRpjuV4FDrF9VMriAppgmvfepXhzBicuMBL681kx7KB3+7/xbff3+S7G7f54fZPXP/xDtdu3GLwdEwmISzkWnArw8Fohh0XpuROTDvmwPtXPmBnZ4fXXn+DNy9e5K233+GVC69y78/7ph1B3j4XHE9mm751YjpL0ZVfQZAU2IHAckPcKMGPMzyRIvJVRaJS2xnOmEcpXlJtyhVb6O+0bCmq2pyAWu8mIBVml8U6gU0Px9MZqerK5AVMf9OWqZ/wbOFjxyVhqfByiV8ogpIVBVQt9Cbrc1g2kqpVL9JI6lbRSMwZ1O9WqnP/ld5gMCBNE0QUmQviPITQ8xF+EDKaB/z6n8O9hy6/9x3+6Dv88q/DyTSgd3R0ZK4dfbN0t8p5hEGA5fj8M5hz9c4BX9094Ou7B3zz8wEf3nrE349n/A8HeOzVPwDRcQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"iam arn setting\" title=\"iam arn setting\" src=\"/static/a644e983c2d6b29bde78c7a59d874f53/5fd3e/iam-arn-setting.png\" srcset=\"/static/a644e983c2d6b29bde78c7a59d874f53/e9ff0/iam-arn-setting.png 180w,\n/static/a644e983c2d6b29bde78c7a59d874f53/f21e7/iam-arn-setting.png 360w,\n/static/a644e983c2d6b29bde78c7a59d874f53/5fd3e/iam-arn-setting.png 594w\" sizes=\"(max-width: 594px) 100vw, 594px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em>그림 12. AWS 웹콘솔 - IAM 사용자 정책 추가 (ARN 세팅) </em>\n</p>\n<p>쓰기 기능은 ARN이 설정이 가능한데, 일단 명시적인 group-id를 얻으면 좋겠으나 현재는 그 값을 구하기 어려운 상황(컨테이너 생성 전)이라 id는 *로 와일드 카드를 추가해둔다.</p>\n<p>이 정도면 충분하지 않을까 생각을 해본다.</p>\n<p>그 후 IAM 사용자의 AccessKey &#x26; SecretKey를 Github Action에 사용하기 위해서 csv를 등록한 뒤에 github에 실제로 추가를 해야한다.</p>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 60.55555555555555%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABzklEQVQoz31TSW7jMBDU2Y4tURJXcZEoarEdO0iQw9xm/v+pGrC9YGIDcyhQJLurq4utwocEFxLeKoEdkw/k/R3/nj+jZQJtxQmccRSttDBufAn0cUWfjvDxgB1TL8RbJlFXHL+cw+/zB/6cL/geIgomLLRLqFrzIymMB8T5nUi7MEG7EbafKTZ/u2FF50bMIWKJM6Y+oeMaRS0sxvUCPx4epPtaEVFczkTa9TORumGhtQvXvbAJpZmxrTU2lSQUjFtKaJX/4Z8JM+JygYsH1NKhFu663r6ZuJ0Jh1YFcN2jkR5FJsoKnx+gbAwpFd1AikyYYPwE7dNN5URndljQSEexZaOvhMvpixQ+G58Ds28DeXmiwvPpE8v7F8blgjBebVF2JLtyTpFlZoMr3mFb8pfR2ewbvNUGpRrBdEJjVzR2QaUS9jJiUwrKu4spGuWplUyYVWbp15b1C/LdA893t/uC8Q4hHaHc+HiYXNHFFdPxk9ZGBbS6/y8ejyL9jOPHN1odyIdaWuQipdBgrgPzFqU0NNx39dlb2UVw00OYASGdMPgEIR2KSjj6K3JQ2WoipRa4QtUZQmkMdrXE7jYJuSDXAdmuPDK5C28jWmHxF9yyNdLVtRiiAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"github secret\" title=\"github secret\" src=\"/static/b0e39b436832bc1509b544d5172b2583/37523/github-secret.png\" srcset=\"/static/b0e39b436832bc1509b544d5172b2583/e9ff0/github-secret.png 180w,\n/static/b0e39b436832bc1509b544d5172b2583/f21e7/github-secret.png 360w,\n/static/b0e39b436832bc1509b544d5172b2583/37523/github-secret.png 720w,\n/static/b0e39b436832bc1509b544d5172b2583/302a4/github-secret.png 1080w,\n/static/b0e39b436832bc1509b544d5172b2583/33c9c/github-secret.png 1133w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em>그림 13. Github - github action 대상 프로젝트에 secret 등록 </em>\n</p>\n<p>위와 같이 진행하면 사전작업은 끝이다.\n자 이제 배포 스크립트를 작성해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Build and deploy Docker app to Lightsail\n\n<span class=\"token key atrule\">on</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">push</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">branches</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> main <span class=\"token comment\"># 배포 트리거 대상 브랜치 on.push.branch -> 해당 브랜치가 푸시될 때 트리깅</span>\n\n<span class=\"token key atrule\">env</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">AWS_REGION</span><span class=\"token punctuation\">:</span> ap<span class=\"token punctuation\">-</span>northeast<span class=\"token punctuation\">-</span><span class=\"token number\">2</span> \n  <span class=\"token key atrule\">AWS_LIGHTSAIL_SERVICE_NAME</span><span class=\"token punctuation\">:</span> amazon<span class=\"token punctuation\">-</span>lightsail<span class=\"token punctuation\">-</span>container<span class=\"token punctuation\">-</span>example <span class=\"token comment\"># 실제 lightsail에 올라갈 이미지 명</span>\n\n<span class=\"token key atrule\">jobs</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">deploy</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Build and deploy\n    <span class=\"token key atrule\">runs-on</span><span class=\"token punctuation\">:</span> ubuntu<span class=\"token punctuation\">-</span>latest\n    <span class=\"token key atrule\">defaults</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">working-directory</span><span class=\"token punctuation\">:</span> ligthsail<span class=\"token punctuation\">-</span>example <span class=\"token comment\"># github project내에 배포할 대상 프로젝트 디렉토리</span>\n    <span class=\"token key atrule\">steps</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Checkout <span class=\"token comment\"># 해당 working-directory checkout (트리깅 브랜치 최신버전)</span>\n        <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/checkout@v2\n        \n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Install Utilities <span class=\"token comment\"># 필수 유틸리티 다운로드 </span>\n        <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">|</span><span class=\"token scalar string\">\n          sudo apt-get update\n          sudo apt-get install -y jq unzip</span>\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Install AWS Client <span class=\"token comment\"># AWS SDK 다운로드 (LightSail 이미지 푸시 및 배포를 위함)</span>\n        <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">|</span><span class=\"token scalar string\">\n          curl \"https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip\" -o \"awscliv2.zip\"\n          unzip awscliv2.zip\n          sudo ./aws/install || true\n          aws --version\n          curl \"https://s3.us-west-2.amazonaws.com/lightsailctl/latest/linux-amd64/lightsailctl\" -o \"lightsailctl\"\n          sudo mv \"lightsailctl\" \"/usr/local/bin/lightsailctl\"\n          sudo chmod +x /usr/local/bin/lightsailctl</span>\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Configure AWS credentials <span class=\"token comment\"># 입력된 IAM 사용자 액세스키 &amp; 시크릿키 검증</span>\n        <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> aws<span class=\"token punctuation\">-</span>actions/configure<span class=\"token punctuation\">-</span>aws<span class=\"token punctuation\">-</span>credentials@v1\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">aws-region</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> env.AWS_REGION <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n          <span class=\"token key atrule\">aws-access-key-id</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> secrets.AWS_ACCESS_KEY_ID <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n          <span class=\"token key atrule\">aws-secret-access-key</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> secrets.AWS_SECRET_ACCESS_KEY <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Build Docker Image <span class=\"token comment\"># Docker Buildkit 빌드</span>\n        <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> DOCKER_BUILDKIT=1 docker build <span class=\"token punctuation\">-</span>t $<span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> env.AWS_LIGHTSAIL_SERVICE_NAME <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">:</span>release .\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Push and Deploy <span class=\"token comment\"># 이미지 푸시 및 배포</span>\n        <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">|</span><span class=\"token scalar string\">\n          service_name=${{ env.AWS_LIGHTSAIL_SERVICE_NAME }}\n          aws lightsail push-container-image \\\n            --region ${{ env.AWS_REGION }} \\\n            --service-name ${service_name} \\\n            --label ${service_name} \\\n            --image ${service_name}:release\n          aws lightsail get-container-images --service-name ${service_name} | jq --raw-output \".containerImages[0].image\" > image.txt\n          jq --arg image $(cat image.txt) '.containers.app.image = $image' container.template.json > container.json\n          aws lightsail create-container-service-deployment --service-name ${service_name} --cli-input-json file://$(pwd)/container.json</span></code></pre></div>\n<p>위에 각 스텝마다 간단히 주석을 달아놨다.\n사실, AWS SDK를 직접 내려받아서 AWS CLI로 처리를 하는 것을 볼 수가 있다.</p>\n<p>위의 코드를 github action을 사용할 프로젝트에 <code class=\"language-text\">.github/workflows</code> 디렉토리 밑에 두면 실제로 액션이 수행된다.</p>\n<p>한번 main 브랜치에 푸시를 하면 이런식으로 github action이 동작하는 것을 볼 수 있다.</p>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 47.22222222222222%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAzElEQVQoz6WR0WqEMBBFY6ImxiTGGHW7UrZ96P9/4inRLZTSh2ofDsNwYTiXEWO+E58M+Y4f10vk24NpfUWkZSOkFdn01NqdwKO0Q9uIi8uODRlhw0TbBYTUCGWuIzWq7REuzoRxRZZFGaq6u0xjPGIYF9btHTfMWD9hXEL3Ed2Pp+l8QnQusT0+jkUZZGNP1y12Ze6Vy6FiWOz+U/nHwTfckI9gf853/mr6fIr1eTeM80aYXvDphg0ztRlQOiBbR9X0VM3X/I0jU9rzCW+rxqHVwUX7AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"github action\" title=\"github action\" src=\"/static/30332950704c42eb49efe97ffb800180/37523/github-action.png\" srcset=\"/static/30332950704c42eb49efe97ffb800180/e9ff0/github-action.png 180w,\n/static/30332950704c42eb49efe97ffb800180/f21e7/github-action.png 360w,\n/static/30332950704c42eb49efe97ffb800180/37523/github-action.png 720w,\n/static/30332950704c42eb49efe97ffb800180/302a4/github-action.png 1080w,\n/static/30332950704c42eb49efe97ffb800180/07a9c/github-action.png 1440w,\n/static/30332950704c42eb49efe97ffb800180/00e09/github-action.png 2195w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em>그림 14. Github Action 수행 결과 </em>\n</p>\n<p>하지만, 에러가 발생하는 것을 볼 수 있다.\n이 부분은 AWS CLI로 라이트세일 컨테이너 서비스 배포를 처리할 때 발생하는 템플릿 파일이 없어서 발생하는 에러이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token punctuation\">...</span>중략<span class=\"token punctuation\">...</span>\njq <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>arg image $(cat image.txt) '.containers.app.image = $image' container.template.json <span class=\"token punctuation\">></span> container.json <span class=\"token comment\"># container.tamplate.json이 없어서 에러 발생 </span>\n<span class=\"token punctuation\">...</span>중략<span class=\"token punctuation\">...</span></code></pre></div>\n<p>이 파일을 추가하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token punctuation\">{</span>\n  <span class=\"token key atrule\">\"containers\"</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token key atrule\">\"app\"</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token key atrule\">\"image\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token key atrule\">\"environment\"</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token key atrule\">\"APP_ENV\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"release\"</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      <span class=\"token key atrule\">\"ports\"</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token key atrule\">\"80\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"HTTP\"</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token key atrule\">\"publicEndpoint\"</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token key atrule\">\"containerName\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"app\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token key atrule\">\"containerPort\"</span><span class=\"token punctuation\">:</span> <span class=\"token number\">80</span><span class=\"token punctuation\">,</span>\n    <span class=\"token key atrule\">\"healthCheck\"</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token key atrule\">\"healthyThreshold\"</span><span class=\"token punctuation\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span>\n      <span class=\"token key atrule\">\"unhealthyThreshold\"</span><span class=\"token punctuation\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span>\n      <span class=\"token key atrule\">\"timeoutSeconds\"</span><span class=\"token punctuation\">:</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span>\n      <span class=\"token key atrule\">\"intervalSeconds\"</span><span class=\"token punctuation\">:</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span>\n      <span class=\"token key atrule\">\"path\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"/\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token key atrule\">\"successCodes\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"200-499\"</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 파일이 필요한 이유는 위 배포 스크립트에서 jq를 통해서 <code class=\"language-text\">container.template.json</code> 에 생성된 이미지 이름을 넣고, 아래의 명령을 수행하기 때문이다.</p>\n<p><code class=\"language-text\">aws lightsail create-container-service-deployment --service-name ${service_name} --cli-input-json file://$(pwd)/container.json</code></p>\n<p>따라서, aws cli로 배포를 진행할 때 해당 json으로 헬스 체크나 port등을 처리한다 볼 수 있다.</p>\n<p>Spring boot Application 기준으로 디렉토리 트리를 보자면 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">.github\n  └── workflows\n       └── deploy.yml\nligthsail-example\n├── Dockerfile\n├── build.gradle\n├── container.template.json\n├── gradle\n├── gradlew\n├── gradlew.bat\n├── settings.gradle\n└── src</code></pre></div>\n<p>위와 같은 구조로 세팅을 하면 보면 된다.\n따라서, 이 글을 보면서 구축을 하려면 어플리케이션 디렉토리와 <code class=\"language-text\">.github/workflows</code> 디렉토리를 분리하고, 어플리케이션 디렉토리 최상단에 <code class=\"language-text\">Dockerfile</code> 과 <code class=\"language-text\">container.tamplate.json</code>을 위치시키면 된다고 보면된다.</p>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 33.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAwklEQVQoz52RyRKDIBBEJ5sQlUVQlKipMpVD/v8HO8WoWU5ZDq8aGmaYaqhuR9imhwsDVNWitOEnUo2tT4zxEeSXhmmTNKF9hHbdR1TVwdY92uGC0E9wYQS50EMqj9I2TK48ZFF9jSgsstwwsnQg20QUugbtJGiTgbYJ8Rd7UYJ4Ku2RHTUOUuEgV/2evVQQuZ0Hi+crB8u5LNmlPA2v49N/5Pqe73rXLOc0TDf47owqDPzTTDuyvnqevVdm3yyPrQ3vaQWk6g/TvV0AAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"deploy success\" title=\"deploy success\" src=\"/static/06c5a9e26da17259109c5eb6bd703e20/37523/deploy-success.png\" srcset=\"/static/06c5a9e26da17259109c5eb6bd703e20/e9ff0/deploy-success.png 180w,\n/static/06c5a9e26da17259109c5eb6bd703e20/f21e7/deploy-success.png 360w,\n/static/06c5a9e26da17259109c5eb6bd703e20/37523/deploy-success.png 720w,\n/static/06c5a9e26da17259109c5eb6bd703e20/302a4/deploy-success.png 1080w,\n/static/06c5a9e26da17259109c5eb6bd703e20/07a9c/deploy-success.png 1440w,\n/static/06c5a9e26da17259109c5eb6bd703e20/4a10c/deploy-success.png 2219w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em>그림 14. Github Action - 배포 성공 </em>\n</p>\n<p>설정이 정상적이라면 위와 같이 배포 성공했음을 알 수가 있을 것이다.\n그렇다면, 라이트세일 콘솔에서 제대로 반영됐는지 확인해보자.</p>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 103.8888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsTAAALEwEAmpwYAAACvElEQVQ4y5VV247TMBDNB/MFfA1P/AEP8MILDyAQQiwLAi1Lm6Zt7okTx3f7oHE23XbbXYSlo3HcZHxm5sw0cc7BWosQQrQEYwyU0tBax73WJtrlNzr33oNWAE5skpclPn+9AhsGpOkGN79vsdvnWK3W2Gwy5HmBTZYhy7bY5znSTYZ1mkIpNTtyBtAcMAIheCTZbod3Hz5gGEcUZQU2jJBSRhbLRxdXmBnK7XekL55h9fI5nGBIKFRaFAKFQ8/aOkjjoAjWxWdlPbT1MM7D+hDhAyC1QV6UKMsq+kjOLg4BNTfY9gr5oCP2TCFtJ2SdwKad8DMf8KsYcFOOuN71uMo63FYczgckFBbnPLIzLsRDf2A976kolAo+crC+R1nVqJv2gKZp0bYtvHNIKOlX365R1TXayYAJjZprjNKgmQzKUYNrh05aGB+ezGk4DpmY1lU1oyxRFAWkEFEQdLP3DovECLSn9Nxjlk7i727tGMOf7R7rfYnbbYGmYxg5x8gncD5hHDmmScwQIqYIRxpcHMcq04EXHJAKUBpyaOC0wKWCETuSFUVkI3OPRSkHh7RqXuHNj1f4kn2cCxJCfPnYGmvBpwl104AxBqUkrLOXHfaixdvr1/h08z62HX1IoS0hLhBCRmZBT7BjDavl3HZLyPS0OIUHtHKQUkWnKnbL3DEz5r02JhZlwUWGQgj0rIfzDv+zlmKcOSQ2w8jBhTh58SngeP/QIelMywlWq4sMzpz9i6FzFnZisGKEowFg7f3MC+HRUB91SDKgOUhTo67r2Cl0tiTemHm4zvb8ssUeHHZswCrbI90VWGV5tPuiioOgrBr0PYuSIZB86JKHIZ84FMaBKQtuAnrpwKSNMzDcCXv5m/BHA2Lukrn5QnhYZaWQrtfYbbfo2jbK6JgFaY80u+sybLabg/68kSdM/wKhXmTN6RF8xwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"lightsail success\" title=\"lightsail success\" src=\"/static/4aa2309efce24a141012e31272b90c56/37523/lightsail-success.png\" srcset=\"/static/4aa2309efce24a141012e31272b90c56/e9ff0/lightsail-success.png 180w,\n/static/4aa2309efce24a141012e31272b90c56/f21e7/lightsail-success.png 360w,\n/static/4aa2309efce24a141012e31272b90c56/37523/lightsail-success.png 720w,\n/static/4aa2309efce24a141012e31272b90c56/8ea22/lightsail-success.png 1023w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em>그림 15. Lightsail 웹 콘솔 - 배포 성공 </em>\n</p>\n<p>주어진 Public domain으로 요청을 보냈을 때 (<code class=\"language-text\">api/v1/greeting</code>) 안녕하세요가 나오는지 확인해보자.</p>\n<p align=\"center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 18.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAcElEQVQY062ISw7CIAAFOZombqxiqXytx+cALIAlTFMWfvZ9yWQmTzzmJ7My3KXCWI/zr+EdawPWBZxf0dphjB9Wi8GHlRDeqEVznSTTTXI6XxAxRlJK1FrJuVBKGf4nf/7do8u3fxEcPNFao/d+GBuUKxNCKSFjvgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"api call success\" title=\"api call success\" src=\"/static/209cbb8b47d221e0efa28668507a3611/37523/api-call-success.png\" srcset=\"/static/209cbb8b47d221e0efa28668507a3611/e9ff0/api-call-success.png 180w,\n/static/209cbb8b47d221e0efa28668507a3611/f21e7/api-call-success.png 360w,\n/static/209cbb8b47d221e0efa28668507a3611/37523/api-call-success.png 720w,\n/static/209cbb8b47d221e0efa28668507a3611/d9217/api-call-success.png 904w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</p>\n<p align=\"center\">\n    <em>그림 16. API 호출 성공</em>\n</p>\n<p>위와 같이 정상적으로 나옴을 확인할 수 있었다.</p>\n<h2 id=\"step-3-정리\" style=\"position:relative;\"><a href=\"#step-3-%EC%A0%95%EB%A6%AC\" aria-label=\"step 3 정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3. 정리</h2>\n<p>이번 기회에 EC2와 달리 간단하게 설치할 수 있는 VPS 서비스인 LightSail CI/CD를 만들어보았다.</p>\n<p>물론, 라이트세일 인스턴스 서비스가 아닌 컨테이너 서비스를 활용하였다는 것을 잊으면 안된다.</p>\n<p>우리는 이 컨테이너 서비스에 이미지를 적재하기 위해서 아래와 같은 것들을 배웠다.</p>\n<ol>\n<li>싱글 빌드</li>\n<li>멀티스테이징 빌드</li>\n<li>Buildkit을 활용한 의존성 캐시 + 멀티스테이징 빌드</li>\n</ol>\n<p>3을 통해서 좀 더 빠르게 빌드를 할 수 있었고, 이 만들어진 Dockerfile을 적재하기 위해서\nGithub Action을 사용하고자 하였다.</p>\n<p>그 전에 먼저 IAM 사용자를 추가하여 보안성을 확보하였고, 해당 액세스 키랑 시크릿 키도 Github Secret을 통해서 처리되게끔 설정하였다.</p>\n<p>그 뒤에 Github Action의 배포 스크립트를 통해서 실제 배포를 진행하였다.\n많은 과정을 겪었는데, 한번 익숙해지면 금방 할 수 있지 않을까 싶다.</p>\n<hr>\n<h2 id=\"추신\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EC%8B%A0\" aria-label=\"추신 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추신</h2>\n<p>위의 내용 중 상당 부분을 아래의 레포지토리를 참고하였습니다.</p>\n<ul>\n<li><a href=\"https://github.com/arch-inc/amazon-lightsail-containers-test\">arch-inc/amazon-lightsail-containers-test</a></li>\n</ul>\n<p>해당 레포지토리 작성자가 쓴 글도 보시면 매우 좋습니다.</p>\n<ul>\n<li><a href=\"https://zenn.dev/junkato/books/how-to-deploy-research-web-apps/viewer/introduction\">研究プロジェクトのWebアプリを気軽にデプロイする方法</a></li>\n</ul>\n<p>일어라 저는 파파고로 번역해서 읽었습니다.</p>\n<p>프로젝트 전체 예시는 아래에서 확인하실 수 있습니다.</p>\n<ol>\n<li><a href=\"https://github.com/brewagebear/blog-example/blob/main/.github/workflows/deploy.yml\">Github Action 배포 스크립트</a></li>\n<li><a href=\"https://github.com/brewagebear/blog-example/tree/main/ligthsail-example\">brewagebear/blog-example/lightsail-example</a></li>\n</ol>\n<p>모쪼록 긴 글이지만 읽어주셔서 감사합니다.</p>\n<hr>\n<h2 id=\"step-4-reference\" style=\"position:relative;\"><a href=\"#step-4-reference\" aria-label=\"step 4 reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 4. REFERENCE</h2>\n<ol>\n<li><a href=\"https://www.44bits.io/ko/keyword/amazon-lightsail\">아마존 라이트세일(Amazon Lightsail)이란?, 44BITS, 2021</a></li>\n<li><a href=\"https://wooncloud.tistory.com/96\">AWS Lightsail - 라이트세일을 소개합니다, 운클라우드, 2022</a></li>\n<li><a href=\"https://swiftcoding.org/all-about-amazon-lightsail-billing\">아마존 라이트세일 요금의 모든 것과 비용 관리 방법 (서버 및 리소스 가격 책정 방법), 스위프트코딩, 2020</a></li>\n<li><a href=\"https://github.com/moby/buildkit\">moby/buildkit, github</a></li>\n<li><a href=\"https://blukat.me/2021/07/docker-buildkit-speedup/\">Docker Buildkit으로 빌드 시간 단축하기, blukat29, 2021</a></li>\n<li><a href=\"https://earthly.dev/blog/compiling-containers-dockerfiles-llvm-and-buildkit/\">Compiling Containers – Dockerfiles, LLVM and BuildKit, Adam Gordon Bell, 2021</a></li>\n<li><a href=\"https://vsupalov.com/buildkit-cache-mount-dockerfile/\">How to Speed Up Your Dockerfile with BuildKit Cache Mounts, vsupalov, 2022</a></li>\n<li><a href=\"https://github.com/arch-inc/amazon-lightsail-containers-test\">arch-inc/amazon-lightsail-containers-test</a></li>\n<li><a href=\"https://zenn.dev/junkato/books/how-to-deploy-research-web-apps/viewer/introduction\">研究プロジェクトのWebアプリを気軽にデプロイする方法, Jun Kato, 2021</a></li>\n</ol>","frontmatter":{"date":"October 23, 2022","title":"AWS Lightsail과 Github를 이용한 CI/CD 파이프라인 구축 예시","categories":"개발 인프라","author":"개발한입","emoji":"💻"},"fields":{"slug":"/ligthsail-ci-cd-setup/"}},"site":{"siteMetadata":{"siteUrl":"https://brewagebear.github.io","comments":{"utterances":{"repo":"brewagebear/blog-comments"}}}}},"pageContext":{"slug":"/concurrency-distributed-transaction-with-tcc/","nextSlug":"/fundamental-nio-and-io-models/","prevSlug":"/ligthsail-ci-cd-setup/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}