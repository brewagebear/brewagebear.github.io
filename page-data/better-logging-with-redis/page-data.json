{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/better-logging-with-redis/",
    "result": {"data":{"cur":{"id":"287f6419-a82a-51e9-8464-09d3be200c24","html":"<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#step-1-redis-write-back%EC%9D%84-%EB%8F%84%EC%9E%85%ED%95%98%EB%8A%94-%EC%97%AC%EC%A0%95%EA%B8%B0\">STEP 1. Redis Write Back을 도입하는 여정기</a></p>\n</li>\n<li>\n<p><a href=\"#step-1-redis-collection-%EC%84%A4%EA%B3%84-%EB%B0%8F-%EA%B5%AC%ED%98%84\">STEP 1. Redis Collection 설계 및 구현</a></p>\n<ul>\n<li><a href=\"#step-21-%EC%B6%94%EA%B0%80-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD\">STEP 2.1 추가 요구사항</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-3-%EB%AC%B8%EC%A0%9C%EC%A0%90\">STEP 3. 문제점</a></p>\n</li>\n</ul>\n</div>\n<h1 id=\"목차\" style=\"position:relative;\"><a href=\"#%EB%AA%A9%EC%B0%A8\" aria-label=\"목차 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>목차</h1>\n<ul>\n<li>개요</li>\n<li>STEP 1. Redis Write Back을 도입하는 여정기</li>\n<li>STEP 2. Redis Collection 설계 및 구현\n<ul>\n<li>STEP 2.1 추가 요구사항</li>\n</ul>\n</li>\n<li>STEP 3. 문제점</li>\n<li>STEP 4. REFERENCE</li>\n</ul>\n<h1 id=\"개요\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EC%9A%94\" aria-label=\"개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개요</h1>\n<p>현재 재직 중인 회사에서 추천 시스템을 도입하기 위해서 기존의 로깅 방식에 대해서 고도화가 필요했었다.</p>\n<p>일단, 아주 단순하게 기존 사용자에게 추천됐던 아이템과 읽은 아이템을 토대로 추천 시스템을 만들고자하였다.</p>\n<p>이 업무를 진행하기에 앞서 진행되어야하는 부분이 바로 어떤 아이템들이 추천되었고, 어떤 아이템을 읽었는지에 대한 로그를 수집하는 일이었다.</p>\n<p>기존에는 사용자가 클릭을 수행하면 바로 DB에 저장이 되는 형식이였으나 사용자가 증가함에 따라 DB 부하 문제도 있고, 개선책을 찾게 되었다.</p>\n<h2 id=\"step-1-redis-write-back을-도입하는-여정기\" style=\"position:relative;\"><a href=\"#step-1-redis-write-back%EC%9D%84-%EB%8F%84%EC%9E%85%ED%95%98%EB%8A%94-%EC%97%AC%EC%A0%95%EA%B8%B0\" aria-label=\"step 1 redis write back을 도입하는 여정기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1. Redis Write Back을 도입하는 여정기</h2>\n<p>그에 대한 개선책으로는 이러한 흐름으로 생각하게 되었다.</p>\n<ul>\n<li>사용자가 클릭하면 이 데이터를 바로 DB로 넣는 부분은 DB 부하의 문제가 존재한다.</li>\n</ul>\n<blockquote>\n<p>그렇다면 어딘가에 클릭했던 내역을 모아두고 일정 시간이 되면 DB에 벌크 삽입(Bulk Insert)하는 방식은 어떨까?</p>\n</blockquote>\n<ul>\n<li>그렇다면 이 내역을 일정 기간 동안 모아둘 곳이 필요한데 어디다 모아둘 것인가?</li>\n</ul>\n<blockquote>\n<p>Redis를 사용하자</p>\n</blockquote>\n<p>위의 내용을 취합하면 우리가 내린 결론은 Redis를 <strong>Write Back</strong> 방식으로 사용하는 것이었다.</p>\n<p>해당 내용은 <a href=\"https://youtu.be/mPB2CZiAkKM?t=530\">우아한테크세미나 - 우아한 Redis</a> 을 참고해보자.</p>\n<p>그 후에 배치 잡을 통하여 Redis Cache에 저장된 값을 DB에 Bulk Insert하는 방식으로 방향을 잡게 되었다.</p>\n<h2 id=\"step-1-redis-collection-설계-및-구현\" style=\"position:relative;\"><a href=\"#step-1-redis-collection-%EC%84%A4%EA%B3%84-%EB%B0%8F-%EA%B5%AC%ED%98%84\" aria-label=\"step 1 redis collection 설계 및 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1. Redis Collection 설계 및 구현</h2>\n<p>기존 Redis에는 사용자에게 추천될 아이템의 캐시만 있었던 상황인데 이제 추가적으로 Data들이 필요해졌다.</p>\n<ol>\n<li>해당 사용자에게 추천된 아이템들 Collection</li>\n<li>해당 사용자가 읽은 아이템 Collection</li>\n<li>해당 사용자가 언제, 읽었고 그 아이템이 추천된 아이템인지를 확인하는 Collection</li>\n</ol>\n<p>Redis Collection을 처음 다루다보니 아주 단순하게 <code class=\"language-text\">nested json</code> 형태로 작업을 하고자하였다. 그러나, 초반부터 난관에 봉착했다.</p>\n<p>그 이유는 아주 단순하다. Redis는 <code class=\"language-text\">nested hash</code> 를 지원안한다.</p>\n<p>예를 들어보자 아래와 같은 데이터 셋을 나는 가지고 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Prod_Color  |   Prod_Count  |   Prod_Price   |   Prod_Info\n------------------------------------------------------------\n  Red        |       12      |       300      |   In Stock\n  Blue       |        8      |       310      |   In Stock</code></pre></div>\n<p>그래서 이걸 토대로 아래와 같은 명령어를 통해서 <code class=\"language-text\">Hashes</code> 로 저장하고자 하였다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">HMSET Records Prod_Color <span class=\"token string\">\"Red\"</span> Prod_Count <span class=\"token number\">12</span> Prod_Price <span class=\"token number\">300</span> Prod_Info <span class=\"token string\">\"In Stock\"</span>\nHMSET Records Prod_Color <span class=\"token string\">\"Blue\"</span> Prod_Count <span class=\"token number\">8</span> Prod_Price <span class=\"token number\">310</span> Prod_Info <span class=\"token string\">\"In Stock\"</span></code></pre></div>\n<p>대충 이 명령어를 수행하면 나올 데이터 셋은 아래와 같을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n  Records : [\n\t\t{\n\t\t\tProd_Color : \"Red\",\n\t\t\tProd_Count : 12,\n\t\t\tProd_Price : 300,\n\t\t\tProd_Info : \"In Stock\"\n\t\t},\n\t\t{\n\t\t\tProd_Color : \"Blue\",\n\t\t\tProd_Count : 8,\n\t\t\tProd_Price : 310,\n\t\t\tProd_Info : \"In Stock\",\n\t\t}\n\t]\n}</code></pre></div>\n<p>그러나, 이런 결과는 Redis에서 허용되지 않는다.</p>\n<p>실제로 위의 명령어를 날린 후 <code class=\"language-text\">HGTALL Records</code> 명령어를 날려보면 이해가 될 것이다.</p>\n<p>그렇다면 위와 같은 데이터 구조를 Redis에서는 못 만드는 것일까?</p>\n<p>방법은 존재한다.</p>\n<p>바로 <strong>접미사(Suffix)</strong> 를 활용하는 방식이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">/*\n Records:Prod_Color 형태로 Hash를 생성한다. \n 여기서는 Records:red / Records:blue 형태로 생성\n*/\nHMSET Records:red Prod_Color <span class=\"token string\">\"Red\"</span> Prod_Count <span class=\"token number\">12</span> Prod_Price <span class=\"token number\">300</span> Prod_Info <span class=\"token string\">\"In Stock\"</span>\nHMSET Records:blue Prod_Color <span class=\"token string\">\"Blue\"</span> Prod_Count <span class=\"token number\">8</span> Prod_Price <span class=\"token number\">310</span> Prod_Info <span class=\"token string\">\"In Stock\"</span>\n\n/* 생성된 Hash를 Set의 멤버로 삽입한다 Set의 키는 Records:Ids */\nSADD Records:Ids red\nSADD Records:Ids blue\n\n/* \n 이를 통하여 Records:Ids로 조회하면 어떤 값들이 들어가있는지 확인 할 수 있다. \n 이렇게 Set을 만듦으로써 전체 Product에 대한 내용은 Set에서 참조 가능하다.\n*/\nSMEMBERS Records:Ids\n\n/* Hash는 단순히 Records:Ids에서 갖고 있는 Item들을 통해 상세한 값을 조회한다. */\nHGETALL Records:ID_OF_MEMBER\n\n/* 아래의 커맨드로 조회가 가능 */\nHGETALL Records:red\nHGETALL Records:blue</code></pre></div>\n<p>자세한 내용은 <a href=\"https://stackoverflow.com/questions/6864968/writing-a-query-to-add-multiple-values-to-a-key-in-redis-hashes\">writing a query to add multiple values to a key in redis hashes</a> 을 참고하면된다.</p>\n<p>여기서 아이디어를 착안하여 아래와 같이 Collection 설계를 진행하였다.</p>\n<p>기존 추천 아이템 설계 Collection은 <code class=\"language-text\">recommend:UserIdKey</code> 를 통하여 각 개인에게 추천된 데이터 리스트들을 담아두었는데 이를 좀 더 확장하였다.</p>\n<ol>\n<li><code class=\"language-text\">recommend:UserIdKey</code></li>\n</ol>\n<p><img src=\"https://user-images.githubusercontent.com/22961251/111896160-6b0ba580-8a0f-11eb-8f86-4d56fbfbfb04.png\" alt=\"redis-collection-ex-1\"></p>\n<p>기존에 사용자 추천 아이템들의 목록을 들고 있는 List</p>\n<ol start=\"2\">\n<li><code class=\"language-text\">userIdKey:readItemId</code></li>\n</ol>\n<p><img src=\"https://user-images.githubusercontent.com/22961251/111896161-6c3cd280-8a0f-11eb-8893-207c5fb4bd0b.png\" alt=\"redis-collection-ex-2\"></p>\n<p>각 사용자가 어떤 아이템을 읽었는지에 대한 SET 각 아이템에 대해서 언제 읽었고, 추천되었는지 여부는 위의 아이디어를 차용하여 <code class=\"language-text\">HashMap</code>으로 처리하였다.</p>\n<ol start=\"3\">\n<li><code class=\"language-text\">userIdKey:readItemId</code></li>\n</ol>\n<p><img src=\"https://user-images.githubusercontent.com/22961251/111896162-6c3cd280-8a0f-11eb-8b7a-c72fb594ac20.png\" alt=\"redis-collection-ex-3\"></p>\n<p>즉, abcd라는 사용자가 읽은 데이터의 경우에는 <code class=\"language-text\">abcd:readItemId</code> SET 콜렉션에 저장이 되고, 위의 유저가 itemId가 1인 아이템이 읽었을 경우에는 <code class=\"language-text\">abcd:1</code> HASH에 저장되게끔 설계를 진행하였다.</p>\n<p>이로써, <code class=\"language-text\">userId:readItemId</code> 콜렉션은 각각의 유저들이 어떠한 아이템을 읽었는가에 대한 전체 아이템 id를 갖고 있는 Set이 되며, <code class=\"language-text\">userId:readItemId</code> 구조의 Hash는 언제 읽었고, 이 아이템이 추천된 아이템인지를 <code class=\"language-text\">recommend:userId</code> 구조의 List에서 조회를 통하여 파악하여 생성하는 식으로 설계하였다.</p>\n<p>즉, 이런 식으로 Redis에서 들고 있다가 Batch를 통해서 일정 사이즈 만큼 chunk를 하여 Bulk Insert하는 방식으로 생각하게 되었다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/22961251/111896163-6cd56900-8a0f-11eb-8d44-d25f572b21ea.png\" alt=\"bulk-insert-code\"></p>\n<p>이후 Batch 처리를 하면서 TTL expire를 설정하여 배치를 돌고나면 캐시를 지우는 식으로 진행하였다.</p>\n<p>이렇게 끝날 줄 알았으나 문제점이 발생하였다.</p>\n<h3 id=\"step-21-추가-요구사항\" style=\"position:relative;\"><a href=\"#step-21-%EC%B6%94%EA%B0%80-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD\" aria-label=\"step 21 추가 요구사항 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.1 추가 요구사항</h3>\n<ul>\n<li>UserRecommendItem 스키마 예시</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/22961251/111896164-6d6dff80-8a0f-11eb-83a8-598968baec49.png\" alt=\"db-schema-ex-1\"></p>\n<ul>\n<li>UserReadRecommendItem 스키마 예시</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/22961251/111896165-6e069600-8a0f-11eb-932d-ee4b50b19def.png\" alt=\"db-schema-ex-2\"></p>\n<p>문제는 <code class=\"language-text\">UserRecommendItem</code> 스키마에 존재했다. 여기에 <code class=\"language-text\">isRead</code> 속성이 추가되면서 <code class=\"language-text\">UserReadRecommendItem</code> 이 삽입된 후에 얘가 실제로 읽었으면 <code class=\"language-text\">true</code> 로 업데이트해야되는 상황이 된 것이다.</p>\n<p>기존에는 사용자가 읽은 부분에서 이 데이터가 읽었는지 안읽었는지 판별을 수행하였는데</p>\n<p>사용자에게 추천된 아이템에도 이 아이템이 읽었는지 안읽었는지에 대한 판별이 필요하다는 요구사항이 추가된 것이다.</p>\n<p>이렇게 되면 아주 큰 문제가 생기는데 바로 <strong>성능문제</strong>이다.</p>\n<p>사실 성능을 생각 안하고 쿼리를 던지면 간단하게 해결할 수 있는 문제일 것이다.</p>\n<p><code class=\"language-text\">UserReadRecommendItem</code> 에 삽입이 끝나면 다시 <code class=\"language-text\">UserRecommendItem</code> 의 값에서 존재하는 부분을 찾아서 <code class=\"language-text\">isRead</code> 를 업데이트하면 된다.</p>\n<p>그러나, 이 부분은 당연히 <strong>성능 상 문제</strong>가 존재한다.</p>\n<blockquote>\n<p>Select UserReadRecommendItem → Select UserRecommendItem → Update UserRecommendItem isRead = true</p>\n</blockquote>\n<p>이런식으로 <strong>2번의 조회 쿼리와 1번의 update 쿼리</strong>가 날라가는데 이는 대량의 데이터에서는 성능을 기대하기 어려울 수밖에 없다고 생각하였다.</p>\n<p>곰곰히 생각해보니 우리는 이미 Redis를 쓰고 있지 않은가?</p>\n<p>아 차라리 <code class=\"language-text\">Bulk Insert</code> 하기 전에 <code class=\"language-text\">Full-Scan</code> 한 데이터 캐시를 들고 있다가 Redis 상에서 처리를 해서 DB에 쑤시는 방법을 생각하게 되었다.</p>\n<p>아주 간단하게 <code class=\"language-text\">userId:readItemId</code> 와 <code class=\"language-text\">userId:recommendItemId</code> 를 추가하였다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/22961251/111896166-6e069600-8a0f-11eb-820f-fb859932b246.png\" alt=\"redis-collection-ex-4\"></p>\n<ol>\n<li><code class=\"language-text\">userId:readItemId</code> 콜렉션은 <code class=\"language-text\">userIdKey:readItemId</code> 구조의 Set을 전체를 담아두고 있는다.</li>\n<li><code class=\"language-text\">userId:recommendItemId</code> 콜렉션은 <code class=\"language-text\">recommend:userIdKey</code> 구조의 List 전체를 담아두고 있는다.</li>\n</ol>\n<p>우리는 이렇게 함으로써 사용자에게 추천된 아이템에 대한 정보 전체와 사용자가 읽은 아이템에 대한 정보 전체를 Redis에 캐싱을 할 수 있게 된다.</p>\n<p>기존에 업데이트하려고 했을 때 문제는 추천된 아이템에도 읽음 여부가 표시되어야하고 읽은 아이템에도 추천된 아이템인지 여부가 표시되어야한다.</p>\n<p>즉 추천되기도했고 사용자가 읽기도했던 아이템은 아래와 같은 교집합일 것이다.</p>\n<p align=\"center\">\n    <img src=\"https://user-images.githubusercontent.com/22961251/111896367-f33e7a80-8a10-11eb-8e65-700716f0cb6c.png\">\n</p>\n<p>하지만 이 부분을 직접 꺼내와서 <strong>서비스 레이어에서 비교를 하자니 속도가 처참</strong>했다.</p>\n<p>그래서 Redis Command 부분을 찾는 중에 <code class=\"language-text\">SINTER</code> 라는 커맨드를 알게되었다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/22961251/111896168-6e9f2c80-8a0f-11eb-930a-0d0b1a838c61.png\" alt=\"redis-command-sinter\"></p>\n<p>우리가 원하는 교집합을 구하는 커맨드였다. 시간복잡도는 O(N*M)으로 빠르다고는 할 수 없겠지만 서비스레이어에서 직접 가져와서 비교하는 것보다 훨씬 빨랐다.</p>\n<p>아직까지 레디스의 메모리가 터지던가 그런 문제는 발생하지 않았으므로 해당 연산을 사용하기로 하였다.</p>\n<p>이렇게 함으로써 DB에 교집합에 속해있는 데이터만 추천된 아이템에 <code class=\"language-text\">isRead</code> 를 <code class=\"language-text\">true</code> 로 바꿔주면되니 전체를 탐색해서 업데이트해야되는 것이 아니라 보다 빠르게 업데이트가 가능해졌다.</p>\n<h2 id=\"step-3-문제점\" style=\"position:relative;\"><a href=\"#step-3-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"step 3 문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3. 문제점</h2>\n<p>위의 로깅 시스템을 도입 후 잘 사용하고 있다고 생각하였다.</p>\n<p>그러나, 바로 문제점이 생겼다. 우리 예상과 다르게 로그의 양이 너무 빠르게 증가되는 문제였다.</p>\n<p>희한하게 Redis는 아주 단순하게 <code class=\"language-text\">standalone</code> 띄워놓고 사용하고 있었는데 죽지도 않고 잘 버텨주었고 샤딩이나 레플리케이션 관련하여 점진적으로 개선하자는 부분은 다들 알고 있던 부분이었으나 정작 문제가 생긴건 DB서버였다.</p>\n<p>빠르게 증가하는 로그 덕분에 DB 서버의 <code class=\"language-text\">Disk Full</code> 이 발생할 수 있는 사태까지 진행이되었다. 내부적으로 많은 이야기가 오갔고 결국 선택을 한 것이 <strong>Kakfa를 도입한 후 로그성 데이터들을 S3로 저장</strong>을 하자고 얘기가 나왔다.</p>\n<p>다음 편은 Kafka를 로컬에서 어떤식으로 삽질을 진행했고, 운영 서버의 Docker Swarm 레이어에 설계했던 Kafka를 탑재하는데까지의 삽질기에 대해서 작성해보고자 한다.</p>\n<p>Redis를 도입하면서 참고했던 자료는 Reference에 달아두었다.\n특히, <code class=\"language-text\">SMEMBERS</code>나 <code class=\"language-text\">LRANGE</code>, <code class=\"language-text\">HGETALL</code> 커맨드들은 <code class=\"language-text\">Keys</code> 커맨드만큼 사용하는데 주의해야하는 커맨드인데 밑에 레퍼런스들 중에서 Best Pratice 관련된 레퍼런스를 보던가 혹은 왜 쓰면 안되는지에 대해서는 Worst Practice를 참고해보자.</p>\n<h1 id=\"step-4-reference\" style=\"position:relative;\"><a href=\"#step-4-reference\" aria-label=\"step 4 reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 4. REFERENCE</h1>\n<ol>\n<li><a href=\"https://tech.kakao.com/2016/03/11/redis-scan/\">Redis의 SCAN은 어떻게 동작하는가? - Kakao Tech</a></li>\n<li><a href=\"https://charsyam.wordpress.com/2014/02/04/redis-scansscanzscanhscan-%EC%9D%B4%EC%95%BC%EA%B8%B0/\">Redis Scan/SScan/ZScan/HScan 이야기 - Charsyam’s Blog</a></li>\n<li><a href=\"https://jinhunpark.com/posts/2019/04/redis-best-practice/\">Redis best practice - Jin’s rambling</a></li>\n<li><a href=\"https://redislabs.com/blog/7-redis-worst-practices/\">7 redis Worst Practices - redislabs</a></li>\n<li><a href=\"https://www.objectrocket.com/blog/how-to/10-quick-tips-about-redis/\">10 quick tips about redis</a></li>\n</ol>","excerpt":"STEP 1. Redis Write Back을 도입하는 여정기 STEP 1. Redis Collection 설계 및 구현 STEP 2.1 추가 요구사항 STEP 3. 문제점 목차 개요 STEP 1. Redis Write Back을 도입하는 여정기 STEP 2. Redis Collection 설계 및 구현 STEP 2.1 추가 요구사항 STEP 3. 문제점 STEP 4. REFERENCE 개요 현재 재직 중인 회사에서 추천 시스템을 도입하기 위해서 기존의 로깅 방식에 대해서 고도화가 필요했었다. 일단, 아주 단순하게 기존 사용자에게 추천됐던 아이템과 읽은 아이템을 토대로 추천 시스템을 만들고자하였다. 이 업무를 진행하기에 앞서 진행되어야하는 부분이 바로 어떤 아이템들이 추천되었고, 어떤 아이템을 읽었는지에 대한 로그를 수집하는 일이었다. 기존에는 사용자가 클릭을 수행하면 바로 DB에 저장이 되는 형식이였으나 사용자가 증가함에 따라 DB 부하 문제도 있고, 개선책을 찾게 되었다. ST…","frontmatter":{"date":"December 29, 2020","title":"To The Moon - 더 나은 로깅시스템을 위한 여정 (Redis 편)","categories":"개발 인프라","author":"개발한입","emoji":"💻"},"fields":{"slug":"/better-logging-with-redis/"}},"next":{"id":"71473346-b939-5b1f-9fc7-2698078a9f3f","html":"<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#step-11-%EC%8B%A4%EC%84%B8%EA%B3%84-%EC%98%88%EC%8B%9C%EB%A5%BC-%ED%86%B5%ED%95%9C-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EB%93%A4%EC%97%AC%EB%8B%A4%EB%B3%B4%EA%B8%B0\">STEP 1.1 실세계 예시를 통한 객체지향 들여다보기</a></li>\n<li><a href=\"#step-111-%EC%9A%94%EC%B2%AD%EA%B3%BC-%EC%9D%91%EB%8B%B5%EC%9C%BC%EB%A1%9C-%EA%B5%AC%EC%84%B1%EB%90%9C-%ED%98%91%EB%A0%A5\">STEP 1.1.1 요청과 응답으로 구성된 협력</a></li>\n<li><a href=\"#step-112-%EC%97%AD%ED%95%A0%EA%B3%BC-%EC%B1%85%EC%9E%84\">STEP 1.1.2 역할과 책임</a></li>\n<li><a href=\"#step-12-%EC%A4%91%EA%B0%84-%EC%A0%95%EB%A6%AC\">STEP 1.2 중간 정리</a></li>\n<li><a href=\"#step-21-%EC%83%81%ED%83%9C%EC%99%80-%ED%96%89%EB%8F%99%EC%9D%84-%ED%95%A8%EA%BB%98-%EC%A7%80%EB%8B%8C-%EC%9E%90%EC%9C%A8%EC%A0%81%EC%9D%B8-%EA%B0%9D%EC%B2%B4\">STEP 2.1 상태와 행동을 함께 지닌 자율적인 객체</a></li>\n<li><a href=\"#step-22-%ED%98%91%EB%A0%A5%EA%B3%BC-%EB%A9%94%EC%8B%9C%EC%A7%80\">STEP 2.2 협력과 메시지</a></li>\n<li><a href=\"#step-23-%EB%A9%94%EC%84%9C%EB%93%9C%EC%99%80-%EC%9E%90%EC%9C%A8%EC%84%B1\">STEP 2.3 메서드와 자율성</a></li>\n</ul>\n</div>\n<h1 id=\"객체지향의-사실과-오해-1장-리뷰\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9D%98-%EC%82%AC%EC%8B%A4%EA%B3%BC-%EC%98%A4%ED%95%B4-1%EC%9E%A5-%EB%A6%AC%EB%B7%B0\" aria-label=\"객체지향의 사실과 오해 1장 리뷰 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체지향의 사실과 오해 1장 리뷰</h1>\n<ul>\n<li>STEP 1. 객체지향은 실세계의 모방이다?\n<ul>\n<li>STEP 1.1 실세계 예시를 통한 객체지향 들여다보기\n<ul>\n<li>STEP 1.1.1 요청과 응답으로 구성된 협력</li>\n<li>STEP 1.1.2 역할과 책임</li>\n</ul>\n</li>\n<li>STEP 1.2 중간 정리</li>\n</ul>\n</li>\n<li>STEP 2. 협력 속에 사는 객체\n<ul>\n<li>STEP 2.1 상태와 행동을 함께 지닌 자율적인 객체</li>\n<li>STEP 2.2 협력과 메시지</li>\n<li>STEP 2.3 메서드와 자율성</li>\n</ul>\n</li>\n<li>STEP 3. 객체지향의 본질</li>\n<li>STEP 4. 객체를 지향하라</li>\n</ul>\n<br/>\n<h1 id=\"개요\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EC%9A%94\" aria-label=\"개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개요</h1>\n<p>이 책을 보고 나서 많은 것들을 깨닫고, 많은 생각을 하게 되었다. 정말 객체지향이란 무엇인지? 에 대해서 가슴에 와닿게 설명해준 책이라 생각한다. 특히 나와 같은 초보들에게 말이다.</p>\n<p>이번 포스팅은 이 책을 읽고 같이 OOP에 대해서 좀 더 깊게 들어가고자 조영호님의 “객체지향의 사실과 오해”라는 책의 1장을 리뷰해보자 한다.</p>\n<center>\n<img src=\"https://user-images.githubusercontent.com/22961251/99187721-28c81400-2750-11eb-93b9-4c5e94c4c8ae.png\">\n</center>\n<br>\n<h1 id=\"step-1-객체지향은-실세계의-모방이다\" style=\"position:relative;\"><a href=\"#step-1-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9D%80-%EC%8B%A4%EC%84%B8%EA%B3%84%EC%9D%98-%EB%AA%A8%EB%B0%A9%EC%9D%B4%EB%8B%A4\" aria-label=\"step 1 객체지향은 실세계의 모방이다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1. 객체지향은 실세계의 모방이다?</h1>\n<p><strong>객체지향은 실세계를 직접적이고 직관적으로 모델링 할 수 있다.</strong></p>\n<p>위의 말을 다시 풀어보자면, <strong>객체지향 세계는 실세계의 모방</strong>이라는 뜻이다.</p>\n<p>객체지향을 위와 같은 말로 설명할 수 있을까? 이 책의 저자 조용호님은 다음과 같이 말한다.</p>\n<blockquote>\n<p>이러한 설명은 철학적인 개념을 설명하는 데 적합하지만, 유연하고 실용적인 관점에서는 적합하지 않다.</p>\n</blockquote>\n<p>그렇다면? 객체지향과 실세계의 연관성은 어떻게 될까? 이 책에 나온 예를 들어보자.</p>\n<ul>\n<li>\n<p>건물의 방화벽과 네트워크의 방화벽</p>\n<p>→ 건물의 방화벽은 말 그대로 건물 내에 불이 번지는 것을 막기 위한 방화벽이다.</p>\n<p>→ 네트워크의 방화벽은 네트워크 침입을 막는 것이다.</p>\n</li>\n</ul>\n<p>일단, 의미적 거리만큼이나 소프트웨어 객체와 실세계 사물 사이에 존재하는 연관성은 희미하다.</p>\n<p>그렇다면 객체지향은 무엇일까?</p>\n<p>→ <strong>객체지향의 목표는 실세계를 모방하는 것이 아니다! 오히려 새로운 세계를 창조하는 것이다.</strong></p>\n<p>하지만, 실세계의 모방이라는 말은 객체지향의 철학적인 개념을 설명하는 데 적합하다하였다.</p>\n<p>나는 실세계의 예시를 통하여, 객체지향이 담고 있는 철학적인 개념 무엇인지? 설명하고자 한다.</p>\n<h2 id=\"step-11-실세계-예시를-통한-객체지향-들여다보기\" style=\"position:relative;\"><a href=\"#step-11-%EC%8B%A4%EC%84%B8%EA%B3%84-%EC%98%88%EC%8B%9C%EB%A5%BC-%ED%86%B5%ED%95%9C-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EB%93%A4%EC%97%AC%EB%8B%A4%EB%B3%B4%EA%B8%B0\" aria-label=\"step 11 실세계 예시를 통한 객체지향 들여다보기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.1 실세계 예시를 통한 객체지향 들여다보기</h2>\n<center>\n<img src=\"https://user-images.githubusercontent.com/22961251/99187716-24036000-2750-11eb-939e-f238d1c1bb2e.png\">\n</center>\n<br>\n<p>출근길은 항상 고되다 현대인들은 이러한 고됨을 덜기 위해 카페를 찾아 커피를 구매한 뒤 본격적인 오전 업무를 진행하기 전 커피 한잔의 여유를 즐기곤 한다. 실세계의 예를 통해서 객체지향을 비교해볼 예시는 바로 출근길의 카페이다.</p>\n<p>대부분의 카페는 아래와 같이 주문이 처리될 것이다.</p>\n<ol>\n<li>손님은 커피를 주문한다.</li>\n<li>캐시어는 주문을 받는다.</li>\n<li>바리스타는 커피를 제조한다.</li>\n<li>바리스타는 제조한 커피를 캐시어에게 전달한다.</li>\n<li>캐시어는 전달받은 커피를 손님에게 전달한다.</li>\n<li>손님은 완성된 커피를 받는다.</li>\n</ol>\n<p>물론, 캐시어가 바리스타의 역할을 해서 주문을 받고 커피를 제조할 수도 있으며, 반대도 가능할 것이다.</p>\n<p>이 내용은 아래서 다뤄 볼 예정이다. 하지만 위의 예시(1~6)를 토대로 설명해보고자 한다.</p>\n<p>위와 같이 실세계에서 단순한 커피를 주문하는 작은 이벤트를 완성하는 데도 <strong>여러 사람의 조율과 조화</strong>가 필요한 것을 볼 수 있다.</p>\n<p>모든 음료 주문은 손님이 커피를 주문하고, 캐시어가 주문을 받고, 바리스타가 커피를 제조함으로서 이뤄진다.</p>\n<p>이 과정은 <strong>역할, 책임, 협력이라는 세 가지 개념이 한데 어울려 조화</strong>를 이루며 만들어 낸 것이다.</p>\n<ul>\n<li>\n<p>역할</p>\n<ul>\n<li>주문하는 손님</li>\n<li>주문을 받는 캐시어</li>\n<li>커피를 제조하는 바리스타</li>\n</ul>\n</li>\n<li>\n<p>책임</p>\n<ul>\n<li>손님은 주문할 책임을 수행</li>\n<li>캐시어는 주문을 받는 책임을 수행</li>\n<li>바리스타는 주문된 커피를 제조하는 책임을 수행</li>\n</ul>\n</li>\n</ul>\n<p>역할과 책임은 위와 같이 구성된 것을 볼 수가 있다. 그렇다면? 협력은 무엇일까?</p>\n<p>위와 같은 역할과 책임 속에 암묵적인 협력이 존재한다. 우리는 이 협력관계가 무엇인지 파악하고자 한다.</p>\n<h2 id=\"step-111-요청과-응답으로-구성된-협력\" style=\"position:relative;\"><a href=\"#step-111-%EC%9A%94%EC%B2%AD%EA%B3%BC-%EC%9D%91%EB%8B%B5%EC%9C%BC%EB%A1%9C-%EA%B5%AC%EC%84%B1%EB%90%9C-%ED%98%91%EB%A0%A5\" aria-label=\"step 111 요청과 응답으로 구성된 협력 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.1.1 요청과 응답으로 구성된 협력</h2>\n<center>\n<img src=\"https://user-images.githubusercontent.com/22961251/99187720-282f7d80-2750-11eb-8be4-d9bcc48a8d40.png\">\n</center>\n<p>실세계에서 우리는 스스로 해결하지 못하는 문제와 마주치면 문제 해결에 필요한 지식을 알고 있거나 서비스를 제공해줄 수 있는 사람에게 도움을 **요청(Request)**한다.</p>\n<p>위의 예시는 출근길 카페에 대한 요청 예시이다. 하나의 문제를 해결하기 위해서 다 수의 요청이 발생하는 것이 일반적이며, 따라서 요청은 <strong>연쇄적으로 발생한다.</strong> 응답 또한, 요청의 방향과 반대 방향으로 연쇄적으로 전달 되는 것을 알 수가 있다.</p>\n<ul>\n<li>손님은 커피를 제조하여 먹고싶은 문제를 해결하고자 함. → 카페에 들러서 커피 주문을 한다.</li>\n<li>캐시어는 주문을 해결할 수 있으나 커피 제조라는 문제를 해결하지 못한다 → 바리스타에게 커피 요청</li>\n<li>바리스타는 완성된 커피를 전달한다.</li>\n</ul>\n<p>이렇게 <strong>요청과 응답을 통해 다른 사람과 협력 할 수 있는 것</strong>은 복잡한 문제를 해결할 수 있는 공동체를 형성한다.</p>\n<h2 id=\"step-112-역할과-책임\" style=\"position:relative;\"><a href=\"#step-112-%EC%97%AD%ED%95%A0%EA%B3%BC-%EC%B1%85%EC%9E%84\" aria-label=\"step 112 역할과 책임 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.1.2 역할과 책임</h2>\n<p>사람들은 다른 사람들과 협력하는 과정 속에서 특별한 역할(Rule)을 부여받는다.</p>\n<p>역할은 <strong>어떤 협력에 참여하는 특정한 사람이 협력 안에서 차지하는 책임이나 임무를 의미</strong>한다.</p>\n<p>위의 예시를 들어서 설명하면, 어떤 사람이 손님이라는 역할을 맡았다면 커피를 주문하는 임무를 맡게되며, 캐시어라는 역할을 맡았으면 손님으로부터 주문을 받아야하는 임무를 맡게된다. 바리스타의 역할을 맡은 사람은 주문된 커피를 제조할 책임이 있다.</p>\n<p>위에서 “바리스타는 커피를 제조할 책임이 있다”라 하였는데 즉, <strong>역할은 책임이라는 개념을 내포</strong>함을 알 수가 있다.</p>\n<p>이러한 사실들은 몇가지 중요한 개념을 제시한다.</p>\n<ul>\n<li><strong>여러 사람이 동일한 역할을 수행할 수 있다.</strong></li>\n<li><strong>역할은 대체가능성을 의미한다.</strong></li>\n<li><strong>책임을 수행하는 방법은 자율적으로 선택할 수 있다.</strong></li>\n<li><strong>한 사람이 동시에 여러 역할을 수행할 수 있다.</strong></li>\n</ul>\n<p><strong>1. 여러 사람이 동일한 역할을 수행할 수 있다.</strong></p>\n<p>손님은 단지 커피를 받기만 하면 된다. 바리스타가 누군지 캐시어가 누군지는 신경쓰지 않는다. 만일, 캐시어가 그만둔다하더라도 캐시어라는 역할에 따르는 책임을 수행할 수 있는 다른 사람을 고용하면 된다.</p>\n<p>즉, 손님 입장에서는 캐시어가 주문을 받고 커피가 완성됐다는 사실을 통보하는 책임을 성실히 이행할 수 있다면 그만이다.</p>\n<p><strong>2. 역할은 대체 가능성을 의미한다.</strong></p>\n<p>손님 입장에서 캐시어는 **대체 가능(Subsittutable)**하다. 만약 두 명이 캐시어의 역할을 수행할 수 있다면, 손님 입장에서는 둘 중 어느누가 역할을 수행하더라도 문제가 되지않는다.</p>\n<p><strong>3. 책임을 수행하는 방법은 자율적으로 선택할 수 있다.</strong></p>\n<p>요청을 받은 사람들은 요청을 처리하는 방법을 자유롭게 선택할 수 있다. 즉, 바리스타가 카페라떼의 주문이 들어온 경우 어떠한 바리스타는 라떼아트를 할 수 있을 것이며, 어떤 바리스타는 풍미를 돋우기 위해 노력할지 모른다.</p>\n<p>즉, 바리스타의 역할을 수행하는 사람들마다 서로 다른 방식으로 요청을 처리한다는 것이다.</p>\n<p>그러나 그 결과 나오는 “카페라떼”는 변하지 않는다.</p>\n<p>이처럼 동일한 **요청에 대해 서로 다른 방식으로 응답할 수 있는 능력을 다형성(Polymorphism)**이라 한다.</p>\n<p><strong>4. 한 사람이 동시에 여러 역할을 수행할 수 있다.</strong></p>\n<p>처음 예시를 들 때 바리스타가 캐시어의 역할을 수행할 수 있을 수 있으며, 반대도 가능하다하였다.</p>\n<p>우리 주변의 카페도 그런 경우가 많다. 위의 예시는 캐시어와 바리스타라는 개별적인 역할을 이용해 협력관계를 묘사했지만, 한 사람이 캐시어와 바리스타의 역할을 동시에 수행하는 것도 가능하다.</p>\n<p>즉, 한 사람이 동시에 둘 이상의 역할을 수행하는 것이 가능하다.</p>\n<p>이는 다형성의 개념으로도 볼 수 있는데 학교에 등교할 때는 학생이라는 역할을 수행하며, 집에 돌아와서는 부모님의 막내아들이라는 역할을 수행하는 나와 같다고 볼 수 있다.</p>\n<h2 id=\"step-12-중간-정리\" style=\"position:relative;\"><a href=\"#step-12-%EC%A4%91%EA%B0%84-%EC%A0%95%EB%A6%AC\" aria-label=\"step 12 중간 정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1.2 중간 정리</h2>\n<p>출근길 카페 예시를 통해서 알게 된 내용은 다음과 같다.</p>\n<p><strong>협력(collaboration)</strong> : <strong>문제를 해결할 수 있는 다른 사람에게 요청과 응답을 통해 문제를 해결하는 것</strong></p>\n<p><strong>역할(Rule)</strong> : <strong>어떤 협력에 참여하는 특정한 사람이 협력 안에서 차지하는 책임이나 임무</strong></p>\n<p><strong>책임(Responsiblilty)</strong> :  <strong>협력하는 과정에서 문제를 해결하기 위해 자신에 임무를 성실히 수행하는 것</strong></p>\n<p>또한, <strong>역할은 의미적으로 책임이라는 개념을 내포한다</strong>하였다.</p>\n<p>그리고 역할과 책임은 다음과 같은 특성을 갖는다.</p>\n<ul>\n<li><strong>여러 사람이 동일한 역할을 수행할 수 있다.</strong></li>\n<li><strong>역할은 대체 가능성을 의미한다.</strong></li>\n<li><strong>책임을 수행하는 방법은 자율적으로 선택할 수 있다.</strong></li>\n<li><strong>한 사람이 동시에 여러 역할을 수행할 수 있다.</strong></li>\n</ul>\n<p>그렇다면 출근길 카페 예시를 객체지향 세계로 옮기면 어떻게 될까?</p>\n<ul>\n<li>손님, 캐시어, 바리스타 → <strong>객체(Object)</strong></li>\n<li>손님이 캐시어에게 주문을 요청, 캐시어가 바리스타에게 커피 제조를 요청 → <strong>메시지(Message)</strong></li>\n<li>캐시어가 주문 요청을 처리하는 방법, 바리스타가 제조 요청을 처리하는 방법 → <strong>메서드(Method)</strong></li>\n</ul>\n<p>위와 같이 실세계의 예를 들어 객체지향 세계가 어떻게 이뤄지는지 철학적인 개념을 알게 되었다.</p>\n<p>이제 좀 더 실용적인 관점에서 이를 보고자 한다.</p>\n<h1 id=\"step-2-협력-속에-사는-객체\" style=\"position:relative;\"><a href=\"#step-2-%ED%98%91%EB%A0%A5-%EC%86%8D%EC%97%90-%EC%82%AC%EB%8A%94-%EA%B0%9D%EC%B2%B4\" aria-label=\"step 2 협력 속에 사는 객체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2. 협력 속에 사는 객체</h1>\n<blockquote>\n<p>“어떤 객체도 섬이 아니다.” - Ward Cunningham, Kent Beck (1989)</p>\n</blockquote>\n<p>내가 가장 인상이 깊었던 말이었다. 객체지향의 본질을 밑에서 또 정리하겠지만, 여기까지 읽었을 때 객체지향이 무엇인가에 대해서 감이 오는가?</p>\n<p>나는 이렇게 생각한다.</p>\n<p><strong>“복잡하고 거대한 문제를 해결하기 위해서 역할과 책임을 성실히 수행하며 자율적으로 협력하는 객체들을 만들어 내는 것”</strong></p>\n<p>사람들이 어떠한 문제를 해결하기 위해서 협력하듯이 객체들은 애플리케이션의 기능을 구현하기 위해서 협력한다.</p>\n<p>객체지향 세계에서 협력에 참여하는 주체는 **객체(Object)**이다. 실세계에서 인간이라는 것이 없으면 역할, 책임, 협력은 아무런 의미가 없는 것 처럼 객체지향도 마찬가지이다.</p>\n<p>따라서, 객체는 다음 두 가지를 갖춰야한다.</p>\n<ol>\n<li><strong>객체는 충분히 ‘협력적’이어야 한다.</strong></li>\n<li><strong>객체는 충분히 ‘자율적’이어야 한다.</strong></li>\n</ol>\n<ul>\n<li><strong>객체는 충분히 ‘협력적’이어야 한다.</strong></li>\n</ul>\n<p><strong>“어떤 객체도 섬이 아니다”라는 말</strong>처럼 객체지향에서 꼭 잊으면 안되는 것이 <strong>협력</strong>이다. 객체지향 세계에서 객체는 다른 객체의 요청에 충실히 귀를 기울이고, 다른 객체에게 적극적으로 도움을 요청해야한다는 것이다.</p>\n<p>혼자서 모든 것을 처리하는 전지전능한 객체는 내부적인 복잡도에 의해 스스로 자멸한다.</p>\n<p>→ 이는 SOILD 원칙 중 **단일 책임 원칙(Single Responsibility Principle)**과 관련이 있다고 볼 수 있다.</p>\n<p>여기서 협력적이라는 말은 다른 객체의 명령에 수동적으로 움직이는 객체들을 말하는 것이 아니다.</p>\n<p>객체는 요청이 들어온 객체의 명령에 복종하는 것이 아니라 자율적으로 처리한다. 단순하게 말하면 요청에 응답을 주는 것일 뿐 내부적으로 어떠한 방식으로 응답을 생성 했는지는 외부 객체가 관여하지 않는다.</p>\n<p>→  이는 객체지향의 특성 중에 하나인 **캡슐화(Encapsulation)**과 관련이 있다.</p>\n<ul>\n<li><strong>객체는 충분히 ‘자율적’이어야 한다.</strong></li>\n</ul>\n<p>잠깐 설명했던 것 처럼 요청을 한 객체는 응답을 주는 객체에게 내부적으로 어떻게 응답을 생성하라 간섭을 하지 않는다. 단순하게 요청을 하고 해당 응답을 기다릴 뿐이다.</p>\n<p>잠깐 다시 출근길 카페로 돌아가보자.</p>\n<p>우리가 만약 캐시어라면 손님이 주문하면 행동을 시작하지만 손님이 주문하는 절차나 바리스타에게 접수한 것을 전달하는 방법은 스스로 결정한다.</p>\n<p>즉, 캐시어는 <strong>요청에 대해 스스로 판단하고 행동하는 자율적 존재</strong>이다.</p>\n<p>객체지향 세계에서도 마찬가지이다. <strong>객체는 협력에 참여하지만 스스로의 결정과 판단에 따라 행동하는 자율적인 존재</strong>이다. 그렇다면 어떻게 충분히 협력적이고, 자율적인 객체를 만들 수 있을까?</p>\n<h2 id=\"step-21-상태와-행동을-함께-지닌-자율적인-객체\" style=\"position:relative;\"><a href=\"#step-21-%EC%83%81%ED%83%9C%EC%99%80-%ED%96%89%EB%8F%99%EC%9D%84-%ED%95%A8%EA%BB%98-%EC%A7%80%EB%8B%8C-%EC%9E%90%EC%9C%A8%EC%A0%81%EC%9D%B8-%EA%B0%9D%EC%B2%B4\" aria-label=\"step 21 상태와 행동을 함께 지닌 자율적인 객체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.1 상태와 행동을 함께 지닌 자율적인 객체</h2>\n<p>이 장에서는 어떻게 충분히 협력적이고, 자율적인 객체를 만들 수 있을까?에 대한 해답을 내놓으려고 한다.</p>\n<p>힌트는 사실 위에서도 설명했지만, **캡슐화(Encapsulation)**랑 관련이 깊다.</p>\n<p>“객체는 **상태(state)와 행위(behavior)**를 갖는다”라는 말을 많이 들어 봤을 것이다. 객체가 협력에 참여하기 위해서 어떤 행동을 해야 한다면 그 행동을 하는 데 필요한 상태도 함께 지니고 있어야 한다는 것을 의미한다.</p>\n<p>객체의 <strong>자율성은 객체의 내부와 외부를 명확하게 구분하는 것으로부터 나온다.</strong> 즉, 무엇(What)을 수행하는지 알 수 있지만 어떻게(How) 수행하는지에 대해서 알 수 없다.</p>\n<p>그렇기에 객체의 자율성은 캡슐화와 관련이 깊다는 것이다.</p>\n<h2 id=\"step-22-협력과-메시지\" style=\"position:relative;\"><a href=\"#step-22-%ED%98%91%EB%A0%A5%EA%B3%BC-%EB%A9%94%EC%8B%9C%EC%A7%80\" aria-label=\"step 22 협력과 메시지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.2 협력과 메시지</h2>\n<p>인간 세계와 달리 객체지향 세계에서는 한 가지 의사소통 수단만이 존재한다. 바로 그것이 <strong>메시지</strong>이다.</p>\n<p>객체는 협력을 위해 다른 객체에게 메시지를 전송하고 다른 객체로 부터 메시지를 수신한다.</p>\n<p>객체지향 세계에서의 <strong>협력은 메시지를 전송하는 객체(Sender)와 수신하는 객체(Receiver) 사이에서 이뤄진다.</strong></p>\n<h2 id=\"step-23-메서드와-자율성\" style=\"position:relative;\"><a href=\"#step-23-%EB%A9%94%EC%84%9C%EB%93%9C%EC%99%80-%EC%9E%90%EC%9C%A8%EC%84%B1\" aria-label=\"step 23 메서드와 자율성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.3 메서드와 자율성</h2>\n<p>어떤 객체가 협력을 위해 메세지를 수신하면 자신이 처리할 수 있는지 판단한 뒤 미리 정해진 자신만의 방법으로 메세지를 처리한다. 이 처리하는 방법을 <strong>메서드</strong>라고 부른다.</p>\n<p>그렇다면 메서드와 자율성은 무슨 연관성이 있을까?</p>\n<p>객체는 메시지를 수신하면 이를 수신할 수 있는지 판단하는데 이때, 판단할 수 있으면 위에서 얘기한 바와 같이 <strong>어떻게 처리하는 부분이 바로 메서드</strong>일 것이다.</p>\n<p>예를 들면 동일한 커피 제조 요청에도 바리스타는 커피머신으로 커피를 내릴 수도 있으며, 어떤 경우에는 핸드 드립으로 커피를 내릴 수도 있을 것이다.</p>\n<p>객체지향 세계에서는 협력에 참여하는 객체들 간의 메세지와 메서드의 분리를 통하여 자율성을 증진시킨다.</p>\n<p>좀 더 깊게 말하면, <strong>외부의 요청이 무엇인지를 표현하는 메시지와 요청을 처리하기 위한 구체적인 방법인 메서드를 분리하는 것</strong>이 객체의 자율성을 높인다. 이것 또한 캡슐화와 아주 깊은 연관 관계를 갖는다.</p>\n<h1 id=\"step-3-객체지향의-본질\" style=\"position:relative;\"><a href=\"#step-3-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9D%98-%EB%B3%B8%EC%A7%88\" aria-label=\"step 3 객체지향의 본질 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3. 객체지향의 본질</h1>\n<p>이번 포스팅에서 설명한 내용을 종합하여 객체지향의 본질을 정리하면 다음과 같다고 볼 수 있다.</p>\n<ul>\n<li>\n<p><strong>객체지향이란 시스템을 상호작용하는 자율적인 객체들의 공동체로 바라보고 객체를 이용해 시스템을 분할하는 방법이다.</strong></p>\n</li>\n<li>\n<p><strong>자율적인 객체란 상태와 행위를 함께 지니며 스스로 자기 자신을 책임지는 객체를 의미한다.</strong></p>\n</li>\n<li>\n<p><strong>객체는 시스템의 행위를 구현하기 위해 다른 객체와 협력한다.</strong></p>\n<p>→ <strong>각 객체는 협력 내에서 정해진 역할을 수행하며, 역할은 관련된 책임의 집합이다.</strong></p>\n</li>\n<li>\n<p><strong>객체는 다른 객체와 협력하기 위해 메시지를 전송하며, 메시지를 수신한 객체는 메시지를 처리하는 데 적합한 메서드를 자율적으로 선택한다.</strong></p>\n</li>\n</ul>\n<h1 id=\"step-3-객체를-지향하라\" style=\"position:relative;\"><a href=\"#step-3-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%A7%80%ED%96%A5%ED%95%98%EB%9D%BC\" aria-label=\"step 3 객체를 지향하라 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 3. 객체를 지향하라</h1>\n<p>항상 우리는 객체지향 프로그래밍 혹은 객체지향 설계를 이야기할 때 항상 중점으로 바라봤던 것은 객체가 아니라 <strong>클래스</strong>였다.</p>\n<p>돌이켜 생각해보자, 학부시절 객체지향 설계를 보면 클래스 다이어그램이 중요하다 배웠었고, 객체지향 프로그래밍에서는 첫 장부터 객체와 클래스란 무엇인가?로 시작하지 않았나라고 말이다.</p>\n<p>잘 생각해보자 자바스크립트와 같은 프로토타입(prototype) 기반 언어들은 클래스라는 개념이 없음에도 (ES6 이전을 생각하자) 객체지향 언어라고 불리었다.</p>\n<p>우리가 배워야할 것은 클래스 지향 프로그래밍과 설계가 아니다. 객체지향 프로그래밍과 설계이다.</p>\n<p>이 책의 저자 조용호님께서는 클래스를 강조하는 프로그래밍 언어적인 관점은 다음과 같은 문제가 있다고 한다.</p>\n<ol>\n<li><strong>객체의 캡슐화를 저해한다.</strong></li>\n<li><strong>클래스를 서로 강하게 결합시킨다.</strong></li>\n<li><strong>협력하는 객체들의 공동체가 아닌 클래스로 구성된 설계도의 관점은 유연하고 확장가능한 애플리케이션 구축을 방해한다.</strong></li>\n</ol>\n<p>우리는 이제 객체를 지향해야 한다.</p>\n<p>클래스의 관점에서 메시지를 주고받는 객체의 관점으로 사고의 중심을 전환해야 된다는 것을 잊지 말아야 한다.</p>\n<p>중요한 것은 어떤 클래스가 필요한가가 아니라 어떤 객체들이 어떤 메세지를 주고받으며 협력하는가이다.</p>","frontmatter":{"date":"November 15, 2020","title":"Book Review - 객체지향의 사실과 오해 1장 리뷰","categories":"개발 독서요약","author":"개발한입","emoji":"📚"},"fields":{"slug":"/review-essence-of-object-orientation/"}},"prev":{"id":"ccd2f160-9bde-5736-b66e-498b63f2da3a","html":"<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#step-21-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A1%9C%EB%8D%94-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%98%81%EC%97%ADclass-loader-system-area\">STEP 2.1 클래스 로더 시스템 영역(Class Loader System Area)</a></p>\n<ul>\n<li><a href=\"#step-211-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A1%9C%EB%8D%94%EC%9D%98-%ED%8A%B9%EC%A7%95class-loaders-feature\">STEP 2.1.1 클래스 로더의 특징(Class Loader’s feature)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-22-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%ADruntime-data-area\">STEP 2.2 메모리 영역(Runtime Data Area)</a></p>\n</li>\n<li>\n<p><a href=\"#step-23-%EC%8B%A4%ED%96%89-%EC%97%94%EC%A7%84execution-engine\">STEP 2.3 실행 엔진(Execution Engine)</a></p>\n<ul>\n<li><a href=\"#%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0\">인터프리터</a></li>\n<li><a href=\"#jit%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC\">JIT 컴파일러</a></li>\n<li><a href=\"#gcgarbage-collector\">GC(Garbage Collector)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-24-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A1%9C%EB%94%A9-%EA%B3%BC%EC%A0%95class-loading-process\">STEP 2.4 클래스 로딩 과정(Class Loading Process)</a></p>\n</li>\n<li>\n<p><a href=\"#step-241-%EB%8F%99%EC%A0%81%EB%A1%9C%EB%94%A9\">STEP 2.4.1 동적로딩</a></p>\n<ul>\n<li><a href=\"#step-242-%EB%A1%9C%EB%93%9C%ED%83%80%EC%9E%84-%EB%8F%99%EC%A0%81-%EB%A1%9C%EB%94%A9load-time-dynamic-loading\">STEP 2.4.2 로드타임 동적 로딩(load-time dynamic loading)</a></li>\n<li><a href=\"#step-243-%EB%9F%B0%ED%83%80%EC%9E%84-%EB%8F%99%EC%A0%81-%EB%A1%9C%EB%94%A9load-time-dynamic-loading\">STEP 2.4.3 런타임 동적 로딩(load-time dynamic loading)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step-41-class-loader%EB%A5%BC-%ED%86%B5%ED%95%9C-hot-swap-%EC%98%88%EC%A0%9C\">STEP 4.1 Class Loader를 통한 Hot Swap 예제</a></p>\n</li>\n<li>\n<p><a href=\"#step-42-%EB%B0%94%EC%9D%B4%ED%8A%B8%EC%BD%94%EB%93%9C-%EC%A1%B0%EC%9E%91%EC%9D%84-%ED%86%B5%ED%95%9C-hot-swap-%EC%98%88%EC%A0%9C\">STEP 4.2 바이트코드 조작을 통한 Hot Swap 예제</a></p>\n</li>\n</ul>\n</div>\n<h1 id=\"목차\" style=\"position:relative;\"><a href=\"#%EB%AA%A9%EC%B0%A8\" aria-label=\"목차 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>목차</h1>\n<ul>\n<li>개요</li>\n<li>STEP 1. Write Once, Run Anywhere(WORA)</li>\n<li>STEP 2. JVM 구조\n<ul>\n<li>STEP 2.1 클래스 로더 시스템 영역(Class Loader System Area)\n<ul>\n<li>STEP 2.1.1 클래스 로더의 특징</li>\n</ul>\n</li>\n<li>STEP 2.2 메모리 영역(Runtime Data Area)</li>\n<li>STEP 2.3 실행 엔진(Excutable Engine)</li>\n<li>STEP 2.4 클래스 로딩 과정(Class Loading Process)\n<ul>\n<li>STEP 2.4.1 동적로딩(Dynamic Loading)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>STEP 4. Implement class hot swap in java</li>\n<li>STEP 5. 결론</li>\n<li>STEP 6. Reference</li>\n</ul>\n<h1 id=\"개요\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EC%9A%94\" aria-label=\"개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개요</h1>\n<p>Fundamental이라고 적었지만, 저 또한 JVM의 모든 구조와 Class Loader의 동작방식을 100% 이해했다고는 장담을 못하는 상황입니다.</p>\n<p>이 포스팅은 아주 단순한 궁금증에서 출발했습니다.</p>\n<p>제 궁금증은 <code class=\"language-text\">spring-boot-devtools</code> 와 같은걸 쓰면 정적페이지 수정이 있을 경우 바로바로 반영을 해서 뷰에서 뿌려줍니다.  근데 자바 코드의 경우에는 결국에는 <code class=\"language-text\">rebuild</code> 나 <code class=\"language-text\">recompile</code> 과 같은 행위가 있어야지 반영이 됩니다.</p>\n<p>Java Class Hot Swap는 불가능한 것일까? 라는 의문에서 출발하게 됐습니다. 그렇게 의문을 쫓다보니 결국 JVM 구조와 그 내부에 속해있는 Class Loader에 대해서 이해를 했어야했습니다.</p>\n<p>그 전에 자바의 목표인 WORA(Write Once, Run Anywhere)가 어떻게 가능했는지부터 출발하여</p>\n<p>마지막은 Java에서 어떻게 HotSwap을 구현할 수 있을지에 대한 짧은 샘플코드로 마무리하고자 합니다.</p>\n<h1 id=\"step-1-write-once-run-anywherewora\" style=\"position:relative;\"><a href=\"#step-1-write-once-run-anywherewora\" aria-label=\"step 1 write once run anywherewora permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 1. Write Once, Run Anywhere(WORA)</h1>\n<p>우리가 알고 있는 고급 프로그래밍 언어같은 경우에는 해당 코드를 기계어로 번역하기 위해서 컴파일러와 인터프리터를 사용하는 것으로 다들 알고 있을 것이다.</p>\n<p>아래는 컴파일러와 인터프리터의 기계어 번역과정을 나타낸 그림이다.</p>\n<p align=\"center\">\n    <img src=\"https://user-images.githubusercontent.com/22961251/103324819-dc574000-4a40-11eb-966e-a3abb05fe829.png\">\n</p>\n<p align=\"center\">\n    <em>Aniket Thakur,difference between compiler interpreter,2013</em>\n</p>\n<p>위 그림을 정리하자면 차이는 이렇다고 볼 수 있을 것이다.</p>\n<ul>\n<li>컴파일러\n<ul>\n<li>플랫폼 종속적(dependent)이다.</li>\n<li>소스코드를 한번에 번역을 한다.</li>\n<li>빠르다.</li>\n</ul>\n</li>\n<li>인터프리터\n<ul>\n<li>플랫폼 비종속적(independent)이다.</li>\n<li><code class=\"language-text\">line-by-line</code> 으로 기계어 번역을 수행한다.</li>\n<li>느리다.</li>\n</ul>\n</li>\n</ul>\n<p>여기서 속도의 차이는 관점(런타임이냐 컴파일 시점이냐)에 따라 다른데 이 부분은 뒤의 JVM과 Class Loader를 설명하기위해 곁다리로 보는 부분이라 해당 부분은 설명이 매우 잘나와있는 링크로 대체하겠다.</p>\n<p><a href=\"https://blog.naver.com/ehcibear314/221228200531\">컴파일러와 인터프리터 차이</a></p>\n<p><a href=\"https://gusdnd852.tistory.com/206\">인터프리터 &#x26; 혼합기법</a></p>\n<p>위의 특징 중에서 눈 여겨야하는 키워드는 <strong>플랫폼 종속적(dependent)이라는 것</strong>이다.</p>\n<p>여기서 말하는 플랫폼은 OS나 코드가 돌아갈 환경이라고 생각하면 될 것이다.</p>\n<p>컴파일러는 플랫폼 종속적(dependent)하지만, 언어는 <strong>플랫폼 비종속적(Independent)</strong> 하다.</p>\n<p>그러면 혹자들은 이렇게 말할 수도 있을 것이다.</p>\n<blockquote>\n<p>어 내가 윈도우에서 만든 .exe 파일은 mac에서는 안돌아가잖아? 종속적인거 아냐?</p>\n</blockquote>\n<p>여기서 핵심은 <code class=\"language-text\">.exe</code> 이다. 언어가 플랫폼에 종속적인 것이 아니라 <strong>실행 파일(excutable)이 종속적일 수도 있고 아닐 수도 있는 것이다.  맥이든 리눅스든 윈도든 C자체를 사용하여 코딩할 수 있지 않는가?</strong></p>\n<p>C는 이런 플랫폼에 맞는 컴파일러들을 제공하여 그 플랫폼에 맞는 기계어(정확히는 네이티브 코드)로 번역해서 실행파일을 만드는 것이다.</p>\n<p>따라서, 기계어는 플랫폼 종속적이다라고 볼 수 있는데 해당 내용은 <a href=\"https://www.quora.com/If-machine-code-is-dependent-on-the-hardware-why-can-compiled-code-be-run-on-any-platform-with-the-same-OS\">If machine code is dependent on the hardware, why can compiled code be run on any platform with the same OS?</a> 에 자세히 답변이 되어있다.</p>\n<p>하지만, 기계어 자체는 OS를 배제하고 바로 CPU에서 읽어 쓰는 개념이므로 앞으로는 <strong>네이티브 코드</strong>로 부르겠다.</p>\n<p>각설하고 자바가 강조하는 <code class=\"language-text\">Write Once, Run Anywhere</code> 를 자바는 어떻게 실현했는가? 를 다시 보자.</p>\n<p>자바는 이를 <strong>컴파일러와 인터프리터</strong> 두 개 다 사용함으로써 극복해냈다.</p>\n<p>사실 자바 컴파일러(javac)는 C의 gcc나 visual c와 같이 <code class=\"language-text\">excutable</code> 파일을 만드는 것이 목적이 아니다.</p>\n<p>자바 컴파일러의 목적은 해당 소스코드들을 <code class=\"language-text\">JVM(Java Virtual Machine)</code> 이 이해할 수 있는 <strong>자바 바이트코드(.class)</strong> 로 변환하는 것이다.</p>\n<p>플랫폼 종속적인 부분을 JVM을 통해서 해결하고자 한 것인데 자바 코드를 실행하고자하면 <strong>JVM이라는 가상머신 위에서 돌아가서 플랫폼의 영향을 안받게</strong> 하고자 한 것이다. 따라서, 자바라는 언어는 플랫폼은 비종속적이나 JVM에 종속적인 언어라 보는게 맞다고 생각한다.</p>\n<p>근데 웃긴 것은 JVM 자체는 <strong>플랫폼 종속적</strong>이라는 것이다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/22961251/103324906-2dffca80-4a41-11eb-95e8-311f2fe7e85e.png\" alt=\"Screen_Shot_2020-12-25_at_11 18 40_PM\"></p>\n<p>Zulu의 JDK 다운로드 사이트이다. OS뿐만 아니라 Architecture에 따라 JDK가 다름을 볼 수가 있다.</p>\n<p>예시는 이번 M1 맥북이 될 수 있을 것 같다. 같은 Mac OS여도 M1 맥북이냐 Intel 맥북이냐에 따라서 JDK도 다르게 받아야한다는 것이다.</p>\n<p>JVM 얘기하다가 왜 뜬금없이 JDK 얘기를 하는지 의아해할 수 있다.</p>\n<p>우리가 자바를 실행하기 위해서 사용하는 <code class=\"language-text\">JDK(Java Development Kit)</code> 안에는 JRE가 포함되어있는데 그 JRE안에 JVM이 포함되어 있다.</p>\n<ul>\n<li>JDK 컴포넌트</li>\n</ul>\n<p align=\"center\">\n    <img src=\"https://user-images.githubusercontent.com/22961251/103324933-42dc5e00-4a41-11eb-9742-edae34e4ec33.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.inflearn.com/course/the-java-code-manipulation\">백기선, 더 자바, 코드를 조작하는 다양한 방법, 2019</a></em>\n</p>\n<p>모듈화 시스템이 도입됨에 따라 JRE가 모듈로 대체되긴했지만 이 부분은 나중에 JVM에 대해서 좀 더 깊게 다룰 때 얘기해보도록 하겠다.</p>\n<p>각설하고, 즉, 플랫폼 종속적인 JDK를 받으면 해당 플랫폼의 네이티브 코드로 번역을 위한 JVM이 같이 들어가있다는 걸 알 수 있다.</p>\n<p>자바의 목표인 WORA(Write Once, Run Anywhere)는 <code class=\"language-text\">자바 소스코드 → JVM (자바 바이트 코드) → 네이티브 코드 변환</code> 의 순서로 해당 목표를 실현해낸 것이다.</p>\n<p>따라서, 우리는 Java 코드를 작성하면 어떤 플랫폼이든 해당 플랫폼의 네이티브 코드로 변환을 해줄 수 있는 JVM만 있으면 돌아가는 것이다.</p>\n<p>그렇다면 Java에서 인터프리터를 사용하는 이유는 무엇일까?</p>\n<p>인터프리터가 실질적으로 JVM에 저장된 <strong>자바 바이트 코드를 네이티브 코드로 번역</strong>하는 것이다.</p>\n<p>지금까지 내용을 정리하자면</p>\n<p><code class=\"language-text\">자바 소스코드 → 자바 컴파일러 → 자바 바이트 코드 → JVM → 자바 인터프리터 → 네이티브 코드</code></p>\n<p>이런 순서가 된다고 알 수가 있다.</p>\n<p>근데 웃긴 것은 방금 전에 간략하게 내가 인터프리터는 <strong>느리다</strong>고 얘기했다.</p>\n<blockquote>\n<p>아 C에 비해 자바가 느리다는게 JVM 위에서 돌아가고 인터프리터까지 쓰기때문인가?</p>\n</blockquote>\n<p>어느 정도 맞다고 볼 수 있다. 요즘 동작환경이 되는 시스템 사양자체가 성능이 뛰어나고, HotSpot VM과 같은 뛰어난 JVM을 통해서 극복을 해가고 있으며 점차 격차는 줄어들고 있지만 구조적 특성 상 미미한 차이지만 상대적으로 느린 것은 맞다. 사실 이 부분은 나보다 더 뛰어난 분이 분석을 해놨다.</p>\n<p><a href=\"https://codevang.tistory.com/83?category=827598\">Java의 메모리 구조_기본 구조[1/3]</a></p>\n<p>해당 포스팅은 3개의 시리즈 문서인데 1편이 아키텍처적인 부분을 다루고 있고, 관심이 있으면 다음 포스팅도 읽어도 도움이 매우 될 것이다. 하나하나 읽으면서 감탄사만 뱉었다.</p>\n<p>근데 해당 포스팅을 보면 <code class=\"language-text\">자바 바이트 코드 → 기계어</code> 로 변환 시에 JIT컴파일러와 인터프리터를 쓴다고 하였다.</p>\n<p>JIT 컴파일러는 왜 또 쓸까? 이것은 인터프리터의 성능을 조금이라도 더 올리기 위해서라고 생각하면 된다.</p>\n<p>인터프리터는 한줄씩 읽어 내려가면서 번역한다했는데 그러면 계속해서 <strong>반복되는 구문을 불러들이는 경우</strong>는 효율이 떨어지는 것이라 볼 수도 있을 것이다.</p>\n<p>이때, JIT 컴파일러가 사용되는데 반복적인 코드는 JIT 컴파일러(바이트 코드 → 네이티브 코드)한테 보내서 미리 바꿔서 저장해둔다. 인터프리터는 해당 구문을 만나면 저장해둔 결과를 가져와서 네이티브 코드로 바꿔서 수행하는 로직을 수행한다.</p>\n<p>자 이제, 어떤 방식으로 구동되는 지 이해했으니 JVM 구조와 Class Loader에 대해서 깊게 들어가보고자 한다.</p>\n<h1 id=\"step-2-jvm-구조\" style=\"position:relative;\"><a href=\"#step-2-jvm-%EA%B5%AC%EC%A1%B0\" aria-label=\"step 2 jvm 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2. JVM 구조</h1>\n<p>위에서 자바 컴파일러의 역할은 <code class=\"language-text\">자바 소스코드(.java) → 자바 바이트코드(.class)</code> 로 바꾼 후에 JVM에 로딩한다고 말했었다. 이 자바 컴파일러에 의해 생성된 자바 바이트 코드를 JVM의 클래스 로더 시스템을 활용하여 메모리에 적재한 후에 실행 엔진에서 런타임 시 인터프리터와 JIT 컴파일러를 활용하여 실제 <code class=\"language-text\">자바 바이트 코드 → 네이티브 코드</code> 로 변경하여 실행한다고 보면 된다.</p>\n<p>그림으로 보자면 다음과 같다고 볼 수 있다.</p>\n<p align=\"center\">\n    <img src=\"https://user-images.githubusercontent.com/22961251/103324980-846d0900-4a41-11eb-9a9a-cfc9e16ce227.png\">\n</p>\n<p align=\"center\">\n    <em>Benjamin J.Evans,Java Optimizing(O'Reilly Media,2019),49.</em>\n</p>\n<p>정리하자면 아래의 순서를 따른다.</p>\n<ol>\n<li>실행될 클래스 파일을 메모리에 로드 후 초기화 작업 수행</li>\n<li>메소드와 클래스 변수들을 해당 메모리 영역에 배치</li>\n<li>클래스로드가 끝난 후 지역변수, 객체변수, 참조변수를 스택영역에 쌓음</li>\n<li>다음 라인을 진행하면서 상황에 맞는 작업을 수행</li>\n</ol>\n<p>이제 위의 과정을 좀 더 깊게 들여다 볼 시간이다.</p>\n<p align=\"center\">\n    <img src=\"https://user-images.githubusercontent.com/22961251/103325299-1c1f2700-4a43-11eb-8c3f-0c317a940a06.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.inflearn.com/course/the-java-code-manipulation\">백기선, 더 자바, 코드를 조작하는 다양한 방법, 2019</a></em>\n</p>\n<p>JVM(Java Virtual Machine)은 위와 같은 구조로 설계되어있다.</p>\n<p>하나씩 살펴보고자 한다.</p>\n<h2 id=\"step-21-클래스-로더-시스템-영역class-loader-system-area\" style=\"position:relative;\"><a href=\"#step-21-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A1%9C%EB%8D%94-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%98%81%EC%97%ADclass-loader-system-area\" aria-label=\"step 21 클래스 로더 시스템 영역class loader system area permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.1 클래스 로더 시스템 영역(Class Loader System Area)</h2>\n<p>자바 바이트 코드를 읽고 메모리에 적재하는 역할을 수행하는데 메모리를 적재하는 과정은 크게 3개로 나뉜다.</p>\n<ul>\n<li>로딩(loading) : 클래스를 파일에서 가져와서 JVM의 메모리에 로드한다.</li>\n<li>링킹(linking) : 레퍼런스를 연결하는 과정</li>\n<li>초기화(initialization) : <code class=\"language-text\">static</code> 한 값들을 초기화 한다.</li>\n</ul>\n<p align=\"center\">\n    <img src=\"https://user-images.githubusercontent.com/22961251/103325319-30fbba80-4a43-11eb-9366-8ed89f68c6c3.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.inflearn.com/course/the-java-code-manipulation\">백기선, 더 자바, 코드를 조작하는 다양한 방법, 2019</a></em>\n</p>\n<p>클래스가 실질적으로 적재되는 순서는 <code class=\"language-text\">로딩 → 링킹 → 초기화</code> 순서로 진행된다.</p>\n<p>자바의 동적로딩이 가능한 이유가 바로 이 클래스 로더 때문이기도 하다.</p>\n<p>해당 프로세스를 보기 전에 로딩 아래 놓여져 있는 <code class=\"language-text\">Bootstrap, Extenstion, Application</code>과 같은 키워드를 이해해야할 필요가 있다.</p>\n<p>해당 키워드들은 클래스 로더의 종류를 나타낸다고 볼 수 있다.</p>\n<p>화살표 순서대로 순차적으로 실행된다.</p>\n<p><code class=\"language-text\">BootStrap Class Loader → Extension Class Loader → Application(=System) Class Loader</code></p>\n<p>자바는 확장성이 좋은 언어다보니 직접 클래스 로더를 구현해서 사용할 수 있다. 이러한 것들을 사용자 정의 클래스로더(User-Defined Class Loader)라 부르며, 이런 클래스 로더들은 <strong>Application Class Loader</strong> 이후에 로딩된다.</p>\n<p>실질적인 구조는 아래와 같이 되어 있다.</p>\n<p align=\"center\">\n    <img src=\"https://user-images.githubusercontent.com/22961251/103325493-fa726f80-4a43-11eb-8849-5ef3218c9c41.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://resian-programming.tistory.com/63\">Resian, ClassLoader의 특징과 종류, 2020</a></em>\n</p>\n<p>이 화살표는 <strong>상속 관계</strong>를 나타낸 것이므로 로딩 순서는 역순이라는 것을 잊으면 안된다.</p>\n<blockquote>\n<p>상속이라 했는가?</p>\n</blockquote>\n<p>맞다. 클래스 로더는 계층적 구조를 갖고 있는데 잠깐 클래스 로더의 특징을 살펴보자.</p>\n<h3 id=\"step-211-클래스-로더의-특징class-loaders-feature\" style=\"position:relative;\"><a href=\"#step-211-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A1%9C%EB%8D%94%EC%9D%98-%ED%8A%B9%EC%A7%95class-loaders-feature\" aria-label=\"step 211 클래스 로더의 특징class loaders feature permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.1.1 클래스 로더의 특징(Class Loader’s feature)</h3>\n<p>클래스 로더의 특징</p>\n<ul>\n<li>클래스 로더는 계층적(Hierarchical)이다.</li>\n<li>클래스 로더는 가시적인 규약(Visibility Constraint)을 갖고 있다.</li>\n<li>클래스 로더는 위임형 로드 요청(Delegate Load Request)의 특징을 갖고 있다.</li>\n<li>클래스 로더에 로드된 클래스는 언로드가 불가능하다.</li>\n</ul>\n<p align=\"center\">\n    <img src=\"https://user-images.githubusercontent.com/22961251/103325331-496bd500-4a43-11eb-9f95-b2c59a7f419a.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://engkimbs.tistory.com/606\">새로비, Java 클래스 로딩 과정, 2018</a></em>\n</p>\n<p><strong>클래스 로더는 계층적이다.</strong></p>\n<p>위의 그림과 같이 최상위 부모클래스는 BootStrap Class Loader이고, 그 밑에 부모-자식 관계를 갖고 있다.</p>\n<p align=\"center\">\n    <img src=\"https://user-images.githubusercontent.com/22961251/103325493-fa726f80-4a43-11eb-8849-5ef3218c9c41.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://resian-programming.tistory.com/63\">Resian, ClassLoader의 특징과 종류, 2020</a></em>\n</p>\n<p><strong>클래스 로더는 가시적인 규약을 갖고 있다.</strong></p>\n<p>여기서 말하는 가시적인 규약은 일련의 규칙을 갖고 있다고 생각해도 될 것 같다. 그 규칙은 다음과 같다.</p>\n<ul>\n<li>자식 클래스 로더에서 찾지 못한 클래스 → (위임) 부모 클래스 로더에서 찾을 수 있음.</li>\n<li>부모 클래스 로더에서 찾지 못한 클래스 → 자식 클래스 로더에서 찾을 수 없음.</li>\n</ul>\n<p>즉, 하위 클래스 로더는 상위 클래스 로더의 Class를 위임형 로드 요청(Delegate Load Request)를 통해서 찾을 수 있지만 반대는 불가능하다.</p>\n<p>또한 상위 클래스 로더가 같은 하위 클래스는 서로 로딩한 클래스를 사용할 수 없다는 룰을 가시적인 규약이라 한다.</p>\n<p align=\"center\">\n    <img src=\"https://user-images.githubusercontent.com/22961251/103325489-f8a8ac00-4a43-11eb-982a-ec379b1f8574.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://resian-programming.tistory.com/63\">Resian, ClassLoader의 특징과 종류, 2020</a></em>\n</p>\n<p><strong>클래스 로더는 위임형 로드 요청(Delegate Load Request)의 특징을 갖고 있다.</strong></p>\n<p>상위 클래스 로더가 로딩한 클래스가 우선권을 갖는 것을 위임형 로드 요청이라 한다.</p>\n<p><strong>클래스 로더에 로드된 클래스는 언로드가 불가능하다.</strong></p>\n<p>클래스 로더에는 클래스 언로딩(Unloading) 기능이 없다. 따라서, 언로딩을 하기 위해서는 Class Loader 자체를 삭제하고 재생성해야된다.</p>\n<p>다음으로는 JVM의 나머지 구조인 <strong>메모리</strong> <strong>영역</strong>과 <strong>실행 엔진</strong>에 대해서 알아보자.</p>\n<h2 id=\"step-22-메모리-영역runtime-data-area\" style=\"position:relative;\"><a href=\"#step-22-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%ADruntime-data-area\" aria-label=\"step 22 메모리 영역runtime data area permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.2 메모리 영역(Runtime Data Area)</h2>\n<p>JVM이 운영체제 위에서 실행되면서 할당받는 메모리 영역으로, Class Loader에서 준비한 데이터들을 보관한다. 메모리 영역은 크게 모든 쓰레드가 공유하는 영역과 쓰레드별로 하나씩 생성되는 영역으로 나뉘어진다.</p>\n<ol>\n<li>모든 쓰레드가 공유하는 영역\n<ul>\n<li>메소드 영역(Method Area)</li>\n<li>힙 영역(Heap Area)</li>\n</ul>\n</li>\n<li>쓰레드 별 하나씩 생성되는 영역\n<ul>\n<li>스택 영역(Stack Area)</li>\n<li>네이티브 메소드 영역(Native Method Area)</li>\n<li>PC 레지스터(Program counter Register)</li>\n</ul>\n</li>\n</ol>\n<p>밑에서는 위의 영역들을 하나씩 살펴보고자 한다.</p>\n<p><strong>메소드 영역</strong></p>\n<ul>\n<li>클래스 수준의 정보 (클래스 이름, 부모 클래스 이름, 메소드, 변수) 저장하는 영역이다.</li>\n</ul>\n<p>메소드 영역은 사실 클래스 영역(Class Area)이라고도 부르고 정적 영역(Static Area)라고도 부른다.</p>\n<p>클래스 수준의 정보가 저장된다는 뜻은 <strong>클래스 파일의 바이트 코드가 로드 되는 곳</strong>이라고 생각하면 된다.</p>\n<p>즉, JVM이 시작될 때 생성되는 영역이며 JVM이 읽어 들인 각각의 클래스와 인터페이스에 대한 정보들이 보관된다.</p>\n<p><strong>힙 영역</strong></p>\n<ul>\n<li>힙 영역에는 객체를 저장하는 영역이다.</li>\n</ul>\n<p>즉, <code class=\"language-text\">Person person = new Person();</code> 을 수행하면 해당 인스턴스 변수가 놓이는 영역이다.</p>\n<p>생성이 된 인스턴스는 가비지 컬렉터에 의해 지워지거나 JVM이 종료될 때까지 힙 영역에 남아있게 된다.</p>\n<p><strong>스택 영역</strong></p>\n<ul>\n<li>쓰레드 마다 런타임 쓰레드를 만들고  그 안에 메소드 호출(Method Call)을 스택 프레임이라 부르는 블럭으로 쌓는다. 쓰레드 종료하면 런타임 스택도 사라진다.</li>\n</ul>\n<p><strong>PC 레지스터</strong></p>\n<ul>\n<li>쓰레드 마다 쓰레드 내 현재 실행할 스택 프레임을 가르키는 포인터가 생성된다.</li>\n</ul>\n<p><strong>네이티브 메소드 스택</strong></p>\n<p>네이비티브 메소드 스택이란 자바 외의 언어로 작성된 네이티브 코드를 위한 스택이다. 이 때, 네이티브 메소드 인터페이스를 통해 호출하는 코드들을 위한 스택이라고 생각하면 될 것같다.</p>\n<ul>\n<li>\n<p>쓰레드 마다 생성되며 네이티브 메소드 사용시 별도로 생성되는 스택</p>\n<p>→  예시) <code class=\"language-text\">Thread.currentThread()</code></p>\n</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/22961251/103325596-49b8a000-4a44-11eb-85aa-50da8499f074.png\" alt=\"native method\"></p>\n<p>위와 같이 <code class=\"language-text\">native</code> 키워드가 붙은 것들이 네이티브 메소드들이라고 보면 될 것 같다.</p>\n<h2 id=\"step-23-실행-엔진execution-engine\" style=\"position:relative;\"><a href=\"#step-23-%EC%8B%A4%ED%96%89-%EC%97%94%EC%A7%84execution-engine\" aria-label=\"step 23 실행 엔진execution engine permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.3 실행 엔진(Execution Engine)</h2>\n<p>클래스 로더를 통해 JVM 내 런타임 데이터 영역에 배치된 바이트코드들이 실제 실행되기 위해 사용되는 영역</p>\n<h3 id=\"인터프리터\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0\" aria-label=\"인터프리터 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인터프리터</h3>\n<ul>\n<li>자바 바이트 코드를 한 줄씩 실행</li>\n</ul>\n<p>이 때문에 느린 부분이 있는데 단점을 보완하기 위해서 JIT 컴파일러 사용</p>\n<h3 id=\"jit컴파일러\" style=\"position:relative;\"><a href=\"#jit%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC\" aria-label=\"jit컴파일러 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JIT 컴파일러</h3>\n<ul>\n<li>인터프리터의 단점을 보완하기 위해 도입되었다.</li>\n</ul>\n<p>반복적인 코드는 JIT 컴파일러(바이트 코드 → 네이티브 코드)한테 보내서 미리 바꿔서 저장해둔다. 인터프리터는 해당 구문을 만나면 저장해둔 결과를 가져와서 네이티브 코드로 바꿔서 수행한다.</p>\n<p>참고로 JIT 컴파일러가 컴파일하는 과정은 당연히 컴파일러다 보니 하나씩 인터프리팅하는 것보다 느리다. 따라서, 자주 수행되는 수행 여부 체크와 이 코드가 어느정도 반복됐는지 여부 등을 체크하여 컴파일을 수행한다.</p>\n<h3 id=\"gcgarbage-collector\" style=\"position:relative;\"><a href=\"#gcgarbage-collector\" aria-label=\"gcgarbage collector permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GC(Garbage Collector)</h3>\n<ul>\n<li>애플리케이션이 생성한 객체의 생존 여부를 판단하여 더 이상 사용되지 않는 객체를 해제하는 방식으로 메모리를 자동 관리함.</li>\n</ul>\n<p>GC는 나중에 따로 포스팅을 해보고자 한다.</p>\n<p>자 이제 JVM의 큰 덩어리들은 훑어봤다고도 할 수 있다. 이제 실질적으로 바이트 코드가 어떻게 로드되서 동작하는지 지금까지의 개념을 토대로 생각해보자.</p>\n<h2 id=\"step-24-클래스-로딩-과정class-loading-process\" style=\"position:relative;\"><a href=\"#step-24-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A1%9C%EB%94%A9-%EA%B3%BC%EC%A0%95class-loading-process\" aria-label=\"step 24 클래스 로딩 과정class loading process permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.4 클래스 로딩 과정(Class Loading Process)</h2>\n<p align=\"center\">\n    <img src=\"https://user-images.githubusercontent.com/22961251/103325319-30fbba80-4a43-11eb-9366-8ed89f68c6c3.png\">\n</p>\n<p align=\"center\">\n    <em><a href=\"https://www.inflearn.com/course/the-java-code-manipulation\">백기선, 더 자바, 코드를 조작하는 다양한 방법, 2019</a></em>\n</p>\n<p><strong>로딩(Loading)</strong></p>\n<p>클래스 로더가 바이트 코드를 읽고 그 내용에 따라 적절한 바이너리 데이터를 만들고 메소드 영역에 저장한다. (JVM의 메모리에 로드한다고 보면 된다.)</p>\n<p>이때 메소드 영역에는 다음과 같은 데이터들이 저장된다.</p>\n<ul>\n<li>FQCN(Fully Qaulified Class Name)</li>\n<li>클래스인지 인터페이스인지 이늄인지 여부</li>\n<li>메소드와 변수</li>\n</ul>\n<p>로딩을 하고 나면 해당 클래스 타입의 <code class=\"language-text\">Class&lt;?></code> 객체를 생성하여 힙 영역에 저장한다.</p>\n<p><strong>링킹(Linking)</strong></p>\n<p>링킹은 세가지 단계로 나뉘어진다.</p>\n<ol>\n<li>검증(Verifiy)</li>\n<li>준비(Prepare)</li>\n<li>분석(Reslove)</li>\n</ol>\n<p>검증 : <code class=\"language-text\">.class</code> 파일 형식이 유효한지 검증한다.</p>\n<p>준비 : 메모리를 준비하는 과정으로 <code class=\"language-text\">static</code> 변수와 기본 값에 필요한 메모리를 준비</p>\n<p>분석 : 심볼릭 메모리 레퍼런스를 메소드 영역에 있는 실제 레퍼런스로 교환한다.<em><strong>(optional)</strong></em></p>\n<p>여기서 심볼릭 메모리 레퍼런스는 클래스가 로드가 되면 실제 힙영역의 레퍼런스 영역을 가르키는 것이 아니라 논리적인 주소만 가르키고 있는 것을 뜻한다. 이를 Resolve 단계에서 실제 힙 영역의 레퍼런스를 가르키게 한다.</p>\n<p>이제 각 과정을 배웠으니 실질적으로 동적 로딩이 어떤 식으로 이뤄지는 지 보자.</p>\n<p>포스팅 중간 중간에 동적 로딩(Dynamic Loading)이 계속해서 나온 것을 알 수 있다.</p>\n<p>당최 동적 로딩이란 무엇일까?</p>\n<p>지금까지 공부했던 내용으로 총 정리를 해보자.</p>\n<ol>\n<li>자바 컴파일러(javac)가 자바 소스코드(<code class=\"language-text\">.java</code>)를 자바 바이트 코드(<code class=\"language-text\">.class</code>)로 컴파일한다.</li>\n<li><strong>Class Loader</strong>를 통해서 Class 파일을 JVM으로 로딩한다.</li>\n<li>로딩된 자바 바이트 코드들을 실행 엔진(Excution Engine)이 해석한다.</li>\n<li>해석된 바이트 코드는 메소드 영역(Runtime Data Area)에 배치되서 실질적으로 돌아간다.</li>\n</ol>\n<p>이번에 집중적으로 분석해볼 구간은 2번이라고 보면 될 것 같다.</p>\n<p>클래스 로더는 두 가지 방식으로 클래스를 로딩한다.</p>\n<ol>\n<li><strong>로드타임 동적 로딩(load-time dynamic loading)</strong></li>\n<li><strong>런타임 동적 로딩(run-time dynamic loading)</strong></li>\n</ol>\n<p>이를 좀 더 깊게 다뤄보고자 한다.</p>\n<h2 id=\"step-241-동적로딩\" style=\"position:relative;\"><a href=\"#step-241-%EB%8F%99%EC%A0%81%EB%A1%9C%EB%94%A9\" aria-label=\"step 241 동적로딩 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.4.1 동적로딩</h2>\n<p>자바는 동적으로 클래스 로더를 통해서 클래스를 읽어 들인다. 이 과정은 런타임에 이뤄진다.</p>\n<p>런타임에 동적으로 클래스를 로딩하는 것은 JVM이 클래스에 대한 정보를 갖고 있지 않다는 것을 의미한다.</p>\n<p>즉, JVM은 이 클래스가 유효한지를 로딩할 때 판단해야 된다. JVM은 내부적으로 클래스를 분석할 수 있는 기능을 갖고 있으며 개발자들은 이것을 리플렉션(<strong>Reflection</strong>)을 통해서 분석을 할 수 있다.</p>\n<h3 id=\"step-242-로드타임-동적-로딩load-time-dynamic-loading\" style=\"position:relative;\"><a href=\"#step-242-%EB%A1%9C%EB%93%9C%ED%83%80%EC%9E%84-%EB%8F%99%EC%A0%81-%EB%A1%9C%EB%94%A9load-time-dynamic-loading\" aria-label=\"step 242 로드타임 동적 로딩load time dynamic loading permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.4.2 로드타임 동적 로딩(load-time dynamic loading)</h3>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span></span><span class=\"token operator\">*</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">HelloWorld</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"안녕하세요!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>해당 <code class=\"language-text\">HelloWorld</code> 클래스를 실행하였다 가정해보면, 명령행에서는 다음과 같이 입력이 될 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token variable\">$java</span> HelloWorld</code></pre></div>\n<p>이 경우에 JVM이 시작되고 클래스로더가 생성되면서 코드를 수행하기 위한 과정이 수행될 것이다.</p>\n<p>제일 먼저 우리가 알고있는대로 <code class=\"language-text\">BootStrap ClassLoader</code> 가 생성되며 <code class=\"language-text\">Object</code> 클래스를 읽어온다.</p>\n<p>그 이후에 <code class=\"language-text\">HelloWorld</code> 클래스를 로딩하기 위해서 해당 클래스의 바이트 코드를 읽어온다.</p>\n<p>이 때, <code class=\"language-text\">java.lang.String</code> 과 <code class=\"language-text\">java.lang.System</code>같은 클래스가 필요할 것이다.</p>\n<p>이 두 개의 클래스는 <code class=\"language-text\">HelloWorld</code> 클래스가 로드되는 시점에서 로드된다.</p>\n<p>즉, 다른 클래스를 읽어오는 과정에서 함께 로딩되는 것을 <strong>로드타임 동적 로딩</strong>이라고 한다.</p>\n<h3 id=\"step-243-런타임-동적-로딩load-time-dynamic-loading\" style=\"position:relative;\"><a href=\"#step-243-%EB%9F%B0%ED%83%80%EC%9E%84-%EB%8F%99%EC%A0%81-%EB%A1%9C%EB%94%A9load-time-dynamic-loading\" aria-label=\"step 243 런타임 동적 로딩load time dynamic loading permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 2.4.3 런타임 동적 로딩(load-time dynamic loading)</h3>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">HelloWorld1</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Runnable</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"안녕하세요, 1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">HelloWorld2</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Runnable</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"안녕하세요, 2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>위의 코드를 활용해서 런타임 동적 로딩의 과정을 알아보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RuntimeLoading</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n           <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"사용법: java RuntimeLoading [클래스 이름]\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n           <span class=\"token punctuation\">}</span>\n           <span class=\"token class-name\">Class</span> klass <span class=\"token operator\">=</span> <span class=\"token class-name\">Class</span><span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n           <span class=\"token class-name\">Object</span> obj <span class=\"token operator\">=</span> klass<span class=\"token punctuation\">.</span><span class=\"token function\">newInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n           <span class=\"token class-name\">Runnable</span> r <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">)</span> obj<span class=\"token punctuation\">;</span>\n           r<span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> ex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n           ex<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n     <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 코드에서 <code class=\"language-text\">Class</code> 객체를 <code class=\"language-text\">forName()</code> 메소드를 통해서 찾은 후에 <code class=\"language-text\">Class</code> 객체로 매핑하는 것을 확인할 수 있다. 이러한 행위들이 리플렉션 API를 통해서 이뤄진다. <code class=\"language-text\">forName()</code> 메소드를 통하여 클래스 객체를 가져 온 후</p>\n<p>필드 값이나 메소드 이름, 어노테이션 등의 정보를 가져올 수 있다.</p>\n<p>리플렉션은 포스팅을 할지 안할지는 모르겠지만 일단 넘어가고 대충 <code class=\"language-text\">main(String[] args)</code> 로 넘어온 인자의 값을 통해서 클래스 서칭을 하여 클래스 객체를 로딩한다고 이해하면 된다.</p>\n<p><code class=\"language-text\">Object obj = klass.newInstance()</code> 구문을 보면 인자로 넘어온 클래스를 인스턴스화하는 것을 알 수 있다.</p>\n<p>대충 예시는 이렇게 볼 수 있을 것 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Class</span> klass <span class=\"token operator\">=</span> <span class=\"token class-name\">Class</span><span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"java.lang.Integer\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Object</span> obj <span class=\"token operator\">=</span> klass<span class=\"token punctuation\">.</span><span class=\"token function\">newInstace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>여기서 눈치를 챘을 수도 있다. 즉, <code class=\"language-text\">forName()</code> 메소드를 통해 어떤 인자가 들어오는 지에 따라 로드되는 클래스가 달라진다는 점이다. (어떤 클래스를 참조하는 지 알 수 없다.)</p>\n<p>실질적인 클래스가 참조되는 시점은 <code class=\"language-text\">main()</code> 메소드가 수행되고 <code class=\"language-text\">Class.forName(args[0])</code> 을 호출하는 순간 결정된다는 것이다.</p>\n<p>이렇게 클래스를 로딩할 때가 아닌 <strong>코드를 실행하는 순간에 클래스를 로딩하는 것을 런타임 동적 로딩</strong>이라 한다.</p>\n<blockquote>\n<p>아니 그래서 자바 코드 핫스왑은 어떻게 구현하는데?</p>\n</blockquote>\n<p>이정도까지 읽으면서 따라오신 분들은 핫스왑은 다음과 같은 방식으로 자바에서 구현이 가능할 수 있다.</p>\n<ol>\n<li><strong>Class Loader 구현을 통한 Hot Swap</strong></li>\n<li><strong>바이트코드 조작을 통한 Hot Swap</strong></li>\n</ol>\n<p>1번의 아이디어는 다음과 같다. 런타임 시 로드된 클래스의 변경이 있을 경우 로드된 파일로 다시 클래스 로더에 올리는 방식이다. 하지만 이거와 같은 경우는 문제가 좀 있다.</p>\n<p>일단, 위의 클래스 로더 특징을 통해 말했듯이 Java Class Loader는 언로딩(Unloading) 기능이 존재하지 않는다.</p>\n<p>극단적으로는 <code class=\"language-text\">클래스 파일이 변경 → 클래스 로더 삭제 → 재생성 → 클래스 로더</code> 이러한 방식을 취해야할 것이다.</p>\n<p>물론 1개의 클래스 변경된 상태에서 로더를 삭제하고 올리는 것은 상관이 없을 수 있다. 그러나, 상속관계를 생각하고 거기다가 어노테이션까지 생각하면 매우 복잡해질 문제가 될 수 있다.</p>\n<p>실행엔진 부분도 문제가 된다. 인터프리팅이나 JIT 컴파일러를 사용할 때 JIT 컴파일 전에 최적화 하느라 메소드 호출 부분을 실제 코드로 바꿔준다. 잘 생각해보자. 메소드가 추가되면 해당 메소드와 동일한 이름을 가진 메소드가 존재하는지 존재유무 파악이랑 상위클래스도 뒤져야하고 생각보다 매우 복잡한 작업이 될 것이다.</p>\n<p>이러한 방식은 성능과 복잡도에서 비용이 매우 비싸다고 볼 수 있다.</p>\n<p>이는 개인적인 의견이므로 사람마다 의견이 다를 것이라고 생각한다.</p>\n<p>Jrebel 블로그에 자세히 나와있는데 이 부분을 참고하면 도움이 될 것 같다.</p>\n<p><a href=\"https://www.jrebel.com/blog/how-to-use-java-class-loaders\">how-to-use-java-class-loaders</a></p>\n<p><a href=\"https://www.jrebel.com/blog/how-do-classloader-leaks-happen\">how-do-classloader-leaks-happen</a></p>\n<p><a href=\"https://www.jrebel.com/blog/java-hotswap-guide\">java-hotswap-guide</a></p>\n<p>2번의 아이디어는 다음과 같다. 언로드가 안된다면 로드된 바이트코드를 뜯어서 변경된 걸로 교체하면 되는거 아닌가? 에서 출발했다고 볼 수 있다. 즉, 변경점을 추적해서 변경 클래스 파일의 바이트 코드 자체를 변경해버리면 이미 로드가 되어있어도 변경된 바이트 코드로 동작하니까 말이다.</p>\n<p>바이트코드를 조작하는 방식은 다양하게 존재하는데</p>\n<ol>\n<li>\n<p><code class=\"language-text\">.class</code> 내용을 변경하여 조작</p>\n<p>→ instance 로드할 때 기존 바이트코드의 정보가 메모리에 올라가있으므로</p>\n<p><code class=\"language-text\">.class</code> 파일의 바이트코드 변경 후 동작하는 소스를 실행토록 해야함.</p>\n</li>\n<li>\n<p>클래스를 로딩할 떄 바이트코드를 조작하여 메모리에 적재</p>\n<p>→ 코드의 순서에 종속되는 문제가 있다.</p>\n<p>다른 클래스에서 이미 해당 인스턴스를 메모리에 올렸을 경우, 바이트코드가 변경되지 않고 올라갈 수 있다.</p>\n</li>\n<li>\n<p>javaagent를 활용하여 클래스 로드 시 바이트코드를 변경하여 메모리에 적재</p>\n</li>\n</ol>\n<p>바이트 코드 조작의 기술은 코드 커버리지 도구나 프로파일러 그리고 핫스왑 기능을 제공해주는 라이브러리들도 사용하는 기술이라고 보면 된다.</p>\n<p>핫스왑을 지원하는 도구들은 1번과 2번의 아이디어와 더불어 자체적인 아이디어를 통해서 이러한 핫스왑 기능을 지지원한다. 대표적인 도구들은 다음과 같다.</p>\n<p><a href=\"https://www.jrebel.com/products/jrebel\">jrebel</a></p>\n<p><a href=\"https://github.com/spring-projects/spring-loaded\">spring-loaded</a></p>\n<p><a href=\"https://github.com/dcevm/dcevm\">dcevm</a> +\n<a href=\"https://github.com/HotswapProjects/HotswapAgent\">HotswapAgent</a></p>\n<p>spring-loaded의 경우에는 오픈소스로 풀려있어서 소스를 까볼 수가 있는데 ASM이라는 기술을 사용한다.</p>\n<p>사용하기에 매우 복잡한 바이트코드 조작 라이브러리라 볼 수 있다. 요즘은 바이트버디(ByteBuddy)라고 조금 더 쉽게 바이트 코드 조작을 할 수 있는 라이브러리도 등장했다.</p>\n<p>사실 상용으로 쓰이고 많이 쓰이는 자바 핫스왑 제품들 같은 경우에는 구현 자체가 매우 복잡한데 내가 예제로 다뤄볼 코드는 그냥 클래스 리로딩이라고 보는게 적합해보인다.</p>\n<p>즉, 핫스왑 구현이라는 말은 거창하고 그냥 아 이렇게 로드된 클래스를 바꿀 수 있구나 정도만 봐도 될 것 같다.</p>\n<p>예제를 다룰 내용은 1번과 2번에 대해서 간략하게 봐보고 클래스 리로딩 예제들을 조금 다뤄볼 예정이다.</p>\n<h1 id=\"step-4-implement-class-hot-swap-in-java\" style=\"position:relative;\"><a href=\"#step-4-implement-class-hot-swap-in-java\" aria-label=\"step 4 implement class hot swap in java permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 4. Implement class hot swap in java</h1>\n<h2 id=\"step-41-class-loader를-통한-hot-swap-예제\" style=\"position:relative;\"><a href=\"#step-41-class-loader%EB%A5%BC-%ED%86%B5%ED%95%9C-hot-swap-%EC%98%88%EC%A0%9C\" aria-label=\"step 41 class loader를 통한 hot swap 예제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 4.1 Class Loader를 통한 Hot Swap 예제</h2>\n<p>이 부분은 다른 블로거분(DEV 용식님)께서 직접 다룬 내용이 있다.</p>\n<p><a href=\"https://devyongsik.tistory.com/274\">URLClassLoader를 사용 한 class hot deploy (실패)</a> 은 실패사례라 보면 될 것이다.</p>\n<p><a href=\"https://devyongsik.tistory.com/276\">[JAVA] 클래스 hot deploy #2</a> 은 성공사례이다.</p>\n<p>자세한 내용은 해당 블로그를 참고하는게 더 도움이 될 것이라고 생각한다.</p>\n<p>나는 간략하게 실패사례에서 실패했던 이유와 성공사례와 그리고 회고에 대해서 설명하고자 한다.</p>\n<p>실패 사례의 아이디어를 보자면 아주 단순하였다.</p>\n<p>Class Loader를 통하여 로드된 클래스는 <strong>unload</strong>가 불가능하니 <code class=\"language-text\">URLClassLoader</code> 를 사용하여 <strong>Class Loader</strong>를 새로 생성하여 클래스를 동적으로 로딩하자! 가 아이디어라 볼 수 있을 것이다.</p>\n<p>하지만 우리는 클래스로더의 특징을 알고 있다.</p>\n<p>이 실패사례는 큰 문제점을 갖고 있는데 바로 <strong>위임형 로드 요청의 특징을 간과했다는 점</strong>이다.</p>\n<p>새로운 <code class=\"language-text\">URLClassLoader</code> 를 생성해봐야 <code class=\"language-text\">Application ClassLoader</code> 에게 클래스 로딩을 위임하기 때문에 실패한 사례이다.</p>\n<p>여기서 DEV 용식님께서는 포기하지 않으시고 새로운 방법을 도출해낸다.</p>\n<blockquote>\n<p>아 그러면 내가 생성한 <code class=\"language-text\">ClassLoader</code> 를 통해 Load하면 클래스를 동적르로 변경된 내용을 적용할 수 있겠네</p>\n</blockquote>\n<p>라고 말이다.</p>\n<p>그것이 바로 성공사례이다.</p>\n<p>즉, 클래스패스에 있는 클래스는 이미 <code class=\"language-text\">Application ClassLoader</code> 가 클래스를 로딩한 상태이기 때문에 하위 클래스 로더에서 아무리 바꿔치기해도 영향이 가지를 않으므로, <code class=\"language-text\">User-Defined ClassLoader</code> 가 물고 올라가도록 하는 것이다.</p>\n<p>이 성공사례를 보면 해당 클래스패스에 파일을 두지 않고, 다른 위치에 클래스를 둔 뒤에 자신이 만든 클래스로더에 변경한 클래스를 컴파일 하면 해당 바이트코드를 물고 들어오면서 변경된 내용이 콘솔로 찍힌다.</p>\n<p>회고한 부분에도 적혀있지만, 이렇게 구현을 했다 한들 클래스 로더가 하나의 클래스만 로딩하는 상태가 아닐 뿐더러 클래스가 바뀔때 마다 클래스 로더를 삭제후 재생성하는 부분은 비효율적이라고 생각한다고 적혀있다.</p>\n<p>해당 부분은 나도 비효율적이라고 생각이 들어서 좀 더 다른 예제들을 찾아보게 되었고 비슷한 예제가 담긴 아티클을 발견하게 되었다.</p>\n<p><a href=\"https://www.toptal.com/java/java-wizardry-101-a-guide-to-java-class-reloading\">java-wizardry-101-a-guide-to-java-class-reloading</a></p>\n<p>예제 2번이 매우 비슷한 예제임을 알 수가 있는데 실제로 구동해보면 아래와 같은 결과가 나온다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/22961251/103325714-e7ac6a80-4a44-11eb-86db-d731546160d4.png\" alt=\"hot-swap example\"></p>\n<p>2번 예제는 <code class=\"language-text\">DynamicClassLoader</code> 를 만들어서 처리하는 데 런타임 시에 소스코드에 변화를 주고 컴파일을 하면 위와 같이 변경된 바이트 코드로 동작하는 모습을 볼 수가 있다.</p>\n<p>단점이라고 하는 부분이 불러올 때마다 새로운 클래스로더가 생성되는 부분인데 이때 새로운 클래스로더가 생성되면서 <strong>Unlink 되므로</strong> 가비지 콜렉터가 처리를 해준다고 한다. 삭제 ↔ 재생성 반복의 코스트는 줄일 수 있으나 GC가 해당 Unlink된 것들에 대한 처리를 하게될텐데 효율이 얼마나 좋을지는 잘 모르겠다.</p>\n<p>이 아티클의 다른 예제도 돌려볼만하다고 생각한다.</p>\n<p>특히, 마지막 예제는 실제 웹 어플리케이션에서도 사용할 수 있을만한 예제를 다루고 있다.</p>\n<p>2번 예제 얘기로 돌아와, 런타임 시에 바뀐 코드로 동작하는 것을 알 수가 있었다.</p>\n<p>하지만, 이 예제의 경우에도 소스를 바꾸면 컴파일을 해야 된다는 단점이 있다.</p>\n<p><code class=\"language-text\">DynamicClassLoader</code> 의 경우에 <code class=\"language-text\">target/classes</code> 의 자바 바이트코드를 읽어 들이기 때문에 우리가 소스를 수정하면 컴파일을 해줘야한다.  뭐 이 부분도 리플렉션 처리를 통해서 변경사항을 추적 후 JVM 상 바이트코드와 비교해서 변경사항이 있으면 사용자가 만든 로더단에서 컴파일을 해서 올릴 수 있도록 가능할 것 같다.</p>\n<h2 id=\"step-42-바이트코드-조작을-통한-hot-swap-예제\" style=\"position:relative;\"><a href=\"#step-42-%EB%B0%94%EC%9D%B4%ED%8A%B8%EC%BD%94%EB%93%9C-%EC%A1%B0%EC%9E%91%EC%9D%84-%ED%86%B5%ED%95%9C-hot-swap-%EC%98%88%EC%A0%9C\" aria-label=\"step 42 바이트코드 조작을 통한 hot swap 예제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 4.2 바이트코드 조작을 통한 Hot Swap 예제</h2>\n<p>많은 블로그에서 Java의 핫 스왑을 위해서 DCEVM과 HotswapAgent를 사용하는 케이스를 보았다.</p>\n<p>DCEVM 공식페이지의 소개글을 보면 다음과 같이 소개하고 있다.</p>\n<blockquote>\n<p>The Dynamic Code Evolution Virtual Machine (DCE VM) is a modification of the Java HotSpot™ VM that allows unlimited redefinition of loaded classes at runtime. The current hotswapping mechanism of the HotSpot™ VM allows only changing method bodies. Our enhanced VM allows adding and removing fields and methods as well as changes to the super types of a class.</p>\n</blockquote>\n<p>단순하게 말하자면 요즘 많이 쓰는 HotSpot VM과 같은 JVM은 핫스왑 매커니즘이 메소드 바디만 변경되는거만 허용하는데 우리는 필드나 메소드 변경이나 삭제 추가등에 대응되어 있다고 되어있다. 아예 JVM을 이걸로 대체해서 쓰는건지 아니면 HotSpot VM과 같이 쓰는지 궁금해서 관련 자료를 계속 찾아봤는데 딱히 제대로 나오는 것은 없었다.</p>\n<p>아무튼 이 <code class=\"language-text\">DCEVM</code>이라는 놈은 주로 <code class=\"language-text\">HotSwapAgent</code>라는 놈과 함께써서 핫스왑을 수행한다.</p>\n<p>VM의 옵션값으로 넣는 걸 보면 대충 동작과정을 얼추 알 수는 있을 거 같다.</p>\n<p>자바 8에서 사용할때는 이러한 옵션을 추가해서 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">-XXaltjvm=dcevm -javaagent:hotswap-agent.jar</code></pre></div>\n<p>대충 보면 JVM은 dcevm으로 대체하고 (위에도 언급했지만 동작과정에 대한 정확한 설명이 없으므로 뇌피셜이다.) <code class=\"language-text\">javaagent</code> 를 <code class=\"language-text\">hotSwapAgent</code> 로 엮어서 사용하는 거 같다.</p>\n<p><code class=\"language-text\">javaagent</code>를 간략하게 설명을 하자면, JVM에서 동작하는 Java 어플리케이션으로써 JVM의 다양한 이벤트를 전달 받거나 정보 질의, 바이트코드 조작등을 특정 API를 통하여 수행할 수 있는 도구이다.</p>\n<p>우리가 많이 쓰는 Lombok이나 JPA의 다이나믹프록시 또한 바이트코드 조작을 통해 수행되는데 이때 ByteBuddy나 javaagent와 같은 도구들을 사용한다.</p>\n<p>이 내용은 나중에 어노테이션 프로세서나 JPA 다이나믹프록시 관련한 포스팅으로 다시 다뤄보고자한다.</p>\n<p>자 이제 <code class=\"language-text\">ByteBuddy</code> 와 <code class=\"language-text\">javaagent</code> 를 통한 간단한 예시를 보고 끝마치도록 하겠다.</p>\n<p>해당 내용은 백기선님의 더 자바, 코드를 조작하는 다양한 방법의 예시 코드이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// Moja.class</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Moja</span> <span class=\"token punctuation\">{</span>\n \n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">pullOut</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Masulsa.class</span>\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">net<span class=\"token punctuation\">.</span>bytebuddy<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">ByteBuddy</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">net<span class=\"token punctuation\">.</span>bytebuddy<span class=\"token punctuation\">.</span>implementation<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">FixedValue</span><span class=\"token punctuation\">;</span>\n \n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">File</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">IOException</span><span class=\"token punctuation\">;</span>\n \n<span class=\"token keyword\">import</span> <span class=\"token keyword\">static</span> <span class=\"token namespace\">net<span class=\"token punctuation\">.</span>bytebuddy<span class=\"token punctuation\">.</span>matcher<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">ElementMatchers</span><span class=\"token punctuation\">.</span>named<span class=\"token punctuation\">;</span>\n \n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Masulsa</span> <span class=\"token punctuation\">{</span>\n \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">new</span> <span class=\"token class-name\">ByteBuddy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">redefine</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Moja</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token punctuation\">.</span><span class=\"token function\">method</span><span class=\"token punctuation\">(</span><span class=\"token function\">named</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"pullOut\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">intercept</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">FixedValue</span><span class=\"token punctuation\">.</span><span class=\"token function\">value</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Rabbit\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token punctuation\">.</span><span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">saveIn</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/Users/dailyworker/workspace/study/build/classes/java/main/\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n \n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Moja</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">pullOut</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>분명 우리 <code class=\"language-text\">Moja</code> 클래스에는 아무런 값을 리턴하지않지만, JVM에 로딩된 바이트 코드를 <code class=\"language-text\">ByteBuddy</code> 를 통해서 조작하는 방식의 코드이다.</p>\n<p><code class=\"language-text\">ByteBuddy().redefine(Moja.class).method(named(\"pullOut\")).intercept(FixedValue.value(\"Rabbit\"))</code></p>\n<p>이게 핵심 코드라 볼 수 있는데 메소드의 이름이 <code class=\"language-text\">pullOut()</code> 인 것을 인터셉트해와서 <code class=\"language-text\">FiexedValue</code> 로 밸류를 강제로 집어넣고 <code class=\"language-text\">redefine</code> 을 통해서 클래스를 재정의한 방식이라 볼 수 있다.</p>\n<p>근데 이 방식도 우리가 위에서 클래스 로더를 통해서 작업했던거 마냥 단점이 있다.</p>\n<p>일단 먼저 ByteBuddy를 통하여 클래스 재정의 부분을 수행한 후에 해당 바이트코드를 주석처리나 제거를 한 후에 <code class=\"language-text\">pullOut</code> 을 호출해야된다.</p>\n<p>이렇게 하는 이유는 DEV 용식님의 실패사례를 설명했던 것과 동일한데, 이미 메모리 로딩된 원본 모자 클래스를 참조해 실행하기 때문에 변경된 클래스 파일을 참조하지 않기 떄문이다.</p>\n<p>이것도 결국에는 바이트코드가 조작된 클래스를 불러오고 싶다면 <strong>클래스로더에 클래스를 올리기 전 시점에 조작</strong>해야된다는 불편함이 있다.</p>\n<p>이런 불편함을 바로 <code class=\"language-text\">javaagent</code> 를 통해서 극복할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MasulsaAgent</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">premain</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> agentArgs<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Instrumentation</span> inst<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">new</span> <span class=\"token class-name\">AgentBuilder<span class=\"token punctuation\">.</span>Default</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n                  <span class=\"token punctuation\">.</span><span class=\"token function\">type</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ElementMatchers</span><span class=\"token punctuation\">.</span><span class=\"token function\">any</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                  <span class=\"token punctuation\">.</span><span class=\"token function\">transform</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">AgentBuilder<span class=\"token punctuation\">.</span>Transformer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n \n                      <span class=\"token annotation punctuation\">@Override</span>\n                      <span class=\"token keyword\">public</span> <span class=\"token class-name\">DynamicType<span class=\"token punctuation\">.</span>Builder</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">transform</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">DynamicType<span class=\"token punctuation\">.</span>Builder</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> builder<span class=\"token punctuation\">,</span> <span class=\"token class-name\">TypeDescription</span> typeDescription<span class=\"token punctuation\">,</span> <span class=\"token class-name\">ClassLoader</span> classLoader<span class=\"token punctuation\">,</span> <span class=\"token class-name\">JavaModule</span> javaModule<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                          <span class=\"token keyword\">return</span> builder<span class=\"token punctuation\">.</span><span class=\"token function\">method</span><span class=\"token punctuation\">(</span><span class=\"token function\">named</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"pullOut\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">intercept</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">FixedValue</span><span class=\"token punctuation\">.</span><span class=\"token function\">value</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Rabbit\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                      <span class=\"token punctuation\">}</span>\n                  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">installOn</span><span class=\"token punctuation\">(</span>inst<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">javaagent</code>는 <code class=\"language-text\">premain()</code> 메소드를 지원하는데 해당 메소드를 통해서 JVM의 실행가능한 최초 진입점인 <code class=\"language-text\">main()</code> 을 가로챌 수 있다. 이때, <code class=\"language-text\">ByteBuddy</code> 가 제공해주는 <code class=\"language-text\">agentBuilder</code> 를 통해서 다시 위에서 했던 로직을 진행한다.</p>\n<p><code class=\"language-text\">pom.xml</code> 에는 다음과 같은 옵션이 추가로 필요하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"xml\"><pre class=\"language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>plugin</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.apache.maven.plugins<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>maven-jar-plugin<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>3.2.0<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>configuration</span><span class=\"token punctuation\">></span></span>\n          <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>archive</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>index</span><span class=\"token punctuation\">></span></span>true<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>index</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>manifest</span><span class=\"token punctuation\">></span></span>\n              <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>addClasspath</span><span class=\"token punctuation\">></span></span>true<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>addClasspath</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>manifest</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>manifestEntries</span><span class=\"token punctuation\">></span></span>\n              <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>mode</span><span class=\"token punctuation\">></span></span>development<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>mode</span><span class=\"token punctuation\">></span></span>\n              <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>url</span><span class=\"token punctuation\">></span></span>${project.url}<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>url</span><span class=\"token punctuation\">></span></span>\n              <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>key</span><span class=\"token punctuation\">></span></span>value<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>key</span><span class=\"token punctuation\">></span></span>\n              <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Premain-Class</span><span class=\"token punctuation\">></span></span>com.theJava.MasulsaAgent<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Premain-Class</span><span class=\"token punctuation\">></span></span>\n              <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Can-Redefine-Classes</span><span class=\"token punctuation\">></span></span>true<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Can-Redefine-Classes</span><span class=\"token punctuation\">></span></span>\n              <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Can-Retransform-Classes</span><span class=\"token punctuation\">></span></span>true<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Can-Retransform-Classes</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>manifestEntries</span><span class=\"token punctuation\">></span></span>\n          <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>archive</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>configuration</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>plugin</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>여기서 다른 것보다 <code class=\"language-text\">&lt;Premain-Class></code> 와 <code class=\"language-text\">&lt;Can-Redefine-Classes></code>  그리고 <code class=\"language-text\">&lt;Can-Retransform-classes></code> 이 세 옵션을 주목하면 된다.</p>\n<p>그 후에 <code class=\"language-text\">mvn clean pakaging</code> 을 통해서 패키징을 수행한 뒤에 <code class=\"language-text\">javaagent</code> 를 우리가 만든 Jar파일에 등록을 한다.</p>\n<p>VM option에 해당 Jar 파일 경로로 등록한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">-javaagent:<span class=\"token punctuation\">{</span>Jar File Path<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이렇게 함으로써 클래스 로딩과 독립적으로 Class를 재정의하는 등 바이트코드 조작이 가능함을 알 수가 있다.</p>\n<p>이런 javaagent는 위에서도 말했듯이 Lombok 같은 어노테이션 프로세서나 다이나믹 프록시, 코드 커버리지 툴 등 다양한 방면에서 사용되고 있다.</p>\n<h1 id=\"step-5-어떤-핫스왑-도구를-사용할까\" style=\"position:relative;\"><a href=\"#step-5-%EC%96%B4%EB%96%A4-%ED%95%AB%EC%8A%A4%EC%99%91-%EB%8F%84%EA%B5%AC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C\" aria-label=\"step 5 어떤 핫스왑 도구를 사용할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 5. 어떤 핫스왑 도구를 사용할까?</h1>\n<p>위에서 다양한 핫스왑 도구들이 존재한다고 하였다.</p>\n<p>그렇다면 우리가 실제 코딩을 할 때 어떠한 핫스왑 도구를 사용하는게 좋을까?</p>\n<p>무엇이 됐던간에 제일 중요한 건 핫스왑 도구들의 한계를 알아야하는 것이 중요하다고 생각이 든다.</p>\n<p>핫스왑에이전트의 Feature부분을 살펴보자.</p>\n<p><a href=\"http://hotswapagent.org/#features\">http://hotswapagent.org/#features</a></p>\n<blockquote>\n<p>The only unsupported operation is hierarchy change (change the superclass or remove an interface).</p>\n</blockquote>\n<p>다른 핫스왑 도구인 spring-loaded 같은 경우에도 한계점이 있을까?</p>\n<blockquote>\n<p>Q. Does it reload anything that might change in a class file?</p>\n</blockquote>\n<blockquote>\n<p>A. No, you can’t change the hierarchy of a type. Also there are certain constructor patterns of usage it can’t actually handle right now.</p>\n</blockquote>\n<p>여기에도 명시가 되어있다.</p>\n<p>즉, 한계점을 알고 핫스왑 도구를 사용했을 때 발생할 수 있는 일에 대해서 대처를 할 수 있으면 사용하는 것이 맞다고 생각이 드나 무작정 편하다고 한계점과 어떤 핫스왑 기능들을 제공하는지 모른채로 사용한다면 오히려 디버깅이나 해당 도구를 사용했을 때 개발하는데 어려움이 생길 수 있다고 본다.</p>\n<h1 id=\"step-6-결론\" style=\"position:relative;\"><a href=\"#step-6-%EA%B2%B0%EB%A1%A0\" aria-label=\"step 6 결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 6. 결론</h1>\n<p>JVM 구조부터 시작하여 클래스 핫스왑 예제까지 살펴보았다.</p>\n<p>JVM 구조에서 힙이나 스택, PC에 관한 내용이나 GC에 대한 내용은 추후에 따로 포스팅을 해서 다뤄볼 예정이다.</p>\n<h1 id=\"step-7-reference\" style=\"position:relative;\"><a href=\"#step-7-reference\" aria-label=\"step 7 reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>STEP 7. Reference</h1>\n<ol>\n<li><a href=\"https://www.inflearn.com/course/the-java-code-manipulation\">Inflearn - 더 자바, 코드를 조작하는 다양한 방법</a></li>\n<li><a href=\"https://d2.naver.com/helloworld/1230\">JVM Internal - Naver D2</a></li>\n<li><a href=\"https://engkimbs.tistory.com/606\">Java 클래스 로딩 과정 - 새로비</a></li>\n<li><a href=\"https://futurists.tistory.com/43\">자바 동적로딩 이해(델리게이션 모델) - 미래학자</a></li>\n<li><a href=\"https://homoefficio.github.io/2018/10/13/Java-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%8D%94-%ED%9B%91%EC%96%B4%EB%B3%B4%EA%B8%B0/\">Java 클래스로더 훑어보기 - HomoEfficio</a></li>\n<li><a href=\"https://blog.naver.com/ehcibear314/221228200531\">컴파일러와 인터프리터 차이 - 얏구</a></li>\n<li><a href=\"https://blog.wanzargen.me/16?category=700063\">https://blog.wanzargen.me/16?category=700063</a></li>\n<li><a href=\"https://blog.wanzargen.me/17?category=700063\">자바의 메모리 구조 - 1. 메소드 영역 - WANZARGEN</a></li>\n<li><a href=\"https://resian-programming.tistory.com/63\">ClassLoacer의 특징과 종류 - Resian</a></li>\n<li><a href=\"https://velog.io/@agugu95/%EC%9E%90%EB%B0%94-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A1%9C%EB%94%A9%EA%B3%BC-%EC%86%8D%EB%8F%84-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EA%B8%B0%EB%B2%95%EB%93%A4\">자바 클래스 로딩, 그리고 리플렉션 - agugu95</a></li>\n<li><a href=\"https://m.blog.naver.com/PostView.nhn?blogId=tmakdlfwotjd&#x26;logNo=221300385855&#x26;categoryNo=55&#x26;proxyReferer=https:%2F%2Fwww.google.com%2F\">JVM(Java Virtual Machine) - 짠도리</a></li>\n<li><a href=\"https://javacan.tistory.com/entry/1\">클래스로더 1, 동적인 클래스 로딩과 클래스로더 - 자바캔(Java Can Do IT)</a></li>\n<li><a href=\"https://javacan.tistory.com/entry/2\">클래스로더 2, 자바2의 기본 클래스로더 - 자바캔(Java Can Do IT)</a></li>\n<li><a href=\"https://www.jrebel.com/blog/how-to-use-java-class-loaders\">How to Use Java Class Loaders - Jrebel Blog</a></li>\n<li><a href=\"https://www.developer.com/java/data/what-is-java-agent.html\">What Is Java Agent? - developer.com</a></li>\n<li><a href=\"https://dzone.com/articles/java-agent-1\">Understanding Java Agents - Dzone</a></li>\n<li><a href=\"https://www.xspdf.com/resolution/53249066.html\">Reload java classes without restarting the container - xspdf.com</a></li>\n</ol>","frontmatter":{"date":"December 29, 2020","title":"Fundamental of JVM and Class Loader in java - Java JVM과 Class Loader의 동작 과정 이해","categories":"개발","author":"개발한입","emoji":"💻"},"fields":{"slug":"/fundamental-jvm-classloader/"}},"site":{"siteMetadata":{"siteUrl":"https://brewagebear.github.io","comments":{"utterances":{"repo":"brewagebear/blog-comments"}}}}},"pageContext":{"slug":"/better-logging-with-redis/","nextSlug":"/review-essence-of-object-orientation/","prevSlug":"/fundamental-jvm-classloader/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}